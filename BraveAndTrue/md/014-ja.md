


Chapter 11


# core.asyncで並行(concurrent)処理をマスターする

ある日、道を歩いていると、ホットドッグの自動販売機を発見して、驚き、興味をそそられ、少しうんざりすることでしょう。 頭皮が好奇心でうずき、3ドル出してこの仕掛けが実際に動くかどうか確かめずにはいられなくなるでしょう。カチャカチャと音を立ててお金を受け取ると、バンズごと新鮮なホットドッグが出てきます。

![](hotdog-vending-machine.png)

自動販売機は、お金を受け取るとホットドッグを1つ出して、次の購入の準備をするという単純な行動をとります。ホットドッグがなくなると、停止する。私たちの周りには、様々な姿をしたホットドッグの自動販売機があり、独立した存在として、世界の出来事に同時に反応している。お気に入りのコーヒーショップのエスプレッソマシンも、子供のころに可愛がっていたペットのハムスターも、すべては「*x*が起こったら*y*する」という一般的な形式に従った一連の動作に分解することができるのである。私たちが書くプログラムでさえも、単なる栄光のホットドッグ自動販売機で、それぞれが独立したプロセスで、キーストローク、タイムアウト、あるいはソケット上のデータの到着など、次のイベントを待っているのです。

Clojureのcore.asyncライブラリにより、1つのプログラム内で複数の独立したプロセスを作成することができます。この章では、このスタイルのプログラミングについて考えるための便利なモデルと、実際にコードを書くために知っておくべき実用的な詳細について説明します。go ブロックと `thread` によって作成された独立したプロセス間で通信するためにチャネルを使用する方法、Clojure がパーキングとブロッキングでスレッドを効率的に管理する方法について少し、 `alts!!` の使用方法、そしてより簡単なキューの作成方法について学びます。最後に、プロセスパイプラインでコールバックの尻を蹴る方法を学びます。

## プロセス入門

core.asyncの中心は*process*で、イベントに応答するロジックの並列(concurrent)実行ユニットです。プロセスは、私たちの現実世界のメンタルモデルに対応しています。実体は、ある種の中央制御機構が糸を引くことなく、互いに独立して相互作用し、反応します。たとえば、機械にお金を入れると、ホットドッグが出てくるが、これはイルミナティやビッグブラザーが全体を指揮しているわけではない。このことは、あなたがこれまで探求してきた並列処理の考え方とは異なります。そこでは、制御のメインスレッドの単なる延長であるタスク（例えば、 `pmap` によるデータ並列化の実現）や、通信に興味のないタスク（例えば `future` で作成した一回限りのタスク）などを定義してきました。

自動販売機をプロセスとして考えるのは奇妙かもしれません。自動販売機は名詞的であり、モノであり、プロセスは動詞的であり、実行するものです。自動販売機は名詞的でモノ的、プロセスは動詞的でコト的です。正しい考え方をするために、現実世界のオブジェクトをイベントドリブンな振る舞いの総体として定義してみてください。種に水をやると芽が出る、母親が生まれたばかりの子供を見ると愛情を感じる、「スター・ウォーズ エピソード1」を見ると怒りと絶望に包まれる、などです。超哲学的なことを言うなら、あらゆるものの本質を、それが認識する事象とそれにどう反応するかの集合として定義することが可能かどうかを考えてみてください。現実とは、ホットドッグの自動販売機の構成要素に過ぎないのだろうか？

とにかく、私のおしゃべりはもう十分だ。それでは、理論的な話から具体的な話へと、いくつかの簡単なプロセスを作ってみましょう。まず、`lein new app playsync`で*playsync*という新しいライニンゲンプロジェクトを作成します。次に、ファイル *project.clj* を開いて、`:dependencies` ベクトルに core.async を追加して、以下のようになるようにします。



```
[[org.clojure/clojure "1.9.0"]
[org.clojure/core.async "0.1.346.0-17112a-alpha"]]
```



`注` これを書いてから core.async のバージョンが上がっている可能性があります。最新のバージョンについては、core.asyncのGitHubプロジェクトページで確認してください。しかし、この演習の目的では、ここに記載されているバージョンを使用してください。

次に、*src/playsync/core.clj*を開き、以下のような形にする。



```
(ns playsync.core
  (:require [clojure.core.async
             :as a
             :refer [>! <! >!! <!! go chan buffer close! thread
                     alts! alts!! timeout]]))
```



これで、REPLでこれを開くと、よく使うcore.asyncの関数が自由に使えるようになります。素晴らしい ホットドッグの自動販売機のような洗練された革命的なものを作る前に、受け取ったメッセージを単純に表示するようなプロセスを作りましょう。



```
(def echo-chan (chan))
(go (println (<! echo-chan)))
(>!! echo-chan "ketchup")
; => true
; => ketchup
```



コードの最初の行で、あなたは `chan` 関数を使って `echo-chan` という名前の *channel* を作りました。channel は *messages* を通信します。channelにメッセージを*put*し、channelからメッセージを*take*することができます。プロセスはputとtakeの完了を*wait*する--これらはプロセスが反応するイベントである。プロセスは2つのルールを持っていると考えることができます。1) チャネルにメッセージを置いたり、チャネルからメッセージを取り出したりしようとするとき、putやtakeが成功するまで何もしないで待つ、2) putやtakeが成功したら、処理を続行する。

次の行では、`go`を使って新しいプロセスを作成しています。`go`式の中にあるものはすべて、*goブロック*と呼ばれ、別のスレッドで同時に実行されます。go ブロックは、マシンのコア数の 2 倍に等しい数のスレッドを含むスレッドプールでプロセスを実行します。つまり、プログラムはプロセスごとに新しいスレッドを作成する必要がないのです。スレッドの作成に伴うオーバーヘッドを避けることができるため、多くの場合、パフォーマンスが向上します。

この場合、`(println (<! echo-chan))`という処理は、"`echo-chan`からメッセージを受け取ったら、それを表示する。"ということを表現している。この処理は別のスレッドに振り分けられ、現在のスレッドが解放され、REPLとのやりとりを続けることができるようになります。

`(<! echo-chan)`という表現では、`<!`は*take*関数です。これは、引数として与えたチャネルをリッスンし、それが属するプロセスは、他のプロセスがチャネルにメッセージを置くまで待ちます。 `<!`が値を取得すると、その値が返され、`println`式が実行される。

式 `(>!!! echo-chan "ketchup")` は、文字列 `"ketchup" `を `echo-chan` に *put* して `true` を返します。チャネルにメッセージを置くと、他のプロセスがそのメッセージを受け取るまでプロセスがブロックされます。 この場合、REPLプロセスは全く待つ必要がありませんでした。なぜなら、すでにチャネルをリッスンしているプロセスがあり、チャネルから何かを受け取るのを待っていたからです。しかし、次のようにすると、REPLは無限にブロックされることになります。



```
(>!! (chan) "mustard")
```



新しいチャネルを作成し、そこに何かを置いたが、そのチャネルをリッスンしているプロセスはない。プロセスはメッセージを受け取るのを待つだけでなく、チャネルに置いたメッセージが受け取られるのを待つこともあります。

### バッファリング

前の演習では、`go`で作成したプロセスとREPLプロセスという、*2つの*プロセスを含んでいたことは注目に値します。これらのプロセスはお互いのことを明示的に知っているわけではなく、独立して行動しています。

これらのプロセスは食堂で行われると想像してみよう。REPL はケチャップのシェフで、バッチを完成させると "ケチャップ！" と叫びます。他のスタッフは外でオーガニックガーデンのオレガノに見とれており、シェフはただ座って誰かがケチャップを取りに来るのを待つだけということもあり得る。一方、「GO」プロセスはスタッフの一人を表しており、彼は何か反応があるのをじっと待っている。何も起こらず、レストランが閉まるまでただひたすら待つということもあり得る。

ケチャップのシェフが、ケチャップを作る前に、自分の作ったケチャップが誰かに飲まれるのをじっと待っているなんて、そんなバカなことがあるでしょうか？このような悲劇を避けるために、バッファード・チャンネルを作成することができます。



```
(def echo-buffer (chan 2))
(>!! echo-buffer "ketchup")
; => true
(>!! echo-buffer "ketchup")
; => true
(>!! echo-buffer "ketchup")
; This blocks because the channel buffer is full
```



(最後の `(>!!! echo-buffer "ketchup")` はREPLをブロックしてしまうので、評価に注意してください。Leiningen REPLを使っている場合は、`ctrl-C`でブロックが解除されます)。

この場合、バッファサイズ2のチャンネルを作成したことになります。つまり、2つの値は待たずにチャネルに置くことができますが、3つ目の値を置くと、他のプロセスがチャネルから値を取得するまでプロセスが待機することになります。また、`sliding-buffer`で*sliding*バッファを作成することができ、これは先入れ先出し方式で値をドロップします。これらのバッファはいずれも `>!!` をブロックさせることはない。

バッファを使うことで、ケチャップの名人は、スタッフがケチャップを取り上げるのを待つことなく、おいしいケチャップのバッチを作り続けることができるのです。通常のバッファを使用する場合は、ケチャップの束を置く棚があるようなもので、棚がいっぱいになると、スペースが空くのを待つ必要があります。スライド式バッファーの場合、棚がいっぱいになったら一番古いケチャップを捨て、ケチャップをすべてスライドさせて、空いたスペースに新しいケチャップを置く。ドロップバッファーの場合は、一番新しいバッチを棚から叩き落として、そのスペースに新しいバッチを置く。

プロセスは、イベントに応答する独立した同時実行可能なロジックの単位である、という核となるモデルの精緻化に過ぎない。プロセスは独立した、同時に実行されるロジックの単位で、イベントに反応します。goブロックでプロセスを作成し、チャネルでイベントを伝達することができます。

### ブロッキングとパーキング

take関数 `<!` は感嘆符を1つだけ使っているのに対し、put関数 `>!!` は2つ使っていることに気づかれたかもしれません。実は、putにもtakeにも、感嘆符が1つのものと2つのものがあるのです。いつ、どちらを使うのでしょうか？簡単に言うと、goブロックの中では感嘆符を1つ使うことができますが、goブロックの外では感嘆符を2つ使わなければなりません。

            go blockの内側     go blockの外側
  ------ ----------------- ------------------
  put    `>!` or `>!!`     `>!!`
  take   `<!` or `<!!`     `<!!`

すべては効率に帰結します。goブロックは固定サイズのスレッドプールを使用するため、1,000個のgoプロセスを作成しても、わずかなスレッドしか使用しません。



```
(def hi-chan (chan))
(doseq [n (range 1000)]
  (go (>! hi-chan (str "hi " n))))
```



Clojureがどのようにこれを達成するかを理解するために、プロセスがどのように*wait*するのかを探る必要があります。待ち時間は、core.asyncプロセスで作業する際の重要な側面です。我々はすでに、*put*は他のプロセスが同じチャネルで*take*を行うまで待ち、その逆も同様であることを確立しています。この例では、1,000個のプロセスが、`hi-chan`から別のプロセスがtakeするのを待っている。

待ち時間には2種類ある。*パーキング*とブロッキング*です。ブロッキングは、みなさんがよくご存知の待ち時間で、タスクが完了するまでスレッドの実行を停止します。通常、これはある種のI/O操作をしているときに起こります。スレッドは生きていますが、何もしないので、プログラムを継続的に動作させたい場合は、新しいスレッドを作成する必要があります。第9章では、`future`を使ってこれを行う方法を学びました。

Parkはスレッドを解放して、処理を続けられるようにします。例えば、1つのスレッドと2つのプロセス、プロセスAとプロセスBがあるとします。プロセスAはスレッド上で実行され、putまたはtakeを待ちます。ClojureはプロセスAをスレッドから移動させ、プロセスBをスレッドに移動させます。プロセスBが待ち始めて、プロセスAの put または take が終了した場合、ClojureはプロセスBをスレッドから移動し、プロセスAをスレッドに戻します。パーキングは、複数のスレッドを使用することで1つのコアでインターリーブ（間隔を空けること）ができるのと同じように、複数のプロセスからの命令を1つのスレッドでインターリーブすることを可能にします。パーキングの実装は重要ではありません。パーキングはgoブロック内でのみ可能で、`>!`と`<!`、または*parking put*と*parking take*を使用する場合にのみ可能であるとだけ言っておけば十分です。また、`>!!`と`<!!`は、*ブロック put*と*ブロック take*です。

### thread

プロセスがputやtakeを行うまでに長い時間を要する場合など、parkingの代わりにblockingを使用したい場合が確実にあり、そのような場合には`thread`を使用する必要があります。



```
(thread (println (<!! echo-chan)))
(>!! echo-chan "mustard")
; => true
; => mustard
```



`thread`は `future` とほぼ同じように動作します。新しいスレッドを作成し、そのスレッドで処理を実行します。`future` とは異なり、 `thread` はデリファレンスできるオブジェクトを返す代わりに、チャネルを返します。`thread` のプロセスが停止すると、そのプロセスの戻り値は `thread` が返すチャネルに置かれる。



```
(let [t (thread "chili")]
  (<!! t))
; => "chili"
```



この場合、プロセスはイベントを待たず、すぐに停止する。このプロセスの戻り値は `"chili"` で、これは `t.` に束縛されたチャンネルに置かれます。 我々は `t` から受け取り、 `"chili"` を返します。

長時間実行するタスクを実行するときに go ブロックの代わりに `thread` を使うべき理由は、スレッドプールを詰まらせないようにするためです。 巨大なファイルをダウンロードして保存し、そのファイルパスをチャンネルに載せるプロセスを4つ実行しているとします。プロセスがファイルをダウンロードし、これらのファイルを保存している間、Clojureはそれらのスレッドをパークすることができません。最後のステップ、プロセスがファイルのパスをチャネルに置くときだけ、スレッドをパークできます。したがって、スレッドプールに4つのスレッドしかない場合、4つのスレッドすべてがダウンロードに使用され、ダウンロードの1つが終了するまで他のプロセスの実行が許可されない。

`go`、`thread`、`chan`、`<!`、`<!!`、`>!`、`>!!`はプロセスの作成と通信のために使用するコアツールである。put と take は、与えられたチャネルでその補完が行われるまでプロセスを待機させる。`go` を使うと、put と take のパーキング機能を利用することができ、パフォーマンスを向上させることができるかもしれません。put や take の前に長時間実行されるタスクを実行する場合は、 `thread` と共に blocking のバージョンを使用する必要があります。

これで、あなたの心の欲望を満たして、お金をホットドッグに変えるマシンを作るのに必要なものはすべて揃ったはずです。

## 憧れのホットドッグマシンのプロセス

見よ、あなたの夢が現実になる



```
(defn hot-dog-machine
  []
  (let [in (chan)
        out (chan)]
    (go (<! in)
        (>! out "hot dog"))
    [in out]))
```



この関数は、お金を受け取るための `in` チャンネルと、ホットドッグを提供するための `out` チャンネルを作成します。そして、`go`で非同期プロセスを作成し、お金を待ち、ホットドッグを配ります。最後に、`in` と `out` のチャンネルをベクターとして返します。

ホットドッグの時間だ!



```
(let [[in out] (hot-dog-machine)]
  (>!! in "pocket lint")
  (<!! out))
; => "hot dog"
```



このスニペットでは、`let`を使ったデストラクチャリング（第3章で説明）を使って、`in`と`out`チャンネルを`in`と`out`シンボルに結びつけています。そして、`in`チャンネルに `"pocket lint"` を配置します。`"pocket lint"`が到着すると、ホットドッグマシンのプロセスは実行を再開し、`out`チャネルに`"hot dog"`を置く。

ちょっと待てよ......それはおかしいぞ。つまり、ホットドッグは無料だが、このマシンがポケットリントを支払いとして受け取ることに、誰かが怒るに違いない。しかも、この機械はホットドッグが1個しか出てこないと停止してしまう。そこで、ホットドッグマシンの機能を変更して、ホットドッグの数を指定できるようにし、「3」の数字を与えるとホットドッグが1つだけ出てくるようにしてみましょう。



```
(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             ➊(if (= 3 input)
                (do (>! out "hot dog")
                    (recur (dec hc)))
                (do (>! out "wilted lettuce")
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))
```



ここにはもっとたくさんのコードがありますが、戦略は簡単です。新しい関数 `hot-dog-machine-v2` は `hot-dog-count` を指定することができる。➊のgoブロック内では、`in`チャンネルに数字3（3ドルの意）が置かれた場合のみホットドッグが配られ、それ以外の場合は、ホットドッグではない、しおれたレタス(wilted lettuce)が配られる。あるプロセスが出力を受け取ると、ホットドッグマシンのプロセスはホットドッグの数を更新してループバックし、再びお金を受け取ることができるようになる。

マシンプロセスがホットドッグを使い果たすと、プロセスは➋でチャネルを*close*します。チャンネルをcloseすると、そのチャンネルでputを行うことができなくなり、closeしたチャンネルからすべての値を取り出したら、その後のtakeはすべて`nil.`を返すようになります。

リスト11-1でアップグレードされたホットドッグマシンに、お金とポケットリントを投入して試してみましょう。



```
(let [[in out] (hot-dog-machine-v2 2)]
  (>!! in "pocket lint")
  (println (<!! out))

  (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (<!! out))
; => wilted lettuce
; => hotdog
; => hotdog
; => nil
```



1.  リスト11-1. 堅牢なホットドッグの自動販売機プロセスとのインタラクション

まず、ポケットリントのトリックを試すと、しおれたレタス(wilted lettuce)が出てきます。次に、3ドルを2回投入すると、2回ともホットドッグがもらえる。次に、もう1回3ドルを入れようとするが、チャンネルが閉じているため無視される、3という数字はチャンネルに入れられない。`out`チャンネルからお金を取ろうとすると、チャンネルが閉じているため、やはり「`nil`」が表示されます。`hot-dog-machine-v2`について、いくつかの興味深い点にお気づきでしょう。 まず、put と take を同じ go ブロックの中で行っています。これはそれほど珍しいことではなく、プロセスの*パイプライン*を作成する方法の1つです：あるプロセスの*in*チャネルを別のプロセスの*out*チャネルにするだけです。 次の例では、文字列を一連の処理に渡して変換を行い、最後の処理で文字列が表示されるようにしています。


```
(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (>! c2 (clojure.string/upper-case (<! c1))))
  (go (>! c3 (clojure.string/reverse (<! c2))))
  (go (println (<! c3)))
  (>!! c1 "redrum"))
; => MURDER
```



プロセスパイプラインと、コールバックの代わりにパイプラインを使用する方法については、この章の終わり頃に詳しく説明するつもりです。

リスト11-1に戻りましょう! もう1つの注意点は、ホットドッグマシンは、あなたが払い出したものを処理するまで、それ以上のお金を受け取らないということです。このように、チャネル操作の完了が状態遷移のトリガーとなるような、ステートマシンのような振る舞いをモデル化することが可能です。例えば、自動販売機は2つの状態を持っていると考えることができます。*お金を受け取る準備ができている状態*と、*品物を受け取った状態*です。お金を入れることと、商品を取ることが、この2つの間の遷移を引き起こす。

## alts!!

The core.async function `alts!!` lets you use the result of the first successful channel operation among a collection of operations. We did something similar to this with delays and futures in "Delays" on page 198. In that example, we uploaded a set of headshots to a headshot-sharing site and notified the headshot owner when the first photo was uploaded. Here's how you'd do the same with `alts!!`:



```
(defn upload
  [headshot c]
  (go (Thread/sleep (rand 100))
      (>! c headshot)))

➊ (let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (upload "serious.jpg" c1)
  (upload "fun.jpg" c2)
  (upload "sassy.jpg" c3)
➋   (let [[headshot channel] (alts!! [c1 c2 c3])]
    (println "Sending headshot notification for" headshot)))
; => Sending headshot notification for sassy.jpg
```



Here, the `upload` function takes a headshot and a channel, and creates a new process that sleeps for a random amount of time (to simulate the upload) and then puts the headshot on the channel. The `let` bindings and `upload` function calls beginning at ➊ should make sense: we create three channels and then use them to perform the uploads.

Things get interesting at ➋. The `alts!!` function takes a vector of channels as its argument. This is like saying, "Try to do a blocking take on each of these channels simultaneously. As soon as a take succeeds, return a vector whose first element is the value taken and whose second element is the winning channel." In this case, the channel associated with *sassy.jpg* received a value first. The other channels are still available if you want to take their values and do something with them. All `alts!!` does is take a value from the first channel to have a value; it doesn't touch the other channels.

One cool aspect of `alts!!` is that you can give it a *timeout channel*, which waits the specified number of milliseconds and then closes. It's an elegant mechanism for putting a time limit on concurrent operations.  Here's how you could use it with the upload service:



```
(let [c1 (chan)]
  (upload "serious.jpg" c1)
  (let [[headshot channel] (alts!! [c1 (timeout 20)])]
    (if headshot
      (println "Sending headshot notification for" headshot)
      (println "Timed out!"))))
; => Timed out!
```



In this case, we set the timeout to 20 milliseconds. Because the upload didn't finish in that time frame, we got a timeout message.

You can also use `alts!!` to specify put operations. To do that, place a vector inside the vector you pass to `alts!!`, like at ➊ in this example:



```
(let [c1 (chan)
      c2 (chan)]
  (go (<! c2))
➊   (let [[value channel] (alts!! [c1 [c2 "put!"]])]
    (println value)
    (= channel c2)))
; => true
; => true
```



Here you're creating two channels and then creating a process that's waiting to perform a take on `c2`. The vector that you supply to `alts!!` tells it, "Try to do a take on `c1` and try to put `"put!"` on `c2`. If the take on `c1` finishes first, return its value and channel.  If the put on `c2` finishes first, return `true` if the put was successful and `false` otherwise." Finally, the result of `value` (which is `true`, because the `c2` channel was open) prints and shows that the channel returned was indeed `c2`.

Like `<!!` and `>!!`, `alts!!` has a parking alternative, `alts!`, which you can use inside go blocks. `alts!` is a nice way to exercise some choice over which of a group of channels you put or take from. It still performs puts and takes, so the same reasons to use the parking or blocking variation apply.

And that covers the core.async basics! The rest of the chapter explains two common patterns for coordinating processes.

## Queues

In "Rolling Your Own Queue" on page 202, you wrote a macro that let you queue futures. Processes let you use a similar technique in a more straightforward manner. Let's say you want to get a bunch of random quotes from a website and write them to a single file. You want to make sure that only one quote is written to a file at a time so the text doesn't get interleaved, so you put your quotes on a queue. Here's the full code:



```
(defn append-to-file
  "Write a string to the end of a file"
  [filename s]
  (spit filename s :append true))

(defn format-quote
  "Delineate the beginning and end of a quote because it's convenient"
  [quote]
  (str "=== BEGIN QUOTE ===\n" quote "=== END QUOTE ===\n\n"))

(defn random-quote
  "Retrieve a random quote and format it"
  []
  (format-quote (slurp "http://www.braveclojure.com/random-quote")))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (<! c))))
    (dotimes [n num-quotes] (go (>! c (random-quote))))))
```



The functions `append-to-file`, `format-quote`, and `random-quote` have docstrings that explain what they do. `snag-quotes` is where the interesting work happens. First, it creates a channel that's shared between the quote-producing processes and the quote-consuming process.  Then it creates a process that uses `while true` to create an infinite loop. On every iteration of the loop, it waits for a quote to arrive on `c` and then appends it to a file. Finally, `snag-quotes` creates a `num-quotes` number of processes that fetch a quote and then put it on `c`. If you evaluate `(snag-quotes "quotes" 2)` and check the *quotes* file in the directory where you started your REPL, it should have two quotes:



```
=== BEGIN QUOTE ===
Nobody's gonna believe that computers are intelligent until they start
coming in late and lying about it.
=== END QUOTE ===

=== BEGIN QUOTE ===
Give your child mental blocks for Christmas.
=== END QUOTE ===
```



This kind of queuing differs from the example in Chapter 9. In that example, each task was handled in the order it was created. Here, each quote-retrieving task is handled in the order that it finishes. In both cases, you ensure that only one quote at a time is written to a file.

## Escape Callback Hell with Process Pipelines

In languages without channels, you need to express the idea "when *x* happens, do *y*" with `callbacks`. In a language like JavaScript, callbacks are a way to define code that executes asynchronously once other code finishes. If you've worked with JavaScript, you've probably spent some time wallowing in *callback hell*.

The reason it's called callback hell is that it's very easy to create dependencies among layers of callbacks that aren't immediately obvious.  They end up sharing state, making it difficult to reason about the state of the overall system as the callbacks get triggered. You can avoid this depressing outcome by creating a process pipeline. That way, each unit of logic lives in its own isolated process, and all communication between units of logic occurs through explicitly defined input and output channels.

In the following example, we create three infinitely looping processes connected through channels, passing the *out* channel of one process as the *in* channel of the next process in the pipeline:



```
(defn upper-caser
  [in]
  (let [out (chan)]
    (go (while true (>! out (clojure.string/upper-case (<! in)))))
    out))

(defn reverser
  [in]
  (let [out (chan)]
    (go (while true (>! out (clojure.string/reverse (<! in)))))
    out))

(defn printer
  [in]
  (go (while true (println (<! in)))))

(def in-chan (chan))
(def upper-caser-out (upper-caser in-chan))
(def reverser-out (reverser upper-caser-out))
(printer reverser-out)

(>!! in-chan "redrum")
; => MURDER

(>!! in-chan "repaid")
; => DIAPER
```



By handling events using processes like this, it's easier to reason about the individual steps of the overall data transformation system.  You can look at each step and understand what it does without having to refer to what might have happened before it or what might happen after it; each process is as easy to reason about as a pure function.

## Additional Resources

Clojure's core.async library was largely inspired by Go's concurrency model, which is based on the work by Tony Hoare in *Communicating Sequential* *Processes* and is available at *<http://www.usingcsp.com/>.*

Rob Pike, co-creator of Go, has a good talk on concurrency, which is available at *<https://www.youtube.com/watch?v=f6kdp27TYZs>*.

ClojureScript, also known as the best thing to happen to the browser, uses core.async. No more callback hell! You can learn about ClojureScript at *[https://github.com/clojure/clojurescript](https://github.com/clojure/clojurescript%3C/span%3E)*.

Finally, check out the API docs at *<http://clojure.github.io/core.async/>*.

## Summary

In this chapter, you learned about how core.async allows you to create concurrent processes that respond to the put and take communication events on channels. You learned about how to use `go` and `thread` to create concurrent processes that wait for communication events by parking and blocking. You also learned how to create process pipelines by making the *out* channel of one process the *in* channel of another, and how this allows you to write code that's way more intelligible than nested callbacks. Finally, you meditated on whether or not you're just a fancy hot dog vending machine.

