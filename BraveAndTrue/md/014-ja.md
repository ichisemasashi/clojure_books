


Chapter 11


# core.asyncで並行(concurrent)処理をマスターする

ある日、道を歩いていると、ホットドッグの自動販売機を発見して、驚き、興味をそそられ、少しうんざりすることでしょう。 頭皮が好奇心でうずき、3ドル出してこの仕掛けが実際に動くかどうか確かめずにはいられなくなるでしょう。カチャカチャと音を立ててお金を受け取ると、バンズごと新鮮なホットドッグが出てきます。

![](hotdog-vending-machine.png)

自動販売機は、お金を受け取るとホットドッグを1つ出して、次の購入の準備をするという単純な行動をとります。ホットドッグがなくなると、停止する。私たちの周りには、様々な姿をしたホットドッグの自動販売機があり、独立した存在として、世界の出来事に同時に反応している。お気に入りのコーヒーショップのエスプレッソマシンも、子供のころに可愛がっていたペットのハムスターも、すべては「*x*が起こったら*y*する」という一般的な形式に従った一連の動作に分解することができるのである。私たちが書くプログラムでさえも、単なる栄光のホットドッグ自動販売機で、それぞれが独立したプロセスで、キーストローク、タイムアウト、あるいはソケット上のデータの到着など、次のイベントを待っているのです。

Clojureのcore.asyncライブラリにより、1つのプログラム内で複数の独立したプロセスを作成することができます。この章では、このスタイルのプログラミングについて考えるための便利なモデルと、実際にコードを書くために知っておくべき実用的な詳細について説明します。go ブロックと `thread` によって作成された独立したプロセス間で通信するためにチャネルを使用する方法、Clojure がパーキングとブロッキングでスレッドを効率的に管理する方法について少し、 `alts!!` の使用方法、そしてより簡単なキューの作成方法について学びます。最後に、プロセスパイプラインでコールバックの尻を蹴る方法を学びます。

## プロセス入門

core.asyncの中心は*process*で、イベントに応答するロジックの並列(concurrent)実行ユニットです。プロセスは、私たちの現実世界のメンタルモデルに対応しています。実体は、ある種の中央制御機構が糸を引くことなく、互いに独立して相互作用し、反応します。たとえば、機械にお金を入れると、ホットドッグが出てくるが、これはイルミナティやビッグブラザーが全体を指揮しているわけではない。このことは、あなたがこれまで探求してきた並列処理の考え方とは異なります。そこでは、制御のメインスレッドの単なる延長であるタスク（例えば、 `pmap` によるデータ並列化の実現）や、通信に興味のないタスク（例えば `future` で作成した一回限りのタスク）などを定義してきました。

自動販売機をプロセスとして考えるのは奇妙かもしれません。自動販売機は名詞的であり、モノであり、プロセスは動詞的であり、実行するものです。自動販売機は名詞的でモノ的、プロセスは動詞的でコト的です。正しい考え方をするために、現実世界のオブジェクトをイベントドリブンな振る舞いの総体として定義してみてください。種に水をやると芽が出る、母親が生まれたばかりの子供を見ると愛情を感じる、「スター・ウォーズ エピソード1」を見ると怒りと絶望に包まれる、などです。超哲学的なことを言うなら、あらゆるものの本質を、それが認識する事象とそれにどう反応するかの集合として定義することが可能かどうかを考えてみてください。現実とは、ホットドッグの自動販売機の構成要素に過ぎないのだろうか？

とにかく、私のおしゃべりはもう十分だ。それでは、理論的な話から具体的な話へと、いくつかの簡単なプロセスを作ってみましょう。まず、`lein new app playsync`で*playsync*という新しいライニンゲンプロジェクトを作成します。次に、ファイル *project.clj* を開いて、`:dependencies` ベクトルに core.async を追加して、以下のようになるようにします。



```
[[org.clojure/clojure "1.9.0"]
[org.clojure/core.async "0.1.346.0-17112a-alpha"]]
```



`注` これを書いてから core.async のバージョンが上がっている可能性があります。最新のバージョンについては、core.asyncのGitHubプロジェクトページで確認してください。しかし、この演習の目的では、ここに記載されているバージョンを使用してください。

次に、*src/playsync/core.clj*を開き、以下のような形にする。



```
(ns playsync.core
  (:require [clojure.core.async
             :as a
             :refer [>! <! >!! <!! go chan buffer close! thread
                     alts! alts!! timeout]]))
```



これで、REPLでこれを開くと、よく使うcore.asyncの関数が自由に使えるようになります。素晴らしい ホットドッグの自動販売機のような洗練された革命的なものを作る前に、受け取ったメッセージを単純に表示するようなプロセスを作りましょう。



```
(def echo-chan (chan))
(go (println (<! echo-chan)))
(>!! echo-chan "ketchup")
; => true
; => ketchup
```



コードの最初の行で、あなたは `chan` 関数を使って `echo-chan` という名前の *channel* を作りました。channel は *messages* を通信します。channelにメッセージを*put*し、channelからメッセージを*take*することができます。プロセスはputとtakeの完了を*wait*する--これらはプロセスが反応するイベントである。プロセスは2つのルールを持っていると考えることができます。1) チャネルにメッセージを置いたり、チャネルからメッセージを取り出したりしようとするとき、putやtakeが成功するまで何もしないで待つ、2) putやtakeが成功したら、処理を続行する。

次の行では、`go`を使って新しいプロセスを作成しています。`go`式の中にあるものはすべて、*goブロック*と呼ばれ、別のスレッドで同時に実行されます。go ブロックは、マシンのコア数の 2 倍に等しい数のスレッドを含むスレッドプールでプロセスを実行します。つまり、プログラムはプロセスごとに新しいスレッドを作成する必要がないのです。スレッドの作成に伴うオーバーヘッドを避けることができるため、多くの場合、パフォーマンスが向上します。

この場合、`(println (<! echo-chan))`という処理は、"`echo-chan`からメッセージを受け取ったら、それを表示する。"ということを表現している。この処理は別のスレッドに振り分けられ、現在のスレッドが解放され、REPLとのやりとりを続けることができるようになります。

`(<! echo-chan)`という表現では、`<!`は*take*関数です。これは、引数として与えたチャネルをリッスンし、それが属するプロセスは、他のプロセスがチャネルにメッセージを置くまで待ちます。 `<!`が値を取得すると、その値が返され、`println`式が実行される。

式 `(>!!! echo-chan "ketchup")` は、文字列 `"ketchup" `を `echo-chan` に *put* して `true` を返します。チャネルにメッセージを置くと、他のプロセスがそのメッセージを受け取るまでプロセスがブロックされます。 この場合、REPLプロセスは全く待つ必要がありませんでした。なぜなら、すでにチャネルをリッスンしているプロセスがあり、チャネルから何かを受け取るのを待っていたからです。しかし、次のようにすると、REPLは無限にブロックされることになります。



```
(>!! (chan) "mustard")
```



新しいチャネルを作成し、そこに何かを置いたが、そのチャネルをリッスンしているプロセスはない。プロセスはメッセージを受け取るのを待つだけでなく、チャネルに置いたメッセージが受け取られるのを待つこともあります。

### バッファリング

前の演習では、`go`で作成したプロセスとREPLプロセスという、*2つの*プロセスを含んでいたことは注目に値します。これらのプロセスはお互いのことを明示的に知っているわけではなく、独立して行動しています。

これらのプロセスは食堂で行われると想像してみよう。REPL はケチャップのシェフで、バッチを完成させると "ケチャップ！" と叫びます。他のスタッフは外でオーガニックガーデンのオレガノに見とれており、シェフはただ座って誰かがケチャップを取りに来るのを待つだけということもあり得る。一方、「GO」プロセスはスタッフの一人を表しており、彼は何か反応があるのをじっと待っている。何も起こらず、レストランが閉まるまでただひたすら待つということもあり得る。

ケチャップのシェフが、ケチャップを作る前に、自分の作ったケチャップが誰かに飲まれるのをじっと待っているなんて、そんなバカなことがあるでしょうか？このような悲劇を避けるために、バッファード・チャンネルを作成することができます。



```
(def echo-buffer (chan 2))
(>!! echo-buffer "ketchup")
; => true
(>!! echo-buffer "ketchup")
; => true
(>!! echo-buffer "ketchup")
; This blocks because the channel buffer is full
```



(最後の `(>!!! echo-buffer "ketchup")` はREPLをブロックしてしまうので、評価に注意してください。Leiningen REPLを使っている場合は、`ctrl-C`でブロックが解除されます)。

この場合、バッファサイズ2のチャンネルを作成したことになります。つまり、2つの値は待たずにチャネルに置くことができますが、3つ目の値を置くと、他のプロセスがチャネルから値を取得するまでプロセスが待機することになります。また、`sliding-buffer`で*sliding*バッファを作成することができ、これは先入れ先出し方式で値をドロップします。これらのバッファはいずれも `>!!` をブロックさせることはない。

バッファを使うことで、ケチャップの名人は、スタッフがケチャップを取り上げるのを待つことなく、おいしいケチャップのバッチを作り続けることができるのです。通常のバッファを使用する場合は、ケチャップの束を置く棚があるようなもので、棚がいっぱいになると、スペースが空くのを待つ必要があります。スライド式バッファーの場合、棚がいっぱいになったら一番古いケチャップを捨て、ケチャップをすべてスライドさせて、空いたスペースに新しいケチャップを置く。ドロップバッファーの場合は、一番新しいバッチを棚から叩き落として、そのスペースに新しいバッチを置く。

プロセスは、イベントに応答する独立した同時実行可能なロジックの単位である、という核となるモデルの精緻化に過ぎない。プロセスは独立した、同時に実行されるロジックの単位で、イベントに反応します。goブロックでプロセスを作成し、チャネルでイベントを伝達することができます。

### ブロッキングとパーキング

take関数 `<!` は感嘆符を1つだけ使っているのに対し、put関数 `>!!` は2つ使っていることに気づかれたかもしれません。実は、putにもtakeにも、感嘆符が1つのものと2つのものがあるのです。いつ、どちらを使うのでしょうか？簡単に言うと、goブロックの中では感嘆符を1つ使うことができますが、goブロックの外では感嘆符を2つ使わなければなりません。

            go blockの内側     go blockの外側
  ------ ----------------- ------------------
  put    `>!` or `>!!`     `>!!`
  take   `<!` or `<!!`     `<!!`

すべては効率に帰結します。goブロックは固定サイズのスレッドプールを使用するため、1,000個のgoプロセスを作成しても、わずかなスレッドしか使用しません。



```
(def hi-chan (chan))
(doseq [n (range 1000)]
  (go (>! hi-chan (str "hi " n))))
```



Clojureがどのようにこれを達成するかを理解するために、プロセスがどのように*wait*するのかを探る必要があります。待ち時間は、core.asyncプロセスで作業する際の重要な側面です。我々はすでに、*put*は他のプロセスが同じチャネルで*take*を行うまで待ち、その逆も同様であることを確立しています。この例では、1,000個のプロセスが、`hi-chan`から別のプロセスがtakeするのを待っている。

待ち時間には2種類ある。*パーキング*とブロッキング*です。ブロッキングは、みなさんがよくご存知の待ち時間で、タスクが完了するまでスレッドの実行を停止します。通常、これはある種のI/O操作をしているときに起こります。スレッドは生きていますが、何もしないので、プログラムを継続的に動作させたい場合は、新しいスレッドを作成する必要があります。第9章では、`future`を使ってこれを行う方法を学びました。

Parkはスレッドを解放して、処理を続けられるようにします。例えば、1つのスレッドと2つのプロセス、プロセスAとプロセスBがあるとします。プロセスAはスレッド上で実行され、putまたはtakeを待ちます。ClojureはプロセスAをスレッドから移動させ、プロセスBをスレッドに移動させます。プロセスBが待ち始めて、プロセスAの put または take が終了した場合、ClojureはプロセスBをスレッドから移動し、プロセスAをスレッドに戻します。パーキングは、複数のスレッドを使用することで1つのコアでインターリーブ（間隔を空けること）ができるのと同じように、複数のプロセスからの命令を1つのスレッドでインターリーブすることを可能にします。パーキングの実装は重要ではありません。パーキングはgoブロック内でのみ可能で、`>!`と`<!`、または*parking put*と*parking take*を使用する場合にのみ可能であるとだけ言っておけば十分です。また、`>!!`と`<!!`は、*ブロック put*と*ブロック take*です。

### thread

プロセスがputやtakeを行うまでに長い時間を要する場合など、parkingの代わりにblockingを使用したい場合が確実にあり、そのような場合には`thread`を使用する必要があります。



```
(thread (println (<!! echo-chan)))
(>!! echo-chan "mustard")
; => true
; => mustard
```



`thread`は `future` とほぼ同じように動作します。新しいスレッドを作成し、そのスレッドで処理を実行します。`future` とは異なり、 `thread` はデリファレンスできるオブジェクトを返す代わりに、チャネルを返します。`thread` のプロセスが停止すると、そのプロセスの戻り値は `thread` が返すチャネルに置かれる。



```
(let [t (thread "chili")]
  (<!! t))
; => "chili"
```



この場合、プロセスはイベントを待たず、すぐに停止する。このプロセスの戻り値は `"chili"` で、これは `t.` に束縛されたチャンネルに置かれます。 我々は `t` から受け取り、 `"chili"` を返します。

長時間実行するタスクを実行するときに go ブロックの代わりに `thread` を使うべき理由は、スレッドプールを詰まらせないようにするためです。 巨大なファイルをダウンロードして保存し、そのファイルパスをチャンネルに載せるプロセスを4つ実行しているとします。プロセスがファイルをダウンロードし、これらのファイルを保存している間、Clojureはそれらのスレッドをパークすることができません。最後のステップ、プロセスがファイルのパスをチャネルに置くときだけ、スレッドをパークできます。したがって、スレッドプールに4つのスレッドしかない場合、4つのスレッドすべてがダウンロードに使用され、ダウンロードの1つが終了するまで他のプロセスの実行が許可されない。

`go`、`thread`、`chan`、`<!`、`<!!`、`>!`、`>!!`はプロセスの作成と通信のために使用するコアツールである。put と take は、与えられたチャネルでその補完が行われるまでプロセスを待機させる。`go` を使うと、put と take のパーキング機能を利用することができ、パフォーマンスを向上させることができるかもしれません。put や take の前に長時間実行されるタスクを実行する場合は、 `thread` と共に blocking のバージョンを使用する必要があります。

これで、あなたの心の欲望を満たして、お金をホットドッグに変えるマシンを作るのに必要なものはすべて揃ったはずです。

## 憧れのホットドッグマシンのプロセス

見よ、あなたの夢が現実になる



```
(defn hot-dog-machine
  []
  (let [in (chan)
        out (chan)]
    (go (<! in)
        (>! out "hot dog"))
    [in out]))
```



この関数は、お金を受け取るための `in` チャンネルと、ホットドッグを提供するための `out` チャンネルを作成します。そして、`go`で非同期プロセスを作成し、お金を待ち、ホットドッグを配ります。最後に、`in` と `out` のチャンネルをベクターとして返します。

ホットドッグの時間だ!



```
(let [[in out] (hot-dog-machine)]
  (>!! in "pocket lint")
  (<!! out))
; => "hot dog"
```



このスニペットでは、`let`を使ったデストラクチャリング（第3章で説明）を使って、`in`と`out`チャンネルを`in`と`out`シンボルに結びつけています。そして、`in`チャンネルに `"pocket lint"` を配置します。`"pocket lint"`が到着すると、ホットドッグマシンのプロセスは実行を再開し、`out`チャネルに`"hot dog"`を置く。

ちょっと待てよ......それはおかしいぞ。つまり、ホットドッグは無料だが、このマシンがポケットリントを支払いとして受け取ることに、誰かが怒るに違いない。しかも、この機械はホットドッグが1個しか出てこないと停止してしまう。そこで、ホットドッグマシンの機能を変更して、ホットドッグの数を指定できるようにし、「3」の数字を与えるとホットドッグが1つだけ出てくるようにしてみましょう。



```
(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             ➊(if (= 3 input)
                (do (>! out "hot dog")
                    (recur (dec hc)))
                (do (>! out "wilted lettuce")
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))
```



ここにはもっとたくさんのコードがありますが、戦略は簡単です。新しい関数 `hot-dog-machine-v2` は `hot-dog-count` を指定することができる。➊のgoブロック内では、`in`チャンネルに数字3（3ドルの意）が置かれた場合のみホットドッグが配られ、それ以外の場合は、ホットドッグではない、しおれたレタス(wilted lettuce)が配られる。あるプロセスが出力を受け取ると、ホットドッグマシンのプロセスはホットドッグの数を更新してループバックし、再びお金を受け取ることができるようになる。

マシンプロセスがホットドッグを使い果たすと、プロセスは➋でチャネルを*close*します。チャンネルをcloseすると、そのチャンネルでputを行うことができなくなり、closeしたチャンネルからすべての値を取り出したら、その後のtakeはすべて`nil.`を返すようになります。

リスト11-1でアップグレードされたホットドッグマシンに、お金とポケットリントを投入して試してみましょう。



```
(let [[in out] (hot-dog-machine-v2 2)]
  (>!! in "pocket lint")
  (println (<!! out))

  (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (<!! out))
; => wilted lettuce
; => hotdog
; => hotdog
; => nil
```



1.  リスト11-1. 堅牢なホットドッグの自動販売機プロセスとのインタラクション

まず、ポケットリントのトリックを試すと、しおれたレタス(wilted lettuce)が出てきます。次に、3ドルを2回投入すると、2回ともホットドッグがもらえる。次に、もう1回3ドルを入れようとするが、チャンネルが閉じているため無視される、3という数字はチャンネルに入れられない。`out`チャンネルからお金を取ろうとすると、チャンネルが閉じているため、やはり「`nil`」が表示されます。`hot-dog-machine-v2`について、いくつかの興味深い点にお気づきでしょう。 まず、put と take を同じ go ブロックの中で行っています。これはそれほど珍しいことではなく、プロセスの*パイプライン*を作成する方法の1つです：あるプロセスの*in*チャネルを別のプロセスの*out*チャネルにするだけです。 次の例では、文字列を一連の処理に渡して変換を行い、最後の処理で文字列が表示されるようにしています。


```
(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (>! c2 (clojure.string/upper-case (<! c1))))
  (go (>! c3 (clojure.string/reverse (<! c2))))
  (go (println (<! c3)))
  (>!! c1 "redrum"))
; => MURDER
```



プロセスパイプラインと、コールバックの代わりにパイプラインを使用する方法については、この章の終わり頃に詳しく説明するつもりです。

リスト11-1に戻りましょう! もう1つの注意点は、ホットドッグマシンは、あなたが払い出したものを処理するまで、それ以上のお金を受け取らないということです。このように、チャネル操作の完了が状態遷移のトリガーとなるような、ステートマシンのような振る舞いをモデル化することが可能です。例えば、自動販売機は2つの状態を持っていると考えることができます。*お金を受け取る準備ができている状態*と、*品物を受け取った状態*です。お金を入れることと、商品を取ることが、この2つの間の遷移を引き起こす。

## alts!!

core.asyncの関数 `alts!!` は、操作のコレクションの中で最初に成功したチャネル操作の結果を使用することができます。これと似たようなことを、198ページの「delay」でdelayとfutureを使ってやってみました。その例では、一連の写真を写真共有サイトにアップロードし、最初の写真がアップロードされたときに写真所有者に通知しています。以下は、`alts!!`で同じことをする方法です。



```
(defn upload
  [headshot c]
  (go (Thread/sleep (rand 100))
      (>! c headshot)))

➊ (let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (upload "serious.jpg" c1)
  (upload "fun.jpg" c2)
  (upload "sassy.jpg" c3)
➋   (let [[headshot channel] (alts!! [c1 c2 c3])]
    (println "Sending headshot notification for" headshot)))
; => Sending headshot notification for sassy.jpg
```



ここでは、`upload`関数が写真とチャネルを受け取り、ランダムな時間（アップロードをシミュレートするため）スリープする新しいプロセスを作成し、そのチャネルに写真 を置きます。`let` 束縛と `upload` 関数の呼び出しは ➊ で始まっていますが、これは意味があることです。

面白いのは➋のところです。`alts!!`関数は、引数としてチャネルのベクターを受け取ります。これは、「これらのチャンネルのそれぞれで同時にブロッキングを試してみてください。試行が成功したらすぐに、最初の要素が取得した値で、2番目の要素が成功したチャンネルであるベクトルを返します。」 と言っているようなものです。他のチャンネルは、その値を受け取って何かしたいのであれば、まだ利用可能です。`alts!!`が行うのは、最初に値を持ったチャンネルから値を受け取るだけで、他のチャンネルには手をつけません。この場合は、*sassy.jpg*に関連するチャンネルが最初に値を受け取っています。他のチャンネルは、その値を受け取って何かしたいのであれば、まだ利用可能です。`alts!!`が行うのは、最初に値を持ったチャンネルから値を受け取るだけで、他のチャンネルには手をつけません。

`alts!!`の1つのクールな側面は、*timeoutチャネル*を与えることができ、指定したミリ秒数だけ待って閉じます。これは、同時処理に時間制限を設けるためのエレガントなメカニズムです。 アップロードサービスでの使い方は以下の通りです。



```
(let [c1 (chan)]
  (upload "serious.jpg" c1)
  (let [[headshot channel] (alts!! [c1 (timeout 20)])]
    (if headshot
      (println "Sending headshot notification for" headshot)
      (println "Timed out!"))))
; => Timed out!
```



この場合、タイムアウトを20ミリ秒に設定しました。その時間内にアップロードが終わらなかったので、タイムアウトメッセージが表示されました。

また、`alts!!`を使って、put操作を指定することもできます。その場合は、この例の➊のように、`alts!!`に渡したベクターの内側にベクターを配置します：



```
(let [c1 (chan)
      c2 (chan)]
  (go (<! c2))
➊   (let [[value channel] (alts!! [c1 [c2 "put!"]])]
    (println value)
    (= channel c2)))
; => true
; => true
```



ここでは、2つのチャネルを作って、`c2`に対する処理を待っているプロセスを作っています。`alts!!`に供給するベクトルは、`c1`で処理を行い、`c2`で `"put!"` を実行しようとします。もし `c1` の処理が先に終了したら、その値とチャネルを返す。 `c2`へのputが先に終了した場合、putが成功した場合は`true`を、そうでない場合は`false`を返します。" 最後に `value` の結果 (`c2` チャネルが開いていたので `true` です) が表示され、返されたチャネルが確かに `c2` であることがわかります。

`<!!` や `>!!` と同様に、 `alts!!` には代替のパーキングである `alts!` があり、goブロックの中で使用することができます。`alts!`は、複数のチャネルからプットまたはテイクするチャネルを選択するのに便利な方法です。これはまだputとtakeを実行するので、parkingやblockingのバリエーションを使用するのと同じ理由が適用されます。

これで、core.asyncの基本をカバーしたことになります！この章の残りの部分では、プロセスを調整するための2つの一般的なパターンを説明します。

## キュー (待ち行列)

202ページの「独自のキューを作る」では、futureをキューに入れるためのマクロを書きました。Processes を使うと、同じようなテクニックをもっと簡単に使うことができます。例えば、あるウェブサイトからランダムな引用文の集まりを取得し、それを1つのファイルに書き込むとします。一度に1つの引用文しかファイルに書き込まれないようにして、テキストが交錯しないようにしたいので、引用文をキューに入れる。以下は、その完全なコードです：



```
(defn append-to-file
  "ファイルの末尾に文字列を書き込む"
  [filename s]
  (spit filename s :append true))

(defn format-quote
  "便利なので引用の最初と最後を区切る"
  [quote]
  (str "=== BEGIN QUOTE ===\n" quote "=== END QUOTE ===\n\n"))

(defn random-quote
  "ランダムな引用を取得し、それを整形する"
  []
  (format-quote (slurp "http://www.braveclojure.com/random-quote")))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (<! c))))
    (dotimes [n num-quotes] (go (>! c (random-quote))))))
```



関数 `append-to-file`、`format-quote`、`random-quote` には、その動作を説明するドキュメントがあります。`snag-quotes`は、興味深い作業が行われる場所です。まず、引用を生成するプロセスと引用を消費するプロセスの間で共有されるチャネルを作成する。 そして、`while true`を使って無限ループを作るプロセスを作成します。ループの各繰り返しで、`c`に引用文が来るのを待ち、それをファイルに追加する。最後に、`snag-quotes`は、引用符を取得して `c` に置くプロセスを `num-quotes` 個作成する。`(snag-quotes "quotes" 2)` を評価し、REPLを起動したディレクトリにある *quotes* ファイルを確認すると、2つのクォートがあるはずです：



```
=== BEGIN QUOTE ===
Nobody's gonna believe that computers are intelligent until they start
coming in late and lying about it.
=== END QUOTE ===

=== BEGIN QUOTE ===
Give your child mental blocks for Christmas.
=== END QUOTE ===
```



このようなキューイングは、第9章の例とは異なります。その例では、各タスクは作成された順に処理されていた。ここでは、各引用データを取り出すタスクは、それが終了した順に処理されます。どちらの場合も、一度に1つの引用だけがファイルに書き込まれるようにします。

## プロセスパイプラインでコールバック地獄から抜け出す

チャネルを持たない言語では、「*x*が起きたら、*y*をする」という考えを `callback` で表現する必要があります。JavaScriptのような言語では、コールバックは、他のコードが終了したら非同期で実行するコードを定義する方法である。JavaScriptを使ったことがある人なら、おそらく*コールバック地獄*に悩まされる時間を過ごしたことがあるのではないでしょうか。

コールバック地獄と呼ばれる理由は、コールバックのレイヤーの間に、すぐにはわからない依存関係を作るのが非常に簡単だからです。 コールバックは状態を共有することになり、コールバックがトリガーされたときにシステム全体の状態を推論することが難しくなります。このような憂鬱な結果を避けるには、プロセスパイプラインを作成する必要があります。そうすることで、ロジックの各ユニットはそれぞれ独立したプロセスに住み、ロジックのユニット間の通信はすべて、明示的に定義された入出力チャネルを介して行われます。

次の例では、チャネルを介して接続された3つの無限ループプロセスを作成し、あるプロセスの*out*チャネルをパイプラインの次のプロセスの*in*チャネルとして渡します：



```
(defn upper-caser
  [in]
  (let [out (chan)]
    (go (while true (>! out (clojure.string/upper-case (<! in)))))
    out))

(defn reverser
  [in]
  (let [out (chan)]
    (go (while true (>! out (clojure.string/reverse (<! in)))))
    out))

(defn printer
  [in]
  (go (while true (println (<! in)))))

(def in-chan (chan))
(def upper-caser-out (upper-caser in-chan))
(def reverser-out (reverser upper-caser-out))
(printer reverser-out)

(>!! in-chan "redrum")
; => MURDER

(>!! in-chan "repaid")
; => DIAPER
```



このようにプロセスを用いてイベントを処理することで、データ変換システム全体の各ステップについて、より簡単に説明することができます。 各ステップを見れば、その前に何が起こったか、その後に何が起こるかを参照することなく、それが何をするのかを理解することができます。各プロセスは、純粋な関数と同じくらい簡単に推論することができます。

## 追加情報

Clojureのcore.asyncライブラリは、Goの同時実行モデルに大きく触発されました。このモデルは、Tony Hoareによる「*Communicating Sequential* *Processes*」の研究に基づき、*<http://www.usingcsp.com/>.*で入手できます。

Goの共同開発者であるRob Pikeは、同時実行に関する良い講演をしており、*<https://www.youtube.com/watch?v=f6kdp27TYZs>*で入手可能です。

ブラウザに起こる最高の出来事として知られるClojureScriptは、core.asyncを使用しています。もうコールバック地獄はありません！ClojureScriptについては、*[https://github.com/clojure/clojurescript](https://github.com/clojure/clojurescript%3C/span%3E)*で学ぶことができます。

最後に、*<http://clojure.github.io/core.async/>*でAPIドキュメントをチェックしてください。

## まとめ

本章では、core.async を使って、チャネル上の通信イベント put と take に応答する並行処理を作成する方法について学びました。また、`go`と`thread`を使用して、パーキングとブロッキングによって通信イベントを待機する並行プロセスを作成する方法について学びました。また、あるプロセスの*out*チャンネルを別のプロセスの*in*チャンネルにすることで、プロセスパイプラインを作成する方法を学び、これにより、ネストされたコールバックよりもはるかに分かりやすいコードを書くことができることを学びました。最後に、あなたは自分が単なる高級ホットドッグの自動販売機なのかどうか、考えてみた。

