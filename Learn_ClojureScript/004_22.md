[UP](004_00.md)

### レッスン 22：状態の管理

このレッスンは長い時間をかけて行われてきたものであり、非常に重要なものです。ここまでで、可変型データを使用せずにアプリケーション全体を書くことが可能であることがわかりましたが、ほとんどの場合、控えめに言っても不便です。前回のレッスンで学んだように、ClojureScriptでは、純粋に関数型のコアを副作用のあるコードで囲むようにプログラムを書くことが推奨されていますが、これには状態を更新するコードも含まれます。実用的な言語であるClojureScriptは、時間とともに変化する値を扱うためのいくつかの構成要素を提供します。

-----
**このレッスンでは**

- アトムを使って時間とともに変化する値を管理する
- 状態の変化を観察して反応する
- トランジェントを使用して高性能な変異を実現する
-----

#### アトム

何度も見てきたように、ClojureScriptでは、主に不変の値を変換する純粋な関数としてプログラムを書くことが推奨されています。また、これがやや面倒であることもわかりました。ClojureScriptでは、純粋さよりも実用性を重視するという哲学に基づき、時間とともに変化する状態を表現するための便利なツール、アトムを提供しています。アトムは、任意の時点で単一の不変的な値を保持できるコンテナです。しかし、アトムが参照する値は、別の値と入れ替えることができます。さらに、このような状態の入れ替えが起こるたびに、コードはそれを観察することができます。これにより、時間とともに変化する状態を処理する便利な方法が得られます。

JavaScriptとは異なり、ClojureScriptでは、アイデンティティとステートの考え方を分けています(*1)。アイデンティティとは、論理的なエンティティへの参照です。その実体は時間の経過とともに変化することがありますが、川が時間の経過とともに異なる水が流れてもその同一性を保つのと同じように、その同一性を保ちます。アイデンティティは、時間の経過とともにさまざまな値と結びつく可能性があり、その値が状態である。アトムは、CloureScriptでアイデンティティを表現するために使用する状態コンテナです。

![state-river.png](imgs4/state-river.png)
川の状態は時間とともに変化する

##### `swap!`で状態を更新

私たちが学ぶことのできるアイデンティティの最も些細な例は、低俗なカウンタです。カウンタは、時間の経過とともに増加する数値を状態とするアイデンティティです。アトムの初期状態となる値を`v`とすると、`(atom v)`を呼び出すだけで、任意のclojureの値をアトムで包むことができます。

```Clojure
(def counter (atom 0))
```

アトムはある時点での値への参照を提供するので、`deref`マクロまたはその短縮形である`@`を使用することで、参照を解除することができます。

```Clojure
counter                                                    ;; <1>
;; => #object[cljs.core.Atom {:val 0}]

(deref counter)                                            ;; <2>
;; => 0

@counter                                                   ;; <3>
;; => 0
```
アトムの参照解除

1. アトムは、値を包むオブジェクトです。
2. アトムは`deref`を使って再参照できます。
3. アトムの名前の前に `@` を付けると、 `deref` を呼び出すことができます。

もちろん、アトムを使って何か有用なことをするためには、アトムの状態を更新できなければなりません。そのためには、`swap!`関数を使います。`swap!`はアトムと変換を受け取ります。関数はアトムの現在の状態を与えられ、その新しい状態を返さなければなりません。`swap!`自体はアトムの新しい状態を返します。`swap!`への追加の引数はすべて、変換関数への追加の引数として渡されます。単純なカウンタの場合、`inc`で増加させたり、`+`で一度に1以上の値を加えることができます。

```Clojure
(swap! counter inc)

@counter
;; => 1

(swap! counter + 9)

@counter
;; => 10
```

アトムは、状態を更新するための非常に制御されたメカニズムを提供するClojureScriptの方法です。アトムを参照解除しても、不変の値を得ることができ、アトムの状態が更新されても、受け取った値は変わりません。

```Clojure
(def creature
  (atom {:type "water"
         :life 50
         :abilities ["swimming" "speed"]}))

(def base-creature @creature)                              ;; <1>

(swap! creature update :abilities conj "night vision")

@creature                                                  ;; <2>
;; => {:type "water"
;;     :life 50
;;     :abilities ["swimming" "speed" "night vision"]}

base-creature                                              ;; <3>
;; => {:type "water"
;;     :life 50
;;     :abilities ["swimming", "speed"]}
```

1. `swap!`する前のアトムを新しい状態でデリファレンスする
2. `swap!`の後、アトムの状態は変化している
3. 取得した初期状態は変化していません

また、バリデータとして機能する関数を用意し、`set-validator!`関数(*2)を使ってアトムにどのような値が許されるかを定義することもできます。バリデーター関数は、アトムの新しい値を受け取ります。この関数が false を返す (あるいはエラーを投げる) と、更新の試みは失敗し、エラーが発生します。例えば、creatureに負の `:life` 値を設定できないことを保証するために、この特性を保証するバリデータを提供することができます。

```Clojure
(set-validator! creature
  (fn [c] (>= (:life c) 0)))

(swap! creature assoc :life 10) ;; Ok

(swap! creature assoc :life -1) ;; Throws error

(:life @creature) ;; 10
```

先ほど説明したように、バリデータが false を返すような方法でアトムの状態を更新すると、 例外が発生して更新が行われません。バリデータはClojureScriptではあまり使われませんが、関数の事前・事後条件のように、開発時には便利なツールとなります。

**クイックレビュー**

- `swap!` はどんな値を返すの？
- バリデータ関数はどのようにして、ある状態を許可すべきか否かを示すのか?

##### 状態を`reset!`で置き換える

`swap!` はアトムの状態を変換するのに便利ですが、アトムの状態全体を一度に更新したい場合もあります。ClojureScriptの標準ライブラリを使えば、これは難しいことではありません: `(swap! counter (constantly 0))`. `constantly`は、呼び出されるたびに常に特定の値を返す関数を返すので、この場合は、どんな引数が与えられても常に0を返す関数を返し、カウンターの状態を実質的に0にリセットすることになります。しかし、このコードは巧くないので、ClojureScriptでは`reset!`関数も用意しています。この関数は、単にアトムと値を受け取り、それをアトムの新しい状態として設定します。swap! と同様に、この関数は新しい状態を返します。

[UP](004_00.md)

