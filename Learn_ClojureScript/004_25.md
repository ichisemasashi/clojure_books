[UP](004_00.md)

### レッスン 25：core.async の紹介

非同期プログラミングはWeb開発の中心に位置しています。ほとんど全てのアプリは、メインスレッドをブロックすることなく、APIバックエンドと通信したり、ユーザの入力に応答したり、他のIOタスクを実行する必要があります。JavaScriptのPromise APIをClojureScriptから使用することは可能ですが、非同期プログラミングのためのもう一つのパラダイムである`core.async`ライブラリを使用することができます。このライブラリは、Goプログラミング言語と同じ並行処理モデルを実装しており、コードを、相互に通信する必要があるかもしれないシーケンシャル・プロセスとして書くことができます。

-----
**このレッスンでは**

- CSP（ClojureScript（およびGo）の背後にある同時実行モデル）について学びます。
- 並列問題をプロセスの観点から考える
- プロセス間の通信にチャンネルを使用する
-----

#### CSPの概要

ClojureScriptの同時実行ライブラリは、1978年にTony Hoare氏によって記述されたCommunicating Sequential Processesという数学的プロセス計算（同時実行モデル）に基づいています。CSPの基本的な考え方は、それぞれが順序付けられた一連のステップを実行する、いくつかの独立したプロセスがあるというものです。これらのプロセスは、チャネルを介してメッセージを送受信することで相互に通信することができる。プロセスは、チャネルからメッセージを読みたい場合、メッセージが利用可能になるまでブロックし、その後、メッセージを消費して次に進みます。また、プロセスはチャネルにメッセージを同期または非同期で配置することができます。チャネルを介した通信を使用することで、複数のプロセスが同期し、あるプロセスが他のプロセスからの特定の入力を待ってから処理を進めることができます。

ClojureScriptでは、`core.async`ライブラリが、これらの非同期ワークフローを作成するために必要な機能を提供しています。新しい軽量プロセスを作成する`go`マクロ、チャネルを作成する`chan`マクロ、および演算子`<!` (take)、`>!` (put)、および `alts!` (多くのチャンネルの1つから取る)の演算子です。これらのプリミティブを使うだけで，非常に洗練された非同期通信パターンを作ることができます．`core.async`を使用する前に、少し戻ってCSPについて説明します。

CSPでは、基本的なオブジェクトは`process`です。プロセスとは、いくつかのステップを順番に実行できる匿名（無名）のコードであり、独自の制御フローを持つ可能性があります。`process`内のコードは常に同期的に実行されます。つまり、プロセスは前のステップが完了するまで次のステップには進みません。各プロセスは他のすべてのプロセスから独立しており、すべてのプロセスが同時に実行されます（どのプロセスをいつ実行するかのスケジューリングはClojureScriptが担当します）。最後に、通信はCSPの基本ですが、プロセスは必ずしも他のプロセスと通信する必要はありません。

![concurrent-processes.png](imgs4/concurrent-processes.png)
コンカレントなプロセス群

プロセスに続いて、CSPの次の重要なオブジェクトは、チャネル(*1)です。チャネルとは、あるプロセスから別のプロセスに値を伝達するための導管のことです。デフォルトでは、各チャネルは一度に1つの値しか伝えられません。つまり、あるプロセスがチャネルで値を送信すると、次にそのチャネルで送信しようとするプロセスは、他のプロセスがそのチャネルから値を取り出すまで、パークされます。さらに、空のチャネルから値を取ろうとすると、値が投入されるまで受信機がパークされます。また、チャネルには、そのチャネルから値が取り出されていない、指定された数の値を保持できるバッファを設けることができます。さらに、これらのバッファは、満杯になったらプロデューサーをパークするか（これがデフォルトの動作です）、新しい値を黙って破棄するか（`dropping-buffer`経由）、バッファ内の最も古い値をプッシュアウトするか（`sliding-buffer`経由）のいずれかです。

> 注意
>
> 空のチャネルから読み込んだり、満タンのチャネルに書き込もうとすると、プロセスがパークする可能性があることを述べました。プロセスから見ると、プロセスはブロックされており、チャネルの状態が変化するまで何の進展もありません。しかし、ClojureScriptランタイムの観点からは、他のプロセスは実行を続けることができ、パークされたプロセスは、チャネルの状態が変化すれば最終的に再開することができます。ClojureScriptはJavaScriptのシングルスレッドのコンテキストで実行され、プロセスをパーキングしてもそのスレッドはブロックされないので、ブロッキングという言葉は使わないようにしています。

![channel-sync.png](imgs4/channel-sync.png)
チャネルによる同期

プロセスとチャネルの仕組みを理解した上で、例を挙げてみましょう。例えば、SQLクエリのエディタを作っていて、ユーザがクエリの入力に集中してCtrl + Enterを押すたびに、クエリをサーバに送信して応答を待つとしましょう。キー入力を監視するプロセスと、ユーザーの入力を調整し、必要に応じてサーバーへのリクエストを実行するプロセスを用意します。

`core.async`はコアライブラリの一部ではなく、公式ライブラリとして公開されているため、使用したいプロジェクトの`deps.edn`に依存関係を追加する必要があります。

```Clojure
:deps {;; Other deps}
       org.clojure/core.async {:mvn/version "1.3.618"}}
```

#### 軽量プロセスとしてのGoブロック

ClojureScriptでは、実行するコードのブロックを含む`go`マクロを使ってプロセスを作成します。単純な`go`ブロックは以下のようになります。

```Clojure
(go (println "Hello Processes!"))
```

これにより、以下のJavaScriptコードと同様に、非同期的にコンソールに「Hello Processes！」と表示されます。

```JavaScript
setTimeout(() => console.log("Hello Processes!"), 0);
```

この`go`ブロックはいくつでも作ることができ、それらはすべて互いに独立して動作します。面白いのは、`go`ブロックにチャネルを導入するときです。次の例では、あるチャネルから値を読み込んで、ある述語を満たすものを別のチャネルに転送しています。これは本質的にはチャネルフィルターの操作です。

```Clojure
(go (loop []
  (let [val (<! in-ch)]                                    ;; <1>
    (when (pred? val)                                      ;; <2>
      (>! out-ch val)))                                    ;; <3>
  (recur)))
```
絞り込み(フィルタリング)プロセス

1. in-chから値を読み取る
2. pred?で値をテストする
3. 値をout-chに書き込む

この例は、`core.async`に共通するパラダイムを示しています。それは、無限にループするgoブロックを作成し、同じタスクを何度も実行することです。JavaScriptには、コードやコールバックを実行するグローバルイベントループがあるように、ごく一部の機能だけを実行するミニイベントループを作ることができます。実際、このように無限にループする処理パターンは非常に一般的で、`core.async`にはgoブロックと`loop`を組み合わせた`go-loop`マクロが用意されています。このマクロを使うと、私たちのコードは次のようになります。

```Clojure
(go-loop []
  (let [val (<! in-ch)]
    (when (pred? val)
      (>! out-ch val)))
  (recur))
```

各プロセスが独立して動作する様子を説明するために、`core.async`ライブラリが提供する`timeout`関数を利用することができます。この関数は、指定されたタイムアウト（ミリ秒単位）の後に閉じるチャネルを返します。2つのプロセスを作り、それぞれが指定された間隔でコンソールにログを出力するようにしてみましょう。

```Clojure
(go-loop []
  (<! (timeout 100))
  (println "Hello from process 1")
  (recur))

(go-loop []
  (<! (timeout 250))
  (println "Hello from process 2")
  (recur))
```

**クイックレビュー**

- 本当か嘘か？「各 go ブロックは、他の go ブロックが実行される前に必ず完了まで実行されます。」
- `(go (loop [] .... (recur)))`のより簡潔な書き方は？

#### チャネルでの通信

SQLクエリエディタの例に戻ると、キーボードの入力を聞いて、1つ以上の修飾キー（Ctrl、Alt、Shiftなど）と他のキーを組み合わせた「キーコード」のイベントをすべて発するプロセスを生成することができます。このためには、キーダウンとキーアップのイベントをリッスンして、チャネルに配置する必要があります。コードを検出すると、その結果を別のチャネルに配置します。

```Clojure
(def keydown-ch (chan))                                    ;; <1>
(gevent/listen js/document "keydown"
  #(put! keydown-ch (.-key %)))

(def keyup-ch (chan))                                      ;; <2>
(gevent/listen js/document "keyup"
  #(put! keyup-ch (.-key %)))

(def is-modifier? #{"Control" "Meta" "Alt" "Shift"})

(def chord-ch (chan))
(go-loop [modifiers []                                     ;; <3>
          pressed nil]
  (when (and (seq modifiers) pressed)                      ;; <4>
    (>! chord-ch (conj modifiers pressed)))
  (let [[key ch] (alts! [keydown-ch keyup-ch])]            ;; <5>
    (condp = ch
      keydown-ch (if (is-modifier? key)                    ;; <6>
                   (recur (conj modifiers key) pressed)
                   (recur modifiers key))
      keyup-ch (if (is-modifier? key)
                 (recur (filterv #(not= % key) modifiers)
                        pressed)
                 (recur modifiers nil)))))
```
キーコードの検出


1. 1つのチャネルにすべてのキーダウンイベントのキーを乗せる
2. 1つのチャネルにすべてのキーアップイベントのキーを乗せる
3. 押したままの修飾キーと、最後に押された他のキーを追跡する
4. 押されたキーの他に修飾キーがあれば、コードをchord-chチャネルに送る
5. keydown-chまたはkeyup-chチャネルの値を待つ
6. 押されたキーを追加したり、離されたキーを削除したりして、繰り返す

非同期に値を送る

再帰的なパスごとに状態を維持する`go-loop`の使用に加えて、ここでは`core.async`の新しい部分がいくつか出てきます。1つ目は、`put!` この関数は、非同期的にチャネルに値を入れます。通常のputとtakeの演算子（それぞれ`>!`と`<!`）は、goブロックの中でのみ実行されるように設計されています。一つの選択肢として、チャネルに値を置くたびに新しいgoブロックを立ち上げることができます。例えば、`keydown`リスナーは次のように書くことができました。







[UP](004_00.md)

