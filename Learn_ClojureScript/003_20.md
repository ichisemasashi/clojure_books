[UP](003_00.md)

### レッスン 20：キャップストーン 3 - 連絡帳

これまでの数回のレッスンでは、ClojureScriptでデータを扱うためのコアツールを学びました。まず、基本的なコレクションタイプであるリスト、ベクター、マップ、セットと、これらのコレクションを操作するための最も一般的な関数について学びました。次に、統一されたインターフェイスを使ってあらゆる種類のシーケンシャルデータを操作することができる、重要なシーケンス抽象化について詳しく見ていきます。次に、`reduce`関数と、一連のデータを集約するために使用される多くのケースについて学びました。最後に、現実世界の分析領域をモデル化するプロセスを説明しました。これらの知識を得て、次のキャップストーンプロジェクトを構築する準備ができました。今回は、[レッスン16](003_16.md)で触れた連絡帳の例を取り上げ、完全な実装であるClojureScript Contactsを構築します。

-----
このレッスンでは

- フレームワークを使わずに完全なClojureScriptアプリケーションを作る
- 単純なClojureScriptデータ構造からHTMLを構築する

-----

![contacts-screenshot.png](imgs3/contacts-screenshot.png)
ClojureScriptのContactsのスクリーンショット

このキャップストーンのコード全体をそのまま表示することはありませんが、完成したプロジェクトのコードは、この本のGitHubリポジトリで見ることができます。前回と同様に、新しいFigwheelプロジェクトを作成します。

```bash
$ clj -X:new :template figwheel-main :name learn-cljs/contacts :args '["+deps"]'
$ cd contacts
$ clj -A:fig:build
```

#### データのモデリング

このレッスンでは、前の章で学んだテクニックとパターンを使って、連絡帳のデータをモデリングします。このレッスンの目的は、これまでに学んだことを実践することであり、新しい内容を多く取り入れることではありません。主にマップとベクターを使ってデータをモデル化し、新しい連絡先を作成するためのコンストラクタ関数パターンを実装します。また、データを変換する簡単な関数を使って、UIが連絡先リストを更新するために必要な操作を実装します。それでは、データモデルを見ていきましょう。

##### エンティティの構築

連絡帳は連絡先の順番に並んだリストを表しているので、その順番に並んだリストを表すデータ構造が必要になりますが、すでに見たようにベクターがぴったりです。空の連絡先リストは、空のベクターとして定義でき、コンストラクタ関数は必要ありません。

```Clojure
(def contact-list [])
```

空のベクターでは面白くないので、そのベクターが保持する連絡先に注目してみましょう。それぞれの連絡先には、姓名、電子メールアドレス、都市名、州名、国名などの住所が必要です。これは以下のようなネストしたマップで簡単に対応することができます。

```Clojure
{:first-name "Phillip"
 :last-name "Jordan"
 :email "phil.j@hotmail.com"
 :address {:street "523 Sunny Hills Cir."
           :city "Springfield"
           :state "MI"
           :postal "11111"
           :country "USA"}}
```

新しい連絡先を作成するには、前回のレッスンで紹介したコンストラクタ・パターンのバリエーションを使用します。各フィールドを個別に渡すのではなく、連絡先を構成する0個以上のフィールドを含むことが期待されるマップを渡します。前回のレッスンで、`select-keys`関数が、マップと選択されるべきキーのコレクションを受け取り、選択されたキーだけがコピーされた新しいマップを返すことを思い出していただけると思います。この関数を使って入力をサニタイズし、連絡先に有効なキーだけが含まれるようにすることができます。

```Clojure
(defn make-contact [contact]
  (select-keys contact [:first-name :last-name :email :postal :address]))
```

アドレス自体はマップなので、アドレスの作成は別の関数にしましょう。そして、make-contact関数を更新して、このアドレスコンストラクタを使うようにします。

```Clojure
(defn make-address [address]
  (select-keys address [:street :city :state :country]))

(defn make-contact [contact]
  (let [clean-contact (select-keys contact [:first-name :last-name :email])]
    (if-let [address (:address contact)]
      (assoc clean-contact :address (make-address address))
      clean-contact)))
```

今回の`make-contact`の新バージョンでは、これまで見たことのない`if-let`という表現が導入されています。このマクロは`if`と同じように動作しますが、名前をテストされる値にバインドします（`let`のように）。`let`とは異なり、1つのバインドしか提供できません。コンパイル時には、このコードは以下のように展開されます(*1)。

```Clojure
(if (:address contact)
  (let [address (:address contact)]
    (assoc clean-contact :address (make-address address)))
  clean-contact)
```
`if-let`の変形

近々、似たようなマクロである`when-let`を使用する予定です。`if-let`のように、バインディングを提供することができ、`when`のように、バインディングされた値が非nilの場合のみ処理します。

しかし、ClojureScriptのスレッディングマクロの1つである `-> (pronounced "thread first")` を使用して、`make-contact`関数をもう少し簡潔で読みやすいものにすることができます。このマクロを使うと、深く入れ子になっている式を、より連続的に書くことができます。このマクロは、値と任意の数の関数呼び出しを受け取り、その値を各関数呼び出しの第一引数として注入します。この変換を実際に見てみると、その機能がより直感的に理解できるはずです。

```Clojure
(-> val                                                    ;; <1>
    (fn-1 :foo)                                            ;; <2>
    (fn-2 :bar :baz)                                       ;; <3>
    (fn-3))

(fn-3                                                      ;; <4>
  (fn-2
    (fn-1 val :foo)
    :bar :baz))
```
スレッドファーストの変換

1. `val`を値とし、以下の式をスレッドしていきます。
2. `fn-1`は`val`と`:foo`を引数として評価されます。
3. `fn-1`の評価結果は、`fn-2`の第1引数としてスレッドされます。
4. マクロは、`fn-1` → `fn-2` → `fn-3` と評価される入れ子式に書き換えられます。

このマクロは、コードの読みやすさを向上させるため、ClojureScriptのコードでは非常によく使われます。このマクロは、コードの読みやすさを向上させるため、一見すると連続しているように見えるが、「インサイドアウト」で評価されるコードを書くことができます。ClojureScriptには、他にもいくつかのスレッディングマクロがありますが、今は説明しませんが、使い方がわかったら説明します。

![thread-first.png](imgs3/thread-first.png)
スレッドファースト・マクロ

このマクロを使えば、make-contact関数をより明確にすることができます。

```Clojure
(defn maybe-set-address [contact]                          ;; <1>
  (if (:address contact)
    (update contact :address make-address)
    contact))

(defn make-contact [contact]
  (-> contact                                              ;; <2>
      (select-keys [:first-name :last-name :email])
      (maybe-set-address)))
```

1. アドレスを条件付きで構築するコードをリファクタリングする
2. `->`マクロを使って`make-contact`を書き換える

**クイックレビュー**

- if-letは複数のバインディングが可能ですか？例えば、このコードは何をするのでしょうか？
```Clojure
(if-let [contact (find-by-id 123)
     address (:address contact)]
(println "Address:" (format-address address)))
```

- 次の式を `->` マクロはどのように書き換えますか？
```Clojure
(let [input {:password "s3cr3t"}]
(-> input
  (assoc :password-digest (-> input :password digest))
  (dissoc :password)))
```

##### ステートトランジションの定義

コードで定義した連絡先の静的なリストを表示する以外のことをUIで行うためには、UIで何らかのインタラクションを可能にする必要があります。ここでも、UIコードの前に低レベルのドメインロジックを構築し、ClojureScriptが推奨するボトムアップ型のプログラミングスタイルを活用できるようにしています（小さくて細かい機能を、より大きくて便利な構造にまとめます）。

まず、ユーザーが新しい連絡先を連絡先リストに追加できるようにしたいとします。ある種のフォームデータを入力として受け取り、それをmake-contactコンストラクタに渡して、結果の連絡先をリストに追加することができます。引数としてコンタクトリストと入力データを渡して、新しいコンタクトリストを作成する必要があります。

```Clojure
(defn add-contact [contact-list input]
  (conj contact-list
        (make-contact input)))
```

これらの関数定義をREPLに貼り付けて、期待通りに機能するかどうかをテストすることができます。

```Clojure
cljs.user=> (-> contact-list                               ;; <1>
                (add-contact {:email "me@example.com"
                              :first-name "Me"
                              :address {:state "RI"}})
                (add-contact {:email "you@example.com"
                              :first-name "You"}))
[{:first-name "Me", :email "me@example.com"}
 {:first-name "You", :email "you@example.com"}]
```
REPLでテスト

1. 繰り返しになりますが、 `->` マクロはコードの読み書きを容易にします。

次に、リストから連絡先を削除する方法が必要になります。連絡先を格納するのにベクターを使用しているので、特定のインデックスの要素を削除するだけで済みます。

```Clojure
(defn remove-contact [contact-list idx]
  (vec                                                     ;; <1>
    (concat                                                ;; <2>
      (subvec contact-list 0 idx)                          ;; <3>
      (subvec contact-list (inc idx)))))
```
連絡先を削除する

1. `vec` : シーケンスをベクターに変換します。
2. `concat`は，渡されたシーケンスのすべての要素を順番に含む`seq`を返す
3. `subvec`は、与えられたベクターの一部を返します。

ここでは、まだ見たことのない新しい関数がいくつかあるので、それらが何をするのかを簡単に見てみましょう。まず、この関数の「内側」から、`subvec`を見てみましょう。この関数は、あるベクターのスライスを効率的に取得する方法を提供します。この関数には、2引数と3引数の形式があります。`(subvec v start)`と`(subvec v start end)`です。この関数は、JavaScriptの`Array.prototype.slice()`関数と同様に動作します。この関数は、元のベクターの`start`インデックスから始まり、`end`インデックスまでのすべての要素を含む新しいベクターを返します。`end`が指定されていない場合は、`start`から元のベクターの終了までのすべての要素が含まれます。

次に，`concat`です。この関数は、いくつかのシーケンスを受け取り、その引数のすべての要素を連結した新しい遅延(*2)`seq`を作成します。結果は`seq`なので、`vec`関数を使って結果をベクターに戻します。ClojureScriptの標準ライブラリの多くはシーケンスを抽象化して動作するため、結果をより特定のタイプのコレクションに変換する必要があることがよくわかります。

最後に、連絡帳を更新する際には、以前のバージョンを置き換えたいと思います。これは、更新された連絡先を、古いバージョンが占めていた`contact-list`の同じインデックスに配置するために、`assoc`を使用することで行うことができます。

```Clojure
(defn replace-contact [contact-list idx input]
  (assoc contact-list idx (make-contact input)))
```

**クイックレビュー**

- `vec`はシーケンスをベクターに変換すると言いました。シーケンスの抽象化について学んだことを踏まえて、`vec`にマップを渡すとどうなるでしょうか？セットの場合はどうでしょうか？

UIの作成

データモデルを扱うために必要なすべての関数を定義したので、アプリケーションのUIの作成に目を向けてみましょう。セクション5では、Reagentフレームワークを使用して高性能なUIを作成する方法を学びますが、今のところは、何か変更があるたびにアプリケーション全体を再レンダリングするという素朴な方法をとります。私たちのアプリケーションには、2つのメインセクションがあります。各連絡先の概要を表示する連絡先リストと、連絡先の詳細を表示/編集するための大きなペインです。

hiccupsライブラリを使用して、プレーンなClojureScriptデータ構造をHTML文字列に変換します。これにより、アプリケーションのインターフェイスをClojureScriptのデータ構造として表現し、ページの実際のDOMに対して非常にシンプルなインターフェイスを持つことができます。このライブラリを使用するためには、deps.ednの依存関係に追加する必要があります。




[UP](003_00.md)

