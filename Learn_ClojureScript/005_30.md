[UP](005_00.md)

### レッスン 30：キャップストーン5 - ノート

このセクションでは、ClojureScriptの知識をWebアプリケーションに応用するためのReagentフレームワークの使い方を学んできました。この最後の基礎講座では、再びプロジェクトを使って、Reagentとモジュール式アプリケーションデザインについて学んだことをまとめます。これまでの基礎講座と同様に、この講座でも、シーケンスの扱い方から状態管理や非同期通信まで、これまでに学んだことをすべて活用します。このレッスンの終わりには、メモを取るためのアプリケーションを一から作ることになります。前回のキャップストーンと同様、今回もフロントエンドのみを作成します。https://notes-api.learn-cljs.com/accounts にPOSTリクエストを発行することで得られる一連の認証情報を使って、https://notes.learn-cljs.com/api で実行されているAPIを利用することができます。

-----
**このレッスンでは**

- 柔軟なコンポーネントベースのUIを作る
- Reagentで状態管理を行う
- RESTful APIを利用する
-----

![cljs-notes-screenshot.png](imgs5/cljs-notes-screenshot.png)
CLJSノートのスクリーンショット

#### 私たちが作っているもの

このキャップストーンの動機は、必要に応じて簡単に拡張できるシンプルなメモ帳アプリケーションが欲しいという作者自身の願望から来ています。ユーザーはこのアプリケーションを使って、メモを取ったり、タグで分類したり、メモのコレクションを編集することができなければなりません。このアプリケーションのバックエンドAPIは、2つの理由から意図的に面白くないものになっています。

1. このアプリケーションのバックエンドAPIは、意図的に面白みのないものになっていますが、これには2つの理由があります。
2. このレッスンではUIの構築に重点を置いているので、APIによるノイズは少ない方が良いのです。

このアプリは、1人のユーザーが使用するように設計されており、認証や認可を必要としません。

#### 状態の管理

何を作ろうとしているのかがわかったところで、データをモデル化し、UIコンポーネントがそのデータにアクセスするために使用できるパターンを明らかにしましょう。

まずは、ノート、タグ、それらの間の関係など、UIの状態を表す基本的なモデルを作成します。データはサーバーから取得するので、データの保存方法やUIからのアクセス方法を決定する際には、サーバーのデータモデルを考慮する必要があります。ここでは、2つの主要なエンドポイントを使用します。すべてのノートを一覧表示する`/notes`と、すべてのタグを一覧表示する`/tags`です。しかし、ほとんどの現実世界のアプリでそうであるように、データはUIでの使用には理想的な形式ではないため、一般的に正規化と呼ばれるプロセスでデータを再形成します。

##### データの正規化

リレーショナルデータベース技術がもたらした主なアイデアの1つに、正規化という概念があります。正規化には技術的な定義がありますが、ここでは非公式な説明を使うことができます。正規のアプリケーション状態では、データはコピーではなく参照によって共有されるべきです。この目的のためには、ノートとタグを別々に保存し、それらの間のリンクのリストを維持することを意味します。さらに、ルックアップが効率的になるように、それらを構造化します。例えば、以下のようなAPIレスポンスを受け取ることができます。

```Clojure
[{:id 1
  :title "Books to Read"
  :content "..."
  :tags [{:id 2 :name "list"}
         {:id 3 :name "reading"}]}
 {:id 2
  :title "Groceries"
  :content "..."
  :tags [{:id 1 :name "food"}
         {:id 2 :name "list"}]}]
```

このデータ構造の最初の難点は、タグが各ノートの下に入れ子になっていることです。ノートを中心とした表示では問題ありませんが、タグを表示または編集する場合は、この構造は理想的ではありません。ノートをそのままにして、タグの別のコレクションを維持することもできます。しかし、タグを編集する際には、ノートの下に入れ子になっているタグのすべてのコピーに同じ編集を適用しなければなりません。ここでの解決策は、リレーショナル・データベース管理システムで多対多の関係を持つ場合と同じことをすることです。つまり、ノート、タグ、そしてそれらの間の関係に別々のコレクションを作成するのです。目標は、データを次のような形に変換することです。

```Clojure
{:notes                                                    ;; <1>
   {1 {:id 1
       :title "Books to Read"
       :content "..."}
    2 {:id 2
       :title "Groceries"
       :content "..."}}
 :tags
   {1 {:id 1 :name "food"}
    2 {:id 2 :name "list"}
    3 {:id 3 :name "reading"}}

 :notes-tags
   {:by-note-id                                            ;; <2>
     {1 [2 3]
      2 [1 2]}
    :by-tag-id
     {1 [2]
      2 [1 2]
      3 [1]}}}
```

1. 各エンティティは、簡単に検索できるように、IDでインデックス化されたマップに格納されます。
2. 参照は、検索しやすいように、各方向（ノート→タグ、タグ→ノート）ごとに別々のマップに格納されます。

このコードでは、重複を避けるという約束を完全には果たせていないことがわかるでしょう。各参照は事実上2回保存されています。1回は `:by-note-id` コレクションに、もう1回は `:by-tag-id` コレクションにです。しかし実際には、この重複を局所的に処理することで、ノートにタグを追加したり削除したりするのは簡単な操作になります。

このデータを再構築するためには、以下の操作を効率的に行えるようないくつかのインデックスを作成する必要があります。

1. 任意のノートやタグをIDで検索する
2. 任意のノートがあれば、それに対応するタグを検索する。
3. 任意のタグが与えられた場合、対応するノートを検索します。

タグとノートのリソースの場合、IDからリソースへのマップが必要です。各IDは一意であるため、任意のIDに対するリソースは1つしかありません。ClojureScriptの`group-by`関数は、ほぼ私たちが望むものです...しかし、完全ではありません。

```Clojure
cljs.user=> (def items [{:id 1 :title "foo"}
                        {:id 2 :title "bar"}])
#'cljs.user/items

cljs.user=> (group-by :id items)
 {1 [{:id 1, :title "foo"}],
  2 [{:id 2, :title "bar"}]}
```

`group-by`関数は、グループ関数`f`とコレクション`xs`を受け取り、`(f x)`から同じ`(f x)`を得たすべてのアイテムのベクターへのマップを返します。キーワードは一般的にグループ関数として使用され、同じキーワードのプロパティを持つすべてのアイテムがグループ化されます。各IDはそのグループに1つの要素を持つことがわかっているので、すべての値から最初の要素を取ることができます。ClojureScriptライブラリには、マップ内のすべての値を変換する関数は用意されていませんが、自明のこととして書くことができます。

```Clojure
(defn map-values [f m]
  (into {} (for [[k v] m] [k (f v)])))
```



[UP](005_00.md)
