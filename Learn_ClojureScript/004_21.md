[UP](004_00.md)

### レッスン 21：関数型プログラミングの概念

ClojureScriptは、関数型プログラミングとプラグマティズムの交点に位置しています。このレッスンでは、関数型言語であることの意味を深く考えてみましょう。関数型プログラミングとは、単に関数を値として使えるようにするだけのものではありません。その核となる重要な概念は、「合成可能性」「関数的純粋性」「不変性」です。コンポーザビリティ(合成可能性)とは、再利用可能な小さな部品から、より大きなモジュールやシステムを構築することを意味します。関数的純粋性の概念は、私たちの関数がグローバルな状態を変更したり、Webページを変更したりするような副作用を持たないことを意味します。不変性とは、変数をその場で変更するのではなく、変換された新しい値を生成することです。このレッスンの終わりには、ClojureScriptで関数型コードを書くことの意味をより深く理解することができるでしょう。

-----
**このレッスンでは**

- 小さな関数を大きな関数に合成するボトムアップ設計を適用する
- 関数的な純粋性によって、プログラムの推論を容易にする
- 関数型プログラミングで不変性が果たす重要な役割を学ぶ

-----

#### 小さな部品から動作を構成する

命令型プログラミングでは、ある種のミュータブルな状態を保持し、その状態を操作する関数を書くことが多い。オブジェクト指向プログラミングが導入した重要な洞察は、可変型の状態と、その状態を操作することが許されているメソッドをオブジェクトにカプセル化することで、プログラムの推論が容易になるということです。クリーンなオブジェクト指向コードは、単一の責任を持つメソッドに集約されます。これは表面的には良いことのように聞こえるかもしれませんが、多くの場合、私たちが望むよりも制限が多くなったり少なくなったりしてしまいます。制限が多いのは、複数のオブジェクト間で同じようなロジックを共有することが、かなりの複雑さを伴わないと難しいからです。また、これらのメソッドが属するオブジェクトの状態を変化させ、そのオブジェクト上のメソッドの将来の動作を呼び出し側が予期しない方法で変化させてしまう可能性があるため、思ったよりも制限が緩くなります。

オブジェクト指向プログラミングと同様に、関数型プログラミングでも1つのことを行う関数を書くことが推奨されていますが、上述の2つの欠点はありません。その代わり、関数はオブジェクトにカプセル化されていなくても、どんなデータでも操作することができるので、重複の少ないシンプルなコードになります。さらに、純粋な関数の定義では、いかなる状態も変更せず、その動作は変更可能な状態の影響を受けないため、その動作はすべての場合において明確に定義されています。

データが一般的なデータ構造（主にマップとリスト）を使ってモデル化され、共有された変更可能な状態に依存しない場合、非常に興味深いことが起こります：一握りの関数を様々な方法で構成することができるのです。実際、標準ライブラリの関数を組み合わせること以外は、ほとんど何もせずにプログラムを作成することができます。ここで、関数型プログラミングの優れたテキストに必ず登場する言葉を紹介し、この点を強調しておきます。

> "10個の関数が10個のデータ構造を操作するよりも、100個の関数が1つのデータ構造を操作する方が良い。"
>
>    -- アラン・パーリス

パーリス氏が言いたいのは、同じ共通のデータ型や抽象度で動作する関数が100個あれば、それらを組み合わせることで100以上のことができるということです。しかし、オブジェクト指向のように、メソッドを特定のオブジェクトクラスに結びつけると、動作を合成する方法はかなり限定されてしまいます。

このセクションの最後にグループチャットアプリケーションを作るので、ユーザーの「バッジ」（ニックネームと現在のオンライン状態）を表示するコンポーネントを考えてみましょう。

![user-badge.png](imgs4/user-badge.png)
ユーザー状態のバッジ

このコンポーネントは、いくつかの小さな合成可能なピースに分解することができます。まず、ユーザーのニックネームを取得する関数と、hiccupのような構造を`strong`タグで包んで太くする関数を書いてみましょう。

```Clojure
(def alan-p {:first-name "Alan"                            ;; <1>
             :last-name "Perlis"
             :online? false})

(defn nickname [entity]                                    ;; <2>
  (or (:nickname entity)
      (->> entity
           ((juxt :first-name :last-name))
           (s/join " "))))

(defn bold [child]                                         ;; <3>
  [:strong child])

(bold (nickname alan-p))
;; => [:strong "Alan Perlis"]
```

1. サンプルデータの定義
2. ユーザーのニックネームの抽出
3. DOMをボールドにする

次に、スタイリングのために特定の要素にクラスを追加したいことがわかっているので、hiccup風のタグにクラスを追加する関数を作成します。

```Clojure
(defn concat-strings [s1 s2]
  (s/trim (str s1 " " s2)))

(defn with-class [dom class-name]
  (if (map? (second dom))
    (update-in dom [1 :class] concat-strings class-name)
    (let [[tag & children] dom]
      (vec (concat [tag {:class class-name}]
                   children)))))
```

DOMを表現するためにプレーンなデータ構造を使っているので、この関数は標準ライブラリのデータ操作関数を使って書くことができます。実際、この関数はhiccup特有のものを全く参照していません。次に、ユーザーの`online?`フラグの値に基づいて、ユーザーバッジに"online"または"offline"のクラスを追加する関数を書きます。

```Clojure
(defn with-status [dom entity]
  (with-class dom
    (if (:online? entity) "online" "offline")))
```

なお、ここではユーザーの`online?`プロパティを検査していますが、将来的に追加したいチャットボットなどのエンティティにこの関数を使用することを妨げるものではありません。最後に、`user-status`コンポーネントを定義するには、先ほど作成したこれらの小さな構成要素だけで十分です。

```Clojure
(defn user-status [user]
  [:div {:class "user-status"}
    ((juxt
      (comp bold nickname)                                 ;; <1>
      (partial with-status                                 ;; <2>
               [:span {:class "status-indicator"}]))
     user)])
```

1. `comp`は、関数を合成した新しい関数を作成します。
2. `partial` は、すでにいくつかの引数が与えられている関数を作成します。

前回のレッスンで`juxt`を初めて見ましたが、この例ではさらに2つの関数があります。これらの関数はClojureScriptで非常によく使われており、小さな関数を組み合わせて大きなアプリケーションにするのに非常に便利です：`comp`と`partial`です。 `comp`は数学の関数合成に似た関数合成を行います。

$$\left(f \circ g\right)\left(x\right) = \left(f\left(g\left(x\right)\right)\right) $$
数学的な関数の合成

数学のように関数`f`と`g`を合成すると、次の例のように、ある引数`x`に適用すると`(g x)`と評価され、その結果が`f`の引数として渡される関数ができます。

```Clojure
(= ((comp f g) x)
   (f (g x)))
```
ClojureScriptにおける関数の合成

`comp`は、`->`マクロを逆に適用したものと考えることができます。ただし、関数のパイプライン全体を評価するのではなく、与えられた任意の入力に対してパイプラインを評価する新しい関数を生成します。ユーザーステータスコンポーネントの場合、`(comp bold nickname)` を使って、ユーザーを受け取り、そのユーザーのニックネームを太字で返す関数を作成します。この新しい関数は、各関数を右から左につなぐパイプラインと考えることができます。

![comp.png](imgs4/comp.png)
`comp`関数パイプライン










[UP](004_00.md)

