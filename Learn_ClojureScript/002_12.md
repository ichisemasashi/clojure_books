[UP](002_00.md)


### レッスン12：関数を使ってコードを再利用しよう

ClojureScriptは、関数型プログラミング言語です。関数型プログラミングのパラダイムは、私たちにスーパーパワーを与えてくれますが、好き嫌いは別として、コードの書き方にも一定の要求があります。関数型コードの意味するところ（不変データ、副作用の最小化など）についてはすでに説明しましたが、ここまでは関数とは何か、ましてや慣用的な使い方については勉強していませんでした。このレッスンでは、ClojureScriptにおける関数とは何かを定義し、その定義と使用方法を学びます。最後に、コードを別々の関数に分割する場合のベストプラクティスと、ClojureScriptで頻繁に遭遇する特殊なクラスの関数である再帰関数の使い方を見ていきます。

-----
このレッスンでは

- ClojureScriptの最も基本的なプログラミング構造を学ぶ
- 共通のコードを関数に抽出して美しいコードを書く
- 再帰関数を使って一般的な問題を解決する
-----

#### 関数について

あなたがこれまでに書いてきたプログラムを考えてみてください。主に企業向けのソフトウェアを書いている人もいるでしょう。ゲームを書いている人もいるでしょう。また、ウェブ上で素晴らしい体験を生み出すデザイナーの方もいらっしゃるでしょう。プログラムには非常に多くの種類がありますが、そのすべてを1つの共通した考え方に集約することができます。プログラムとは、データとして何らかの入力を受け、何らかの出力を生成するものです。企業向けソフトウェアでは、フォームを入力してデータベースの行を生成したり、データベースの行を入力して何らかのユーザーインターフェースを生成したりします。ゲームでは、マウスの動きやキーの押し方、仮想環境に関するデータを受け取り、ピクセルや音波の記述を生成する。インタラクティブなWebページも、ユーザーの入力を受けてマークアップやスタイルを生成します。

![programs-transform-data.png](imgs2/programs-transform-data.png)
プログラムがデータを変換する

これらのケースでは、プログラムは1つまたは複数のデータを他のデータに変換します。関数は、これらのデータ変換を記述するビルディングブロックです。関数は、他の関数を組み合わせて、より便利で高度な変換を行うことができます。

関数型プログラミングは、データの動きを記述するものだと考えることができます。データを割り当てたり変更したりするステートメントでアルゴリズムを考える命令型コードとは異なり、コードはプログラムの中をデータがどのように流れていくかを記述したものと考えることができるのです。このような宣言的なプログラムを書くための鍵となるのが関数です。各関数は、0個以上の入力値（引数）を持ち、必ず何らかの出力値を返します。(*1)

![function-transformation.png](imgs2/function-transformation.png)
関数は入力を出力にマッピングする

#### 関数の定義と呼び出し

文字列、数値、キーワードと同様に、ClojureScriptの関数は値です。これは、変数に割り当てたり、引数として他の関数に渡したり、他の関数から返したりできることを意味します。JavaScriptの関数も第一級の値であるため、JavaScriptのプログラマーにとっては目新しい概念ではありません。

```JavaScript
const removeBy = (pred) => {                               // <1>
    return list =>                                         // <2>
        list.reduce((acc, elem) => {
            if (pred(elem)) {
                return acc;
            }
            return acc.concat([elem]);
        }, []);
}

const removeReds = removeBy(                               // <3>
    product => product.color === 'Red'
);

removeReds([
    { sku: '99734N', color: 'Blue' },
    { sku: '99294N', color: 'Red' },
    { sku: '11420Z', color: 'Green' },
]);
```

1. 関数を変数に代入する `removeBy`
2. 関数を返す
3. 関数を他の関数の引数として渡す

このコードをClojureScriptに直訳すると、とてもわかりやすいものになります。

```Clojure
(def remove-by                                             ;; <1>
  (fn [pred]
    (fn [list]                                             ;; <2>
      (reduce (fn [acc elem]
                (if (pred elem) acc (conj acc elem)))
              []
              list))))

(def remove-reds                                           ;; <3>
  (remove-by (fn [product] (= "Red" (:color product)))))

(remove-reds
  [{:sku "99734N" :color "Blue"}
   {:sku "99294N" :color "Red"}
   {:sku "11420Z" :color "Green"}])
```

1. 関数の変数への代入、`remove-by`
2. 関数を返す
3. 関数を他の関数の引数として渡す

JavaScriptは、Lispの1つであるSchemeの機能の多くを念頭に置いて設計されているので、関数が両言語で似たような働きをすることは驚くことではありません。主な違いは、意味的なものではなく、構文的なものです。それでは、関数を定義するための構文を見てみましょう。

##### fnとdefn

関数は`fn`という特殊な形式で定義します。最も基本的なバージョンでは、`fn`はパラメータのベクトルと、評価するための1つまたは複数の式を受け取ります。関数が呼び出されると、引数はパラメータの名前に束縛され、関数の本体が評価されます。関数は、その本体に含まれる最後の式の値に評価されます。例として、1つの配列に2つ目の配列のすべての要素が含まれているかどうかを調べる関数を考えてみましょう。

```Clojure
(fn [xs test-elems]                                        ;; <1>
  (println "Checking whether" xs                           ;; <2>
           "contains each of" test-elems)
  (let [xs-set (into #{} xs)]                              ;; <3>
    (every? xs-set test-elems)))
```

1. 2つのパラメータを受け取る関数を宣言する
2. 最初の式は副作用がないか評価され，その結果は捨てられます．
3. 関数全体では，最後の式の値を受け取ります

この例では，パラメータベクトルと2つの式で構成されるボディを持つ `fn` の基本的な形式を示しています．最初の式は、いくつかのデバッグ情報を記録しており、意味のある値には評価されないことに注意してください。関数自体は最後の式の値を受け継ぎ，`xs` と `test-elems` は関数が呼び出されたときの実際の値で置換されます．

```Clojure
(let [xs-set (into #{} xs)]
  (every? xs-set test-elems))
```

**無名関数の略記法**

無名関数には、`fn`と名前付き引数リストを省略することでキー操作を数回減らすことができる、より簡潔な構文もあります。次の例では、この省略された構文を使用します。

```Clojure
#(let [xs-set (into #{} %1)]
   (every? xs-set %2)))
```

このように、関数自体は`#(...)`で定義され、各引数は、`%1`、`%2`などの位置で参照されます。関数が1つの引数しか取らない場合は、その引数は単に`%`で参照されます。

```Clojure
(#(str "Hello " %) "world")
;; => "Hello world"
```

この構文は便利ですが、意図がすぐにわかるような非常に小さな関数にしか使わないようにしましょう。通常のケースでは、名前付き引数の明確さを考慮して、少し長い構文を使用することをお勧めします。また、2つ以上の引数を取る関数では、この構文は必要以上に混乱を招くことが多いです。これはClojureScriptのコードではまだかなり一般的で、イベントコールバックによく使われます。

**名前付き関数の定義**

便利な関数を宣言したのに、名前がないので呼び出す方法がないことに気づいたかもしれません。ここで`defn`の出番です。`defn`は、関数を宣言すると同時に、それをvarにバインドするための略記法です。

```Clojure
(def contains-every?                                       ;; <1>
  (fn [xs test-elems]
    ;; function body...
    ))

(defn contains-every? [xs test-elems]                      ;; <2>
  ;; function body...
)
```

1. 無名関数をvar(`contains-every?`)にバインドする
2. 関数の定義とバインドを同時に行う `defn`

このように、`defn` は名前付きの関数を作りたいときに便利な略記法です。

プログラムをきれいに保つために、通常は関連する関数を名前空間にまとめます。`def`または`defn`を使って関数をvarにバインドすると、その関数はpublicになり、他の名前空間からも要求できるようになります。ClojureScriptでは、明示的にプライベートにしない限り(*3)、varはデフォルトでエクスポートされます。最高レベルの実装以外はすべて隠そうとするオブジェクト指向プログラミングとは異なり、Clojureは小さな関数を可視化して合成することを目的としています（しばしば異なる名前空間から）。名前空間と可視性については、[レッスン23](004_23.md)でさらに詳しく説明します。

##### `defn`のバリエーション

先ほど学んだ`defn`の基本形は最も一般的なものですが、いくつかの追加構文を使用することもできます。

**複数のアリティ**

まず、関数は複数のアリティを宣言することができます。これは、与えられた引数の数に応じて動作が変わるというものです。複数のアリティを宣言するには、各パラメータリストと関数本体を、関数名の後に別のリストで囲みます。

```Clojure
(defn my-multi-arity-fn
 ([a] (println "Called with 1 argument" a))                ;; <1>
 (                                                         ;; <2>
  [a b]                                                    ;; <3>
  (println "Called with 2 arguments" a b)                  ;; <4>
 )
 ([a b c] (println "Called with 3 arguments" a b c)))

(defn my-single-arity-fn [a]                               ;; <5>
  (println "I can only be called with 1 argument"))
```

1. 基本的な`defn`形式とは異なり、各関数の実装はリストで囲まれています。
2. 各関数の実装では，リストの最初の要素がパラメータ・ベクトル
3. ...その後に1つ以上の式が続き，そのアリティの実装の本体を形成します。
4. 単一アリティの関数では，関数本体を構成するパラメータと式はリストで囲む必要はありません．

複数アリティの関数は、デフォルトのパラメータを与えるためによく使われます。ショッピングカートに商品を追加する次のような関数を考えてみましょう。3項版では`product-id`と一緒に数量を指定することができ、2項版ではこの3項版をデフォルトの数量`1`で呼び出しています。

```Clojure
(defn add-to-cart
 ([cart id] (add-to-cart cart id 1))
 ([cart id quantity]
  (conj cart {:product (lookup-product id)
              :quantity quantity})))
```

ClojureScriptの関数は、明示的に宣言されたアリティでしか呼び出すことができないので、これはJavaScriptとは驚くべき違いがある部分です。つまり、1つのパラメータで宣言された関数は1つの引数でしか呼び出すことができず、2つのパラメータで宣言された関数は2つの引数でしか呼び出すことができない、といった具合です。

ドックストリング

関数には、docstringを含めることができます。これは、インラインドキュメントとして機能する、関数の短い説明です。ドックストリングを使用する場合は、関数名の直後に記述します。


[UP](002_00.md)
