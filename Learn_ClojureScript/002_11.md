[UP](002_00.md)


### レッスン11：ループする

前回のレッスンでは、通常、分岐制御構造と呼ばれるClojureScriptのバージョンを見ました。しかし、ClojureScriptでは、私たちが慣れ親しんできた他の言語とは少し異なる動作をすることがわかりました。さて、もう1つの基本的なトピックであるループに入ると、ClojureScriptではまたしても少し違うことを学びます。

-----
このレッスンでは

- ClojureScriptのさまざまなループ構造を調べる
- シーケンスの観点から考えることを学ぶ
- 副作用のためにループを強制的に評価する
-----

命令型言語では、ループは同じ命令を何度も繰り返すために使用されます。通常、毎回何らかの小さな変化を加えて、最終的にループを終了させます。典型的な命令型ループは `while` ループで、コンピュータはある条件を満たすまで同じ命令を繰り返し実行します。

```JavaScript
let i = 0;                                                 // <1>

while (i < 10) {                                           // <2>
    console.log("Counting: " + i);
    i++;                                                   // <3>
}
```
JavaScriptのwhileループ

1. 変更される変数の初期化
2. ループの継続条件の設定
3. 通過するたびに`i`の値を増加させる

ClojureScriptは、データの不変性と式指向のプログラミングの両方を重視しており、ループは本質的に可変型であり文指向であることから、ClojureScriptにループのための場所があるかどうか疑問に思うでしょう。答えは「イエス」でもあり「ノー」でもあります。ループのような構成要素はいくつかありますが、よく見ると、それらは明示的なループを伴わない他の概念の抽象化であることがわかります。

#### `for`によるシーケンスの操作

このレッスンで学ぶ最初の、そしておそらく最も一般的な表現は`for`です。`for`は、ある種の命令型ループと名前が似ていますが、まったく別のものです。反復型の`for`とは対照的に、ClojureScriptの`for`は、既存のシーケンスを変換したり、オプションでフィルタリングしたりして、新しいシーケンスを作成するというシーケンス内包のアイデアを中心にしています。ClojureScriptでこのタスクを実行するには複数の方法がありますが、`for`は確かに簡潔で慣用的な選択肢です。

最も基本的な形として、`for`は任意の数のシーケンスとボディを受け取り、シーケンス要素のすべての組み合わせについてボディを評価することで新しいシーケンスを生成します。

```Clojure
(for [elem1 sequence1                                      ;; <1>
      elem2 sequence2]                                     ;; <2>
  expr)                                                    ;; <3>
```
`for`の解剖

1. `sequence1`の各要素を順番に`elem1`にバインドする
2. `sequence2`についても同様に行う
3. `sequence1`と`sequence2`の各要素の組み合わせに対して、結合した`elem1`と`elem2`で`expr`を評価する

##### 単一のシーケンスでの`for`の使用

`for`は任意の数のシーケンスをサポートしていますが、実際には1つか2つのシーケンスで使用されることがほとんどです。最も一般的な使い方は、先に述べたように、シーケンス変換としてです。例えば、数字のリストがあって、それぞれの2乗を求めたいとします。ここで求めたいのは、各要素が元のリストの対応する要素の2乗である新しいリストを生成するプロセスを何らかの形で記述することです。ありがたいことに、これは言葉で表現するよりもコードで表現する方がより簡単です。

```Clojure
(for [n (range 10)]                                        ;; <1>
  (* n n))                                                 ;; <2>
;; (0 1 4 9 16 25 36 49 64 81)
```
0から9の2乗を求める

1. 0〜9の数字を使って新しいシーケンスを作る。
2. 新しいシーケンスの各数字を元の数字の2乗にする

ここまでで、`for`が1つの入力シーケンスで使用された場合、全シーケンス変換を記述することがわかると思います。ClojureScriptを使用する際には、目の前の問題がシーケンス変換として表現できるかどうかを考えてみましょう。もしそうであれば、`for`は何の変哲もない解決策を提供します。同じ問題を`for`を使って反復的に解くことを考えてみましょう。いくつかの直角三角形があるとします。直角に隣接する辺はわかっているので、それぞれの三角形の斜辺を求めなければなりません。Fistは、JavaScriptによる反復的な解決法です。

```JavaScript
let sides = [[4.2, 6], [4, 4], [3, 4], [5.5, 3]];          // <1>
let lengths = [];                                          // <2>
let i;

for (i = 0; i < sides.length; i++) {                       // <3>
    lengths.push(
        Math.sqrt(
                Math.pow(sides[i][0], 2) +
                Math.pow(sides[i][1], 2)
        )
    );
}
```
斜辺の長さを反復的に求める

1. 三角形の辺を2次元の配列としてモデル化する
2. 結果の長さを格納する配列を宣言する
3. 辺の要素を繰り返し処理し、計算された斜辺の長さを毎回 `lengths` 配列に格納する

これは非常にわかりやすい反復コードですが、ClojureScriptで必要とされるレベルよりもまだ低レベルのものです。このようなループでは、インデックスが混ざってしまったり（例えば、`sides[i][0]`と`sides[0][i]`）、off-by-1エラーが発生しやすくなります。この問題は、ある配列を別の配列に変換しているだけなので、簡単に`for`を使うことができます。

```Clojure
(let [sides-list (list [4.2 6] [4 4] [3 4] [5.5 3])]       ;; <1>
  (for [sides sides-list]                                  ;; <2>
    (Math.sqrt (+ (Math.pow (first sides) 2)               ;; <3>
                  (Math.pow (second sides) 2)))))
                                                           ;; <4>
;; (7.323933369440222 5.656854249492381 5 6.264982043070834)
```
斜辺の長さを`for`で求める
Get Hypotenuse Length With for







[UP](002_00.md)
