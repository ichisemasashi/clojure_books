[UP](002_00.md)


### レッスン11：ループする

前回のレッスンでは、通常、分岐制御構造と呼ばれるClojureScriptのバージョンを見ました。しかし、ClojureScriptでは、私たちが慣れ親しんできた他の言語とは少し異なる動作をすることがわかりました。さて、もう1つの基本的なトピックであるループに入ると、ClojureScriptではまたしても少し違うことを学びます。

-----
このレッスンでは

- ClojureScriptのさまざまなループ構造を調べる
- シーケンスの観点から考えることを学ぶ
- 副作用のためにループを強制的に評価する
-----

命令型言語では、ループは同じ命令を何度も繰り返すために使用されます。通常、毎回何らかの小さな変化を加えて、最終的にループを終了させます。典型的な命令型ループは `while` ループで、コンピュータはある条件を満たすまで同じ命令を繰り返し実行します。

```JavaScript
let i = 0;                                                 // <1>

while (i < 10) {                                           // <2>
    console.log("Counting: " + i);
    i++;                                                   // <3>
}
```
JavaScriptのwhileループ

1. 変更される変数の初期化
2. ループの継続条件の設定
3. 通過するたびに`i`の値を増加させる

ClojureScriptは、データの不変性と式指向のプログラミングの両方を重視しており、ループは本質的に可変型であり文指向であることから、ClojureScriptにループのための場所があるかどうか疑問に思うでしょう。答えは「イエス」でもあり「ノー」でもあります。ループのような構成要素はいくつかありますが、よく見ると、それらは明示的なループを伴わない他の概念の抽象化であることがわかります。

#### `for`によるシーケンスの操作

このレッスンで学ぶ最初の、そしておそらく最も一般的な表現は`for`です。`for`は、ある種の命令型ループと名前が似ていますが、まったく別のものです。反復型の`for`とは対照的に、ClojureScriptの`for`は、既存のシーケンスを変換したり、オプションでフィルタリングしたりして、新しいシーケンスを作成するというシーケンス内包のアイデアを中心にしています。ClojureScriptでこのタスクを実行するには複数の方法がありますが、`for`は確かに簡潔で慣用的な選択肢です。

最も基本的な形として、`for`は任意の数のシーケンスとボディを受け取り、シーケンス要素のすべての組み合わせについてボディを評価することで新しいシーケンスを生成します。

```Clojure
(for [elem1 sequence1                                      ;; <1>
      elem2 sequence2]                                     ;; <2>
  expr)                                                    ;; <3>
```
`for`の解剖

1. `sequence1`の各要素を順番に`elem1`にバインドする
2. `sequence2`についても同様に行う
3. `sequence1`と`sequence2`の各要素の組み合わせに対して、結合した`elem1`と`elem2`で`expr`を評価する

##### 単一のシーケンスでの`for`の使用

`for`は任意の数のシーケンスをサポートしていますが、実際には1つか2つのシーケンスで使用されることがほとんどです。最も一般的な使い方は、先に述べたように、シーケンス変換としてです。例えば、数字のリストがあって、それぞれの2乗を求めたいとします。ここで求めたいのは、各要素が元のリストの対応する要素の2乗である新しいリストを生成するプロセスを何らかの形で記述することです。ありがたいことに、これは言葉で表現するよりもコードで表現する方がより簡単です。

```Clojure
(for [n (range 10)]                                        ;; <1>
  (* n n))                                                 ;; <2>
;; (0 1 4 9 16 25 36 49 64 81)
```
0から9の2乗を求める

1. 0〜9の数字を使って新しいシーケンスを作る。
2. 新しいシーケンスの各数字を元の数字の2乗にする

ここまでで、`for`が1つの入力シーケンスで使用された場合、全シーケンス変換を記述することがわかると思います。ClojureScriptを使用する際には、目の前の問題がシーケンス変換として表現できるかどうかを考えてみましょう。もしそうであれば、`for`は何の変哲もない解決策を提供します。同じ問題を`for`を使って反復的に解くことを考えてみましょう。いくつかの直角三角形があるとします。直角に隣接する辺はわかっているので、それぞれの三角形の斜辺を求めなければなりません。Fistは、JavaScriptによる反復的な解決法です。

```JavaScript
let sides = [[4.2, 6], [4, 4], [3, 4], [5.5, 3]];          // <1>
let lengths = [];                                          // <2>
let i;

for (i = 0; i < sides.length; i++) {                       // <3>
    lengths.push(
        Math.sqrt(
                Math.pow(sides[i][0], 2) +
                Math.pow(sides[i][1], 2)
        )
    );
}
```
斜辺の長さを反復的に求める

1. 三角形の辺を2次元の配列としてモデル化する
2. 結果の長さを格納する配列を宣言する
3. 辺の要素を繰り返し処理し、計算された斜辺の長さを毎回 `lengths` 配列に格納する

これは非常にわかりやすい反復コードですが、ClojureScriptで必要とされるレベルよりもまだ低レベルのものです。このようなループでは、インデックスが混ざってしまったり（例えば、`sides[i][0]`と`sides[0][i]`）、off-by-1エラーが発生しやすくなります。この問題は、ある配列を別の配列に変換しているだけなので、簡単に`for`を使うことができます。

```Clojure
(let [sides-list (list [4.2 6] [4 4] [3 4] [5.5 3])]       ;; <1>
  (for [sides sides-list]                                  ;; <2>
    (Math.sqrt (+ (Math.pow (first sides) 2)               ;; <3>
                  (Math.pow (second sides) 2)))))
                                                           ;; <4>
;; (7.323933369440222 5.656854249492381 5 6.264982043070834)
```
斜辺の長さを`for`で求める

1. 直角三角形の2辺を表すペアのリストを宣言します。
2. リストのすべてのペアに変換を適用するためにfor式を使用する
3. ピタゴラスの定理を適用して、斜辺の長さを求める。
4. 結果は、各三角形の斜辺を持つ数列です。

**クイックレビュー**

- 点のペアが次のように与えられます。[[x, y], [x, y]] という座標が与えられたとき，点間の距離を計算する`for`式を書きなさい．ヒント：これは前の例と非常によく似ています。

##### 複数の配列に対する`for`の使用

`for`は、複数の配列の要素を組み合わせることができるのが特徴です。複数の配列が与えられた場合、各入力配列の単一要素のユニークな組み合わせごとに要素を生成します。このような組み合わせは「直交積」と呼ばれ、数学的集合論の重要な概念です。例えば、電子商取引のアプリを書いていて、ある商品には色、サイズ、スタイルなどいくつかのバリエーションがあるとします。`for`を使って、可能なすべての商品の組み合わせを得ることができます。

```Clojure
(let [colors [:magenta :chartreuse :taupe]                 ;; <1>
      sizes [:sm :md :lg :xl]
      styles [:budget :plain :fancy]]
  (for [color colors                                       ;; <2>
        size sizes
        style styles]
    [color size style]))                                   ;; <3>
;; ([:magenta :sm :plain] [:magenta :sm :regular] [:magenta :sm :fancy]
;; ... [:taupe :xl :plain] [:taupe :xl :regular] [:taupe :xl :fancy])
```
`for`による製品バリエーションの生成

1. 3つの配列を宣言する
2. 各コレクションから1つのアイテムの可能なすべての組み合わせを取る
3. 各色、サイズ、スタイルの組み合わせのベクトルを生成する

この例では、結果として得られた商品の組み合わせに対して、`[color size style]`のベクトルにまとめる以外には何もしていませんが、必要に応じてあらゆる変換を行うことができました。反復ループを使って同じタスクを実行するには、3階層の入れ子になったループを書かなければならないことを考えてみてください。

##### ループ修飾子：let、when、while

ここまでは、1つ以上の配列からすべての要素を取り出すという、基本的な`for`の形式のみを使用してきました。これは多くのユースケースで有効ですが、結果をフィルタリングしたい場合もあります（例えば、小さいサイズで豪華な商品を提供したくない場合など）。`for`がリストを生成した後にフィルタリングするのではなく、`:when`修飾子を使って`for`式自体に直接フィルタリングのロジックを組み込むことができます。繰り返しになりますが、結果を出す前に何らかの中間値を計算したい場合があります。`for`の本体に`let`式を入れ子にする代わりに、`:let`修飾子を使うことができます。最後に、あるカットオフポイントまでの要素だけを取り出したい場合は、`:while`修飾子を使用することができます。これらの修飾子を説明するために、少し不自然な例を使ってみましょう。

```Clojure
(for [n (range 100)                                        ;; <1>
      :let [square (* n n)]                                ;; <2>
      :when (even? n)                                      ;; <3>
      :while (< n 20)]                                     ;; <4>
  (str "n is " n " and its square is " square))            ;; <5>

;; ("n is 0 and its square is 0"
;; "n is 2 and its square is 4"
;; "n is 4 and its square is 16"
;; ...
;; "n is 18 and its square is 324")
```
`for`修飾子

1. 0〜99の範囲でnを取る
2. シンボル`square`のバインディングを宣言し、nの2乗として各反復を行う
3. nが偶数である値のみを含める
4. nが20になるまで続ける

これらの修飾子を使用するには，シーケンス式のリストにその修飾子を追加すればよいのです．どの修飾子も理解するのが難しいものではありませんので、次に進む前に、それぞれの修飾子の概要を簡単に説明します。

- **:let**は`for`の本体内に任意の数のバインディングを作成します。`:let`では、`for`式で定義されているシンボルや、スコープ内の他の変数を使用できます。使い方は、通常の`let`形式と同じです。
- **:when**は、どの入力に対して値を出力するかを決定します。`:when`は、どのような入力に対して値を出力するかを決定します。 `:when`の後には述語式が続き、その式が真である場合にのみ値を出力します。
- **:while**は、`:when`と似ていますが、複数の入力シーケンスで使用される場合、最も直接的な「グループ」を短絡的に判断します。つまり、あるシーケンス式の後に配置された場合、配置された後のシーケンスの残りの要素をスキップし、前のシーケンスの次の項目と配置された後のシーケンスの最初の項目を取ることで形成される組み合わせを続行します。この動作を説明するために、while節の配置が次の例の動作にどのように影響するかを考えてみましょう。

![while-short-circuit.png](imgs2/while-short-circuit.png)
`:while`修飾子の動作





[UP](002_00.md)
