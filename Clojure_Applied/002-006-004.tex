\section{コンポーネントを実装する}

さて、コンポーネントをどのように呼び出し、接続するかという観点から見てきましたが、次はAPIの背後にある機能をどのように実装するかという内部事情に目を向ける必要があります。

ほとんどのコンポーネントはある種の状態を保持しており、呼び出し側がこの状態を更新したり、状態に依存する機能を呼び出したりすることができます。これまで学んできた状態のメカニズム（ atom 、 ref 、 agent ）は多くの方法で使用することができ、特に状態の粒度をどのように選択するかを検討します。

また、コンポーネントのライフサイクル全体についても考慮する必要があります。コンポーネントは、構成データと依存関係で構築され、内部状態や外部システムとの接続を初期化する必要があるかもしれません。コンポーネントが構築されたら、各コンポーネントを停止するためのパスも用意しておくとよいでしょう。これは、開発中にREPLで簡単に起動・停止できるようなシステムを構築するために重要です。この2つについて、さらに詳しく見ていきましょう。

まず、各コンポーネント内の状態の粒度について見ていきます。

\subsection{状態の粒度}

コンポーネントはしばしば、コンポーネントの寿命の間に変更される可能性のある実行時の状態を持っています。これはコンポーネントが管理するデータであったり、 データベース接続のような内部ステートフルリソースハンドルであったり、 あるいは動的な設定値であったりします。実行状態の初期値は設定の一部として渡されることもありますが、多くの場合、内部で構築されたり、時間の経過とともに構築されたりします。

コンポーネント内に状態を保持する場合、ステートフルなコンテナ（通常は atom か ref ）を使用する必要があります。どちらを使うか、そしてステートの粒度を選択する必要がある。

主な決定要因は、必要な調整のレベルです。 atom はより単純だが、複数のステート間で調整することができない。 ref はより複雑だが、協調をサポートする。しかし、別の見方をすると、調整が必要な2つの状態の断片を1つの atom の下に持ってきて、再び1つの更新関数で対応できるようにすることも可能である。

口座のインデックスと顧客のインデックスという2種類の状態を管理する必要があるコンポーネントを考えてみましょう。これらは2つの atom として維持することができる。

\begin{lstlisting}[numbers=none]
(defrecord CustomerAccounts [accounts customers])

(defn make-customer-accounts []
  (map->CustomerAccounts {:accounts (atom {})
                          :customers (atom {})}))
\end{lstlisting}

あるいは、アカウントとカスタマーの両方でトランザクション的に変更が必要なケースであれば、 ref を使うことも可能でした。


\begin{lstlisting}[numbers=none]
(defrecord CustomerAccounts [accounts customers])

(defn make-customer-accounts []
  (map->CustomerAccounts {:accounts (ref {})
                          :customers (ref {})}))
\end{lstlisting}

ref を使用すると、コンポーネントの状態との相互作用にトランザクションを巻き付ける必要があります。その代わりに、状態の粒度を大きくして、1つの atom 内にアカウントと顧客の両方を包含することができるかもしれません。

\begin{lstlisting}[numbers=none]
(defrecord CustomerAccounts [state])

(defn make-customer-accounts []
  (map->CustomerAccounts (atom {:accounts {}
                                :customers {}})))
\end{lstlisting}

Clojureの atom は高速なので、更新関数が小さいことを前提に、その内部で粗視化された状態を使うことができる場合が多いのです。

逆に、口座や顧客を桁ごとに分割したり、名前ごとに分割してセグメントごとにrefを作成するなど、粒度をより細かくすることも可能です。コンポーネントのトップレベルの機能は影響を受けますが、エンティティレベルのデータや関数はシンプルでステートレス、そしてどのようなアプローチにも完全に再利用可能であるべきです。

\subsection{構成}

コンポーネントを実装する際には、起動時や継続的に使用するために必要な情報を保持する必要があります。コンポーネントは、構成、依存関係、実行時の状態という3つの主要な情報を必要とします。

設定データは、コンポーネントの外部で取得したり構築したりします (設定データの管理方法については、第7章 アプリケーションの構成で説明します)。作成時にコンポーネントに渡され、コンポーネントの起動時またはそれ以降に使用することができます。設定情報の一般的な使用例としては、外部リソース (データベースやメッセージシステムなど) への接続パラメータがあります。

コンポーネントを作成する際に、各設定値を個別のパラメータとして渡すことができます。

\begin{lstlisting}[numbers=none]
(defn new-component [db-url user password] ...)
\end{lstlisting}

しかし、設定データはシステムの開発に伴って変化することが多いので、設定データは必要に応じて進化できるパッケージ（マップやレコード）として渡すのがよい。

\begin{lstlisting}[numbers=none]
(defn new-component [{:keys [db-url user password]}] ...)
\end{lstlisting}

設定データだけでなく、コンポーネントが他のコンポーネントを参照する必要がある場合も多い。例えば、ナレッジエンジンコンポーネントは、設定データに加えて、データフィードコンポーネントへのアクセスを必要とする場合があります。

\begin{lstlisting}[numbers=none]
(defn new-knowledge-engine [config feed] ...)
\end{lstlisting}

しかし、あるコンポーネントを依存関係として他のコンポーネントに直接渡すよりも、それらの間にチャネルを配置することによってそれらを切り離す方が理にかなっている場合もあります。この場合、リモートコンポーネントではなく、チャネルが依存関係として扱われます。コンポーネントの接続方法を考えると、これはコンポーネントの組み立てに多くの選択肢を与えることになります。

コンポーネントには、設定、他のコンポーネントやチャネルとの依存関係、内部のランタイムの状態を保存する場所が必要です。レコードは、コンポーネントの動作を定義するプロトコルを実装するのが一般的であるため、これに最適な選択肢である。

次に、コンポーネントの状態が作成されるコンストラクションを含む、コンポーネントのライフサイクルを見ていきます。

\subsection{ライフサイクル}

ほとんどのコンポーネントのライフサイクルは単純である。最も重要なイベントは、構築、コンポーネントの開始、およびコンポーネントの停止です。

例えば、先ほどのルールベースの知識エンジンと、そのコンポーネントをどのように構築するかを考えてみましょう。議論のために、知識エンジンは受信メッセージのストリームを受け取り、ルールに従ってそれを修正し、他のコンポーネントに送信する役割を担っていることも考えてみましょう。

\begin{lstlisting}[numbers=none]
(defrecord KnowledgeEngine
  [config ;; map of config info
   ch-in ;; channel to receive messages
   ch-out ;; channel to post messages
   rules ;; state - current rule set
   active]) ;; state - true if active

(defn make-knowledge-engine
  [config ch-in ch-out rule-set]
  (->KnowledgeEngine config ch-in ch-out
          (atom rule-set) (atom false)))

(defn start-knowledge-engine
  [{:keys (ch-in ch-out rules active) :as ke}]
  (reset! active true)
  (go-loop [request (<! ch-in)
            response (fire-rules ke request)]
    (>! ch-out response)
    (when @active (recur)))
  ke)

(defn stop-knowledge-engine
  [{:keys (ch-out active) :as ke}]
  (reset! active false) ;; exit go loop
  (async/close! ch-out) ;; stop producing
  ke)
\end{lstlisting}

コンポーネントはしばしばステートフルフィールドに初期値を設定したり、その他のタスクを実行する必要があるため、通常、コンポーネントインスタンスを作成するためのカスタム関数を提供することになります。ここでは、 \texttt{make-knowledge-engine} 関数は、知識エンジンの現在のルールの状態を保持するアトムを含む、コンポーネントのインスタンスを構築します。

静的な構成は、しばしばアプリケーションの進化に伴う変更の原因となります。この進化を計画するには、静的構成を一連の位置づけの構成パラメータとしてではなく、マップとして捉えるのが最適です。これにより、頻繁に変更される設定値を、既存のコードを壊すことなく変更することができます。

\texttt{start-knowledge-engine} 関数は、受信した要求チャネルの処理を開始するためにコンポーネントをアクティブにします。軽量なgoブロックが作成され、コンポーネントの寿命まで生き続け、 \texttt{ch-in} からメッセージを抽出し、ルールを介してそれを処理し、 \texttt{ch-out} にそれを投稿します。ステートフルアクティブフラグは、ゴーブロックが継続すべきかどうかを決定するために使用されます。

\texttt{stop-knowledge-engine} 関数は \texttt{active} フラグを \texttt{false} に設定し、goブロックのループを停止させることができる。 \texttt{stop} 関数はまた、これ以上メッセージが生成されないため、出力チャネルを閉じます。入力チャネルは閉じません。その代わり、コンポーネントが停止したときに、入力チャネルのオーナーがそのチャネルをクローズする必要があります。これは \texttt{core.async} プログラムでよくある慣習です。




