\section{エンティティの構築}


エンティティの構造を定義したら、その構造に値を入れる関数を作成する必要があります。ほとんどの場合、defrecord の positional と map ファクトリ関数、またはマップを作成するコアライブラリ関数 (\texttt{\{\}}, \texttt{hash-map}, \texttt{zipmap} など) を使ってエンティティに値を入れることができます。

しかし、いくつかのよくある状況は、もう少し考慮する必要があります。最も一般的な状況の1つは、オプションの値を持つエンティティのケースである。Clojureは多くの方法でこれを扱うことができ、最も一般的なもののいくつかを見ていきます。また、派生値を作成するコンストラクタや副作用のあるコンストラクタも見ていきます。

\begin{itembox}[l]{用語と命名について}

ここでは、\texttt{defrecord}によって自動的に生成される関数を特にファクトリ関数と呼び、新しいエンティティインスタンスを構築する他の関数をコンストラクタと呼びます。しかし、これらの用語はClojureコミュニティでしばしば互換的に使用され、他の言語コミュニティでは異なる意味合いを持つ可能性があることに注意してください。

プロジェクト全体でコンストラクタ関数の命名規則を持っていると便利です。Clojureコミュニティにはコンストラクタの標準的な命名規則はありませんが、よく使われるコンストラクタ接頭辞は \texttt{new-} 、 \texttt{make-} 、 \texttt{map->} です。ここでは主に \texttt{make-} を使用しますが、独自の規約を採用してもかまいません -- ただ一貫性を持って使用してください。
\end{itembox}

まず、オプションの引数の扱いについて考えてみます。

\subsection{オプションを使った構築}

オプションの引数を使用することで、コンストラクタに柔軟性を持たせることができます。さまざまな方法で実体を構築することを想定している場合、 オプションの引数を使用すると便利です。
関数の定義にオプションの引数を含めるには、引数ベクトルに \texttt{& opt} を追加します。


\begin{lstlisting}[numbers=none]
(defn fn-with-opts [f1 f2 & opts] ,,, )
\end{lstlisting}

もちろん、\texttt{opts}は好きな名前を付けることができます。関数に渡されるオプションの引数はシーケンスに集められ、関数本体の中でoptに束縛される。


\subsubsection{ポジション・デストラクチャリング}

オプションの引数を持つコンストラクタを定義する場合、分かりやすくするためにデストラクチャリングを使用することができます。

\begin{lstlisting}[numbers=none]
(defn make-entity [f1 f2 & [f3 f4]] ,,, )
\end{lstlisting}













