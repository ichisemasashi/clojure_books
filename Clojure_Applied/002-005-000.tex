\chapter{コアを利用する}


最近のサーバーやノートパソコン、そして携帯電話も、プログラムが使用できる独立した複数の制御スレッドを持つマルチコアチップ上に構築されています。私たちは、これらのチップをフルに活用できるようにプログラムを設計する必要があります。Clojureはこのマルチコアの世界で生まれ、この世界のために設計されました。

Javaなどの言語における並行性の問題のほとんどは、共有されたミュータブルステートの管理の問題です。これまで見てきたように、Clojureは主に（スレッドをまたいで安全に使用できる）不変データに依存しています。また、ステートフル・コンテナ（atom, ref, agent, var）を使って、どのように明示的な状態を作成できるかを見てきました。これらのコンテナはすべて共通の更新モデルを使用しており、状態は常に純粋な関数によってある不変の値から別の値に変換されます。これらのアプローチの組み合わせにより、多くの一般的なエラークラスが取り除かれ、すべてのコアをどのように有用なものにするかという真の問題に集中できるようになります。

私たちが最初に遭遇する問題の一つは、メインスレッドから作業を移し、メインスレッドが業務を行っている間に非同期にそれを実行する方法です。そうすると、非同期タスクが完了したときにその結果を受け取る方法も必要になります。これらのためにClojureの\texttt{future}と\texttt{promise}に飛び込みます。

より長時間のタスク指向の並行処理のために、ワーカスレッドのプールにそれらをファームアウトすることによって、一連のタスクを処理します。Javaにはキューとワーカーのための堅牢なツールがあり、Clojureから直接呼び出すことができます。これらのツールにより、すべてのコアを利用しながら、作業のストリームを効率的に処理することができます。

場合によっては、コレクションに対して並列に、すべての要素に同じ変換を実行する、きめ細かい作業を実装する必要があります。これらの問題にアプローチする方法は、コレクションとシーケンス関数で既に見てきましたが、Clojureには\texttt{reducer}と呼ばれる別の選択肢があります。\texttt{reducer}を使うと、変換をシーケンスのように構成しながら、並列に実行することができます。

最後に、スレッド（と軽量プロセス）を使って、プログラムの全体的な構造をどのように組織化できるかを考えたいと思います。core.asyncライブラリはチャンネルとゴーブロックの概念を定義しており、この構成を手助けしてくれます。アプリケーションの構造をどのように定義するか見ていきましょう。



\input{002-005-001.tex} % Push Waiting to the Background
\input{002-005-002.tex} % Queues and Workers
\input{002-005-003.tex} % Parallelism with Reducers
\input{002-005-004.tex} % Thinking in Processes
\input{002-005-005.tex} % Wrapping Up