\chapter{シーケンシャルデータの処理}

ドメイン・エンティティやエンティティまたは値のコレクションができたら、アプリケーションの要件を満たすために、質問に答えたり、データを新しい形に変換したりできるようにする必要があります。しかし、Clojureはデータの集合体レベルで考えることを推奨しており、コレクション全体に一度に変換を適用します。

Clojureは、単一のデータ構造を操作する広範な関数群を構築するのではなく、その変換のすべてをシーケンス抽象化に基づいて構築します。シーケンスは、Clojureの最も重要な2つの部分、すなわち、不変のコレクションと変換ライブラリをつなぐ重要な抽象化である。

抽象化とは、値のシーケンシャルなソースをトラバースするための最も重要な側面（最初の値を取得し、残りをシーケンスとして取得し、終了をチェックする手段）だけが含まれていることを意味します。シーケンスが実現されると、その値はキャッシュされ、実現状態に関わらずシーケンスは不変である。この単純な抽象化により、変換ライブラリのほぼすべての関数と、すでに見たことのあるすべてのコレクションを接続するのに十分である。

さらに重要なことは、シーケンス抽象化の参加者とその上で動作する関数の両方がオープンシステムであり、この組み合わせが2次元（より多くのデータとより多くの関数）的に拡張可能であることです。どの関数でもどのデータでも接続できることは、Clojureプログラム内、そしてClojureプログラム間で非常に大きな再利用性を可能にし、Clojureプログラムを簡潔かつ表現力豊かにする重要な要因です。

シーケンスは当初からClojureの一部でした。Clojure 1.7はトランスデューサーの概念を導入しています。これはシーケンシャル処理をさらに進化させたもので、入力の反復、変換の適用、出力の生成の概念を分割しています。これらの断片を分離することで、トランスデューサーはさらに幅広いコンテキストで逐次変換の再利用を可能にします。この章を通して、シーケンスとトランスデューサーの比較と、それぞれを最大限に活用する方法を紹介します。

おそらく、シーケンス変換の最も一般的な種類の1つは、シーケンス内のすべての値に関数を適用して新しいシーケンスを生成するという考え方で、私たちはそこから始めましょう。続いて、その他の一般的な変換として、値への還元、フィルタリング、シーケンスの一部の削除、グループ化、ソート、重複の削除について見ていきます。最後に、これらの変換をすべて組み合わせて、変換パイプラインを作成する方法について説明します。 

\input{001-003-001.tex} % Mapping Values
\input{001-003-002.tex} % Reducing to a Value
\input{001-003-003.tex} % Filtering and Removing Values
\input{001-003-004.tex} % Take and Drop
\input{001-003-005.tex} % Sorting and Duplicate Removal
\input{001-003-006.tex} % Grouping Values
\input{001-003-007.tex} % Putting It All Together
\input{001-003-008.tex} % Wrapping Up
