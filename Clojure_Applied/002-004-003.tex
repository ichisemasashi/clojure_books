\section{変化と生きる}

Clojureが提供する、アプリケーションの状態を更新するためのツールをいくつか詳しく見てきました。これらのツールは、変更が有効であり、瞬時に見えることを保証することで、不運から守ってくれます。しかし、まだずさんな考えで自分自身の足を撃つことができます。

状態管理の複雑さを、ドキュメントやブログ記事、そしてこの本のようなおもちゃのようなコードで示すことは困難です。しかし、これまで見てきたような仕組みを応用する際には、いくつかのガイドラインを心に留めておくとよいでしょう。

\subsection{バリデーションの方法とタイミング}

私たちの\texttt{shopping.store} APIは、冗長性と少し厄介な部分を含んでいます。\texttt{init}では、私たちのAPI（特に\texttt{grab}）を無視してストアの\texttt{inventory}を直接更新するコードから保護するために、バリデータ関数として在庫に\texttt{no-negative-values?}関数を適用しました。

このバリデータメソッドは、マップのすべての要素を検査して、在庫が増加していることを確認します。在庫が大きくなり始めたらどうなるのでしょうか？\texttt{grab}で使っている\texttt{in-stock?}テストと比較して、どれだけのオーバーヘッドになるでしょうか？厄介なことに加えて、冗長です。\texttt{grab}を使おうが使うまいが、バリデータは呼び出されるのです。

どうすればいいでしょうか？少なくとも、\texttt{inventory}の\texttt{def}に \texttt{^\{:private true\}} を追加して、\texttt{grab} の使用を奨励すべきです。より堅牢な解決策は、システムを初期化する関数を構築し、それを必要とするコンポーネントに渡すことです。これは、第7章「アプリケーションを構成する」で詳しく説明するコンポジションの水域に足を踏み入れることになります。

APIを開発する際には、必要と思われるすべてのアクションをラップした一連の関数を提供し、実際のデータの保存は非公開にするようにしましょう。こうすることで、提供された関数をバイパスして直接データを操作することを防ぐことができます。これにより、バリデータのパフォーマンスが低下するような場面でも、 不正な操作から保護する仕組みを導入することができます。バリデータ関数は Clojure がトランザクションをコミットする前に実行されるので、 長時間実行するバリデータはステートフルなリソースへのリクエストをブロックしたり キューに入れたりする可能性があることを覚えておいてください。

一方、バリデータ関数の定義は、小さなデータやプログラムの状態には効果的です。(たとえば) ロギング用のファイル名を含むアトム設定がある場合、 そのファイルが存在するかどうかをバリデータに確認させたいことがあります。ひとつのアトムでさまざまな更新が可能な場合、バリデータを使用すると検証を一元化でき、 必要なコードの量を減らすことができます。もちろん、誰かがルールを破ったときに発生する例外をキャッチする準備はしておかなければなりませんが、 設計とは常にトレードオフの関係にあるものなのです。

\subsection{ランタイムステートとプログラムステート}

安心してください、これは少しは分ける価値があります。この章では、主にプログラムの状態やアプリケーションの状態について話してきました。つまり、インベントリやショッピングリストなど、問題領域にある管理された状態を対象にしてきました。プログラム状態は、ソフトウェアがモデル化するドメイン知識と、ソフトウェアが解決しようとする問題に直接関連するデータと概念に、管理されたアクセスを提供する役割を果たします。

店舗APIにはinventoryアトムがあり、そこにsold-itemsアトムを後から追加した。家族での買い物は、買い物リスト、割り当て、ショッピングカートを管理した。これらの要素はすべてプログラム・ステートである。プログラムの状態には、可能な限りAPIを使ってアクセスし、直接ではなく、慎重に吟味されたメソッドを通して使用されるべきである。

一方、ランタイムステートは、ソフトウェアの実行を容易にするために存在する。ランタイム状態は、データベース、設定ファイル、ネットワーク接続、または呼び出す予定のコンポーネントへの参照を保持する役割を果たします。これらは動作環境に影響を与えるもので、ドメイン情報には関係ない。ランタイムステートについては、第7章「アプリケーションを構成する」で詳しく説明します。ランタイムステートはしばしば避けられないもので、設定可能性を損なわずに最小化することは困難です。もしソフトウェアが必要とする状態情報の量を削減したいのであれば、代わりにプログラムの状態に注目しましょう。

関数型プログラミングに慣れないうちは、反射的にドメインに不必要なミュータビリティを散りばめてしまいがちです。この傾向は2つの方向から攻めることができます。1つ目は、前もってそれを確認すること、2つ目は、最後に変異性を減らすことです。



