\section{値への還元}

\texttt{reduce}関数は、蓄積された値とコレクションの次の要素に関数を繰り返し適用することで、コレクションを値に還元する関数です（オプションの初期値を使用）。\texttt{into}関数は、コレクションを単純な値ではなく、別のコレクションに還元する特殊なケースです。

例えば、宇宙シミュレーションで、太陽系のすべての惑星にある月の総数を計算することを考えてみましょう。まず、各惑星の月の数を抽出し（マッピング変換）、それらを\texttt{+}関数で一つの値（合計）に還元する必要があります。\texttt{reduce}関数は、収集変換と削減のステップを組み合わせるためによく使われる。

\texttt{map}と\texttt{reduce}を使って、惑星の集合の総和を計算することができる。



\begin{lstlisting}[numbers=none]
(defn total-moons
  [planets]
  (reduce + 0 (map :moons planets)))
\end{lstlisting}

この関数は、各 \texttt{Planet} レコードに適用する関数として \texttt{:moons} というキーワードを使用して、惑星をマッピングします。その結果、各惑星の月の数を表す数値の列が生成されます。

次に、\texttt{reduce}はそれらの要素にそれぞれ+関数を適用し、初期蓄積値として0から始めます。

\texttt{reduce}はシーケンスではなく、値を生成するため、イーガーとなります。そのため、計算は\texttt{reduce}が実行されたときに行われます。

この変換は，トランスデューサーと類似の関数である\texttt{transduce}を使って計算することもできます．この関数は\texttt{reduce}とは異なり，入力ソースの各要素に適用するトランスデューサと，変換の出力値をどうするかを決定する\texttt{reduce}関数の2つの関数を受け取ります．トランスデューサーは意図的に、入力がどのように供給されるか（ここではソースコレクションから）と、その後に入力に対して何が行われるかの両方から変換を切り離すことを思い出してください。



\begin{lstlisting}[numbers=none]
(defn total-moons
  [planets]
  (transduce (map :moons) + 0 planets))
\end{lstlisting}


このバージョンは先行例と同じ要素を多く含み、表面的には多くの点で類似しています。しかし、このトランスデューサーのバージョンには、2つの潜在的な利点があります。まず、\texttt{(map :moons)} トランスデューサはここではインラインで使われていますが、別の関数として取り出して、今あるものでも将来作られるものでも、どんなトランスデューサのコンテキストでも再利用できる可能性があります。つまり、変換アルゴリズム（単純かもしれませんが）は、そのアルゴリズムの適用から抽象化されているのです。

第二に、ソースにトランスデューサを適用すると、ソースコレクションの単一のトラバーサルが生じます。このトラバーサルは、一連の値を構築するオーバーヘッドなしに自分自身を縮小する方法を知っているソースを利用できることがあります。

次の節で複数のトランスデューサーを合成する方法の例を示します。その前に、ソースのすべての要素を訪れることなく、早期にリダクションを停止する必要があるという特別なケースを考える必要があります。\texttt{Planet}レコードのリストが与えられた場合、特定の1つ、おそらく\texttt{Earth}と名付けられたものを見つけたいと思うかもしれません。この関数は以下のように実装できます。




\begin{lstlisting}[numbers=none]
(defn find-planet
  [planets pname]
  (reduce
    (fn [_ planet]
      (when (= pname (:name planet))
        (reduced planet)))
    planets))
\end{lstlisting}






