\section{値のマッピング}

アプリケーションの中でデータが移動するとき、ある部分が別の形でデータを必要とすることはよくあることです。あるサブシステムは、30列のスプレッドシートから30個のキーを持つ汎用マップにデータをインポートする。別のサブシステムでは、5列のデータをエンティティの形で必要とし、さらに別のシステムでは、一連のエンティティから1つのフィールドのみを必要とし、計算を実行したり画面に表示したりします。

これらのユースケースはすべて、シーケンシャルなソースにある値をある形式から別の形式に変換する必要があります。Clojureでは、map関数はシーケンスの各要素に関数を適用して、その結果の新しいシーケンスを生成するために使用されます。

例えば、宇宙シミュレーションの各惑星エンティティの軌道周期を抽出して画面に表示する必要があるとします。入力は惑星のベクターであり、これはシーケンス、つまり論理的には値のリストとして扱われます。

このシーケンシャルな惑星の集合を、各惑星の軌道周期のシーケンシャルな集合に変換する必要がある。軌道周期とは、惑星が太陽の周りを完全に1周するのにかかる時間である。例えば、地球の場合、公転周期は約365.25日である。

$$
\mu = GM
$$

$$
T = 2 \pi \sqrt{\frac{a^3}{\mu}}
$$

任意の惑星の公転周期を計算する関数を書くことができる。この関数の詳細を理解することは、特に重要ではありません。(もし興味があれば、ここにその方程式を示す。Tは惑星の公転周期、$μ$は標準的な重力パラメータです)。

この値は、惑星だけでなく、中心星の質量にも依存する。公転周期を計算する関数は、惑星と恒星の質量を引数として受け取り、公転周期を返す。



\begin{lstlisting}[numbers=none]
(defn semi-major-axis
  "The planet's average distance from the star"
  [p]
  (/ (+ (:aphelion p) (:perihelion p)) 2))

(defn mu [mass] (* G mass))

(defn orbital-period
  "The time it takes for a planet to make a complete
  orbit around a mass, in seconds"
  [p mass]
  (* Math/PI 2
    (Math/sqrt (/ (Math/pow (semi-major-axis p) 3) (mu mass)))))
\end{lstlisting}

さて、変換関数ができたので、それを使って惑星のコレクションを公転周期のコレクションに変換しなければなりません。Clojureのマップ関数は、惑星のベクターに変換関数を適用して、連続したソース内のすべての値を新しい値に「マップ」する方法です。

1つの引数(値)を取り、新しい値を返す変換関数が必要です。しかし、\texttt{orbital-period}関数は2つの引数を取る関数なので、今ある関数を正しい形（1つの引数）の変換関数にラップする必要があります。これは、定数値（太陽質量）が現在の関数スコープで利用可能な無名関数を使用することでしばしば行われる。

\begin{lstlisting}[numbers=none]
(defn orbital-periods
  "Given a collection of planets, and a star, return the
  orbital periods of every planet."
  [planets star]
  (let [solar-mass (:mass star)]
    (map (fn [planet] (orbital-period planet solar-mass))
         planets)))
\end{lstlisting}

この例では、惑星のコレクションと星を受け取り、星から太陽質量を取り出しています。そして、惑星を受け取り、その惑星と太陽質量を用いてorbital-period関数を呼び出す無名関数でmapを呼び出すことができます。map関数は、この関数をすべての惑星に適用しながらコレクションを走査し、結果を一連のシーケンスにまとめて最後に返します。

mapが何をしているのか、コレクションの世界からシーケンスの世界へどのように入り込んでいるのか、もっと詳しく見ていきましょう。


\subsection{シーケンス処理}

 mapの仕事は、シーケンスのすべての値に関数を適用することである。ここでは Clojureがこの関数を実装する方法の簡略版です。このバージョンを \texttt{simple-map} と呼ぶことにします。


\begin{lstlisting}[numbers=none]
(defn simple-map
  "Map f over the elements of coll."
  [f coll]
  (when (seq coll)
    (cons (f (first coll))
          (simple-map f (rest coll)))))
\end{lstlisting}

この実装はClojureのシーケンスAPIを使って書かれており、主に\texttt{seq}, \texttt{first}, \texttt{rest}, \texttt{cons}関数から構成されています。\texttt{seq}関数は、コレクションが少なくとも1つの要素からなるシーケンスであるかどうかを尋ねます。もしそうなら，それが返され，そうでなければ，nilが返される．この結果は真か偽かを表すので、この関数はしばしば終了の条件チェックに使われる。

マッピングされるコレクションがより多くの要素を持つ場合、\texttt{cons}関数を適用する。\texttt{cons}関数は、値を含むセルと、次のセルへのポインタを構成する。これは典型的なリンクリストのデータ構造であり、値を含む一連のセルである。最初のセルの値は、変換関数fをコレクション内の最初の値に適用したものとして定義される。残りのセルは、同じ関数と入力コレクションの残りを渡して、この関数を再帰的に呼び出すことによって定義される。

この再帰的なシーケンスの定義は、シーケンシャルなコレクション（リストまたはベクタ）に適用されるが、そのデータ構造の実装方法の詳細には一切依存しない。シーケンスAPIを実装するためには、参加者(participant)は次の要素が存在するかどうかをチェックし、最初の要素を返し、残りの要素に対して新しい実体を返すことができればよいのである。つまり、シーケンスとはコレクションの論理的な見方である。

軌道周期の例では、シーケンシャルなコレクションやシーケンスAPIの他の実装を渡しても、\texttt{map}は動作する。シーケンスの抽象化により、汎用的な\texttt{map}関数が様々なデータソースで動作するようになった。

一般にシーケンス関数は、seqable（\texttt{seq}を適用するとシーケンスを生成できるもの）を入力として受け取り、同じものを返すと考えられています。しかし、この場合の結果は永続的なリストとなり、関数に渡されたベクトルほど高速でもメモリ効率も良くはありません。Clojureはこの特殊なケースのために、特別なmapv関数を提供します。mapv関数はmapと使い方は同じですが、特にベクトルを受け取って返します。

これは、ほとんどのシーケンス関数の典型的な側面を強調しています。入力ソース（シーケンス対ベクトル）の反復、変換の適用（\texttt{f}関数の適用）、結果に対する何らかの処理（リストの構築またはベクトルの構築）を組み合わせています。

この3つを組み合わせると、シーケンスの使い方が制限されます。しかし シーケンス入力は抽象化されたものであり，事実上あらゆるソースで実装可能である．同様に，この関数は出力シーケンスしか生成しないので，コレクションに挿入したり，通信チャネルに値を渡したりするには，別のバージョンが必要になる．これらの部品を分解するために、トランスデューサーが導入された。

\subsection{トランスデューサー}

トランスデューサの定義では、入力値がどこから来て、その出力がどのように使われるかを指定することを避け、代わりにトランスデューサが行う実際の作業のみを定義します。\texttt{map}の場合、トランスデューサの仕事は関数がすべての要素に適用されるようにすることです。その本質は、入力要素がコレクション、シーケンス、ソケット、キューのどれであっても、また、出力がコレクションに追加されるかファイルに保存されるかにかかわらず、同じです。

トランスジューサの実装はやや複雑なので説明しませんが、どのように作成され適用されるかを見ることは重要です。マップトランスジューサを作るには、\texttt{map}を呼び出すときに入力コレクションを省略します。

\begin{lstlisting}[numbers=none]
(defn orbital-period-transformation
  "Create a map transformation for planet->orbital-period."
  [star]
  (map #(orbital-period % (:mass star))))
\end{lstlisting}

この変換は、様々な入力ソースと出力条件に対して使用することができる。前の版の\texttt{map}と同様の出力シーケンスを生成するために、この変換とシーケンス関数を使用することができます。

\begin{lstlisting}[numbers=none]
(defn orbital-periods
  [planets star]
  (sequence (orbital-period-transformation star) planets))
\end{lstlisting}

\texttt{mapv}版のような出力ベクトルを作成する場合は、以下のようにします。

\begin{lstlisting}[numbers=none]
(defn orbital-periods
  [planets star]
  (into [] (orbital-period-transformation star) planets))
\end{lstlisting}

あるいはリストを作成する。

\begin{lstlisting}[numbers=none]
(defn orbital-periods
  [planets star]
  (into () (orbital-period-transformation star) planets))
\end{lstlisting}

\texttt{sequence}と\texttt{into}を用いた\texttt{orbital-periods}は、要素の実現方法が異なるため、遅延の概念に関わる。




\subsection{遅延性}

ほとんどのClojureシーケンス関数は、関数が評価されるときに変換を実行しない、遅延シーケンスを生成します。その代わり、遅延シーケンスは、シーケンスの消費者が必要とするときだけ評価されます。オリジナルのシーケンス版である \texttt{map} とシーケンス付きトランスデューサーは、どちらも必要に応じて計算される遅延シーケンスを生成します。

遅延シーケンスは、決して計算される必要のない作業を避けることができるという点で有用です。この場合、軌道周期の遅延シーケンスを消費するコードがなければ、計算する必要はないでしょう。遅延シーケンスは、フィボナッチ・シーケンスや素数シーケンスのような無限の値の並びを表現するのにも便利です。我々は、計算のためにそれらすべてを見ることは決してない（ありえない）。しかし、無限シーケンスとして定義することで、目的に応じて必要な数だけ取ることができる。

これに対して、\texttt{into} は出力全体を熱心に計算し、それを返す関数である。熱心な計算が便利なのは、計算がいつ行われるかを簡単に推論できるようになるからです。これにより、トランスデューサーで使用されるリソースの管理や廃棄が容易になったり、計算が行われるタイミングを正確に管理することができます。

さらに、\texttt{into}で行われる熱心な計算は、しばしばメモリと時間の両面でより効率的です。シーケンスは計算された値をキャッシュしますが、トランスデューサーの熱心なアプリケーションは、中間値を割り当てることなくソースコレクションに対して実行できることがよくあります。

\texttt{into}関数は、より一般的な\texttt{reduce}関数で実装されており、入力コレクションを値に還元します。









\begin{lstlisting}[numbers=none]

\end{lstlisting}




