\section{チャネルを使ったコンポーネントの接続}

コンポーネントは、プロデューサコンポーネントからコンシューマコンポーネントに値を供給するために、継続的な一連の値を渡すために接続する必要があるかもしれません。 \texttt{core.async} チャネルは、このような目的に最適です。コンポーネントが値の入出力にチャネルを必要とする場合、そのコンポーネントは外部のチャネルを受け入れるか、内部でチャネルを作成して利用できるようにします。

例えば、ソーシャルメディアからのメッセージを受信するコンポーネントがあるとします。一つの選択肢は、コンポーネントがその構成の一部として着信チャネルを受け入れることでしょう。

\begin{lstlisting}[numbers=none]
(defn make-feed-processor
  "指定された入力チャネルに新しいフィードプロセッサを作成します。"
  [input-channel] ,,,)  
\end{lstlisting}

あるいは、feed-processorが自らチャネルを構築し、ユーザーがそれを要求できるようにすることもできます。

\begin{lstlisting}[numbers=none]
(defn make-feed-processor
  "新しいFeed Processorを作成する"
  []
  (let [ch (async/chan 100)] ,,,))

(defn input-chan
  "feed processorの入力チャネルを返します。"
  [feed-processor] ,,,)
\end{lstlisting}


ほとんどの場合、外部チャネルを受け入れることで、第7章「アプリケーションの構成」で説明するように、後でシステムを組み立てるための最も多くのオプションが生まれます。ここで決定すべき重要なことのひとつに、入力チャネルのバッファリングポリシーがあります。もしコンポーネントが内部で入力チャネルを作成するのであれば、この決定を行わなければなりません。もし設定可能である必要があるのなら、コンポーネントはバッファ設定オプションを公開する必要があります。チャネルを外部で作成する場合は、システムのアセンブリコードがシステムの残りの部分と一緒に自由に設定することができます。

どちらの場合でも、チャネルを持つコンポーネントができたら、それらをさまざまな方法で接続する必要があります。\texttt{core.async}は多くの種類のチャネルコネクタを提供します。ここでは、それらを直接接続、ファンイン、ファンアウトの観点から分類してみます。

\subsection{ダイレクトコネクション（1対1）}

内部で構築されたチャネルを提供する2つのコンポーネントを組み合わせる場合、直接接続が必要になることがあります。2つのコンポーネントを一緒に使うには、この例のようにチャンネルをパイプで接続します。


\begin{lstlisting}[numbers=none]
(let [component1 (make-comp-1)
      output-chan (get-output component1)
      component2 (make-comp-2)
      input-chan (get-input component2)]
  (pipe output-chan input-chan))
\end{lstlisting}

ここでは、 \texttt{component1} が出力チャネル、 \texttt{component2} が入力チャネルで、両者をパイプでつないでいます。デフォルトでは、最初のチャネルが閉じられると、2番目のチャネルも閉じられ、効果的にこれら2つのチャネルを1つのチャネルにまとめ、プロデューサー用に使用されます。この自動閉鎖の動作は、最後にオプションのブール値フラグを指定することで無効にすることができます。

しかし、消費者側から見ると、消費者が 2 番目のチャネルを閉じた場合、1 番目のチャネルは入力の消費を停止しますが、閉じることはありません。長く接続されているコンポーネントでは、この違いは重要ではないかもしれません。しかし、1つのチャネルとパイプで接続された2つのチャネルの違いの1つは、この違いです。コンポーネントが外部で構築されたチャネルを使用している場合、中間パイプを必要とせずに、あるコンポーネントと別のコンポーネントを直接接続するようにシステムを組み立てることができます。

パイプラインで見たように、 \texttt{core.async} は \texttt{pipeline} 関数も提供しており、それを使って2つのパイプを並列変換ステージで繋ぐことができます。

\subsection{ファンアウト（1対多）}

\texttt{core.async}ライブラリを使うと、チャネル上のメッセージを多くのコンシューマに簡単に公開することができます。ファンアウトする最も一般的な理由は、独立したコンシューマが異なる目的でメッセージを処理できるようにすることです（先の例では、ロギングとセンチメント分析のように）。\texttt{core.async} ライブラリはこれを行うためのいくつかの方法を提供します: \texttt{split}, \texttt{mult}, \texttt{pub/sub}.


\includegraphics[width=8cm]{fig_06_003.eps}


\texttt{core.async}の \texttt{split} 関数は、1つのチャネルを受け取り、述語の真偽に基づいてトラフィックを2つの出力チャネルに分割します。これは図に示すとおりです。

例えば、\texttt{split} はストリームから無効なメッセージを分割し、別のプロセスに送って処理するのに適した方法です。


\includegraphics[width=8cm]{fig_06_004.eps}

\texttt{core.async}の \texttt{mult} 抽象化は、入力チャネルを受け取り、それを複数の出力チャネルに乗算します。

入力チャネルから項目が読み込まれると、次の値に移る前にすべての出力チャネルに供給されます。タップは \texttt{tap} 関数で \texttt{mult} に追加され（\texttt{untap} で削除され）ます。タップが閉じていることが判明した場合、そのタップは mult から削除されます。

すべてのチャネルが各値を受信する必要があるため、1つの遅いタップが \texttt{mult} を停止させる可能性があります。そこで、別のバッファリング戦略を使用することが有効です。例えば、パイプラインの特定の部分の出力ストリームをタップしてログにシャントし、何が起こっているかを覗き見ることができるようにしたいとします。

この関数は、入力と出力のチャネルを接続します（ \texttt{pipe} で行ったことと同様です）が、返されるログのタップもインストールします。


\begin{lstlisting}[numbers=none]
(defn connect-and-tap
  "入力と出力を接続し、その間を流れるチャネルロギングデータを返します。"
  [input output]
  (let [m (mult input)
       log (chan (dropping-buffer 100))]
    (tap m output)
    (tap m log)
    log))
\end{lstlisting}

