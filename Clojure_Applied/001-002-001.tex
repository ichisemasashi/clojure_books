\section{正しいコレクションの選択}

Clojureは少数のコレクションを提供しており、事実上すべてのアプリケーションのニーズに合わせて組み合わせて使用されます。Clojureの4つの主要なコレクション、リスト、ベクター、セット、マップの基本はすでにご存知でしょう。

使用する正しいコレクションを選択するとき、私たちは手元のデータの特性と、コレクションに呼び出すと予想される操作によって導かれます。Clojureコレクション関数は、しばしば実装者が満たさなければならない性能制約を指定します。

キーから値への関連付けが必要な場合、マップは明白な選択です。ドメイン・モデルでは、エンティティ・ホルダーとして、つまり、エンティティ・フィールドと値の間の関連付けとして、マップを使用することを検討しました。また、Modeling Relationshipsでは、マップを識別子からエンティティへのインデックスとして使用しました。get関数を使ってキーに基づいた値を調べたいときは、いつでもマップが必要だ。

Clojureのセットは数学的なセットとして動作し、順序付けされない、重複を許さないという重要な特性を持ちます。セットは主に、contains? や get を使ってセットが値を含むかどうかを素早くチェックする必要があるような状況で使われます。

他のほとんどのデータは、本質的にシーケンシャルです。Clojureはシーケンシャルなデータ構造として、listとvectorを提供します。次に、それらの選択方法について見てみましょう。

\subsection{シーケンシャルコレクション}

シーケンシャルデータとは、順番に並んだ一連の値のことである。シーケンシャルデータでは、データの追加と削除を行う場所と、インデックス付きアクセス（シーケンシャルコレクション内の位置から要素を探せるかどうか）が重要な検討事項となります。

Clojureのリストは、各セルが値と次のセルへの参照を含むリンクリストデータ構造として実装されています。リストでは、既存のリストを指す新しいセルを作成し、それをリストの先頭にすることで、チェーンの先頭に新しいリンクを追加することは簡単です。これに対して、リストの末尾に要素を追加する場合は、新しいセルを追加する前にリスト全体を走査する必要がある。

リストが最適なケースとして、スタック（ビュッフェの皿の積み重ねのようなもの）が必要な場合がある。スタックは、データ構造（ツリーやグラフ）を横断するときに、どこにいたかを覚えておく必要がある場合に便利である。要素は、\texttt{cons} を介してスタックの一番上に押し出される。また、(\texttt{peek} で)先頭の値を見たり、(\texttt{pop} で)スタックの先頭の要素を削除したりすることもできる。

Clojure ベクターは、配列と使い方を比較することができ、その要素へのインデックス付きアクセスを提供します。ベクターは、コレクションの最初ではなく、最後に成長するように設計されています。

\texttt{conj} のような Clojure の操作は自然な挿入ポイントで要素を追加します--リストの場合は最初で、ベクターの場合は最後です。多くの新しいClojure開発者は、1つの操作が異なるデータ構造に対して異なる動作をすることに戸惑いを覚えます。しかし、\texttt{conj}は各データ構造に最適な場所で効率的に要素を追加するように設計されています。
 
第1章「ドメインのモデル化」のレシピの手順で、コレクションを選択することを考えてみましょう。ユーザーがステップを挿入したときの順序を保持したいのであれば、 順番に追加していくような動作をさせるために vector を使用するのが最も理にかなっています。また、レシピの指示で何かを行う必要がある場合、インデックスでステップを検索することが有用であると思われます。

これで、どのシーケンシャル・コレクションを使うか、ある程度決まったと思います。シーケンシャルコレクションは、挿入順序を保持するので便利です（挿入ポイントに依存します）。Clojureのセットとマップは順不同ですが、Clojureはこれが重要な場合のためにソートされたセットとマップを提供します。

\subsection{ソートされたコレクション}

ソートされたセットやマップを使用すると、データが追加されたときにセットやマップ全体で維持したい順序を指定することができます。

私たちのレシピアプリケーションでは、Authorsのインデックスを配信できるようにしたいと思います。Authorsは一意であり、これはセットを使用することを意味します。セットでは、自動的に重複が削除されます。Authorsのインデックスをアルファベット順で保持したい。

ソートされたセットはコンパレータ関数を使用して、要素のペアのソート順を決定します。コンパレータ関数は要素のペアに適用され、最初の要素がコレクション内の2番目の要素よりも低く、同じ、または高くソートされるべきかを示すために、負の整数、ゼロ、または正の整数を返します。

Clojureは、文字列のアルファベット順、数値の昇順など、一般的なデータ型のための「自然な」ソート順を与えるデフォルトのコンパレータ（比較関数で実装）を提供します。デフォルトのコンパレータは、常に\texttt{nil}を他の値よりも低くソートします。ソートされたマップでは、コンパレータはマップのキーに適用され、値には適用されません。

ソートされたセットとマップのカスタムコンパレータを実装する際の一般的な落とし穴は、2つの要素が同じと比較された場合、コレクションの重複削除プロパティのため、1つだけが保持され、もう1つが削除されることです。

たとえば、著者エンティティのカスタムコンパレータの最初の実装では、姓のみを使用する場合があります。

\begin{lstlisting}[numbers=none]
user> (defn compare-authors-badly [s1 s2]
        (compare (:lname s1) (:lname s2)))
#'user/compare-authors-badly
user> (sorted-set-by compare-authors-badly
        {:fname "Jeff" :lname "Smith"}
        {:fname "Bill" :lname "Smith"})
#{{:lname "Smith", :fname "Jeff"}}
\end{lstlisting}

\texttt{compare-authors-badly}は\texttt{lname}フィールドのみに基づいて同等性を定義しているため、2つのauthorマップはセットによって同一とみなされ、重複が削除されます。2つの要素が同じ値を持つ場合にのみ、等しいものとして比較されることを保証することが重要です。これを行う1つの方法は、まず以前のように姓でソートし、次にエンティティの他の各フィールド（ここではファーストネーム）を比較して同値を解除することです。

\begin{lstlisting}[numbers=none]
user> (defn compare-authors [s1 s2]
        (let [c (compare (:lname s1) (:lname s2))]
          (if (zero? c)
            (compare (:fname s1) (:fname s2))
            c)))
#'user/compare-authors
user> (sorted-set-by compare-authors
        {:fname "Jeff" :lname "Smith"}
        {:fname "Bill" :lname "Smith"})
#{{:lname "Smith", :fname "Bill"}
  {:lname "Smith", :fname "Jeff"}}
\end{lstlisting}

この関数は2つのフィールドだけを持つエンティティを比較しますが、エンティティのフィールドをカスタムオーダーで考慮するコンパレータをより簡潔に実装するための一般的なパターンも存在します。このパターンは、関数のコレクションを受け取り、入力にすべての関数を適用する新しい関数を作成し、結果のベクトルを返す、気の遠くなるような\texttt{juxt}関数に依存しています。

\texttt{juxt}を使うと、一連のキーワードをゲッター関数のように適用して、比較に適したフィールド値の順序付きシーケンスを生成することができます。

つまり、\texttt{(juxt :lname :fname)} はエンティティに適用して \texttt{["Smith" "Jeff"]} のようなベクトルを生成することができる関数を生成するのです。そして、デフォルトの比較関数を使用して、これらのフィールドベクトルを自然な順序（左から右へ）で比較することができます。

これをもとに構築してみよう。\texttt{compare-authors}の中にローカルの\texttt{project-author}関数を作成し、各authorフィールドに\texttt{juxt}を適用して比較用のベクトルを返します。

\begin{lstlisting}[numbers=none]
user> (defn compare-author [s1 s2]
        (letfn [(project-author [author]
                  ((juxt :lname :fname) author))]
          (compare (project-author s1) (project-author s2))))
#'user/compare-authors
user> (sorted-set-by compare-author
        {:fname "Jeff" :lname "Smith"}
        {:fname "Bill" :lname "Smith"})
#{{:lname "Smith", :fname "Bill"}
  {:lname "Smith", :fname "Jeff"}}
\end{lstlisting}

これは、underspecificationの問題を回避するカスタムエンティティコンパレータを作成するための便利なテクニックを示しています。これらのコンパレータの作成に関する詳細は、Andy Fingerhut氏の有用なコンパレータ・ガイドを参照してください。

さて、仕事に最適なコレクションを選択して作成する方法を検討したので、要素が追加、更新、削除されたときに、それらのコレクションを更新する最適な方法を検討しましょう。

