\section{まとめ}

ムーアの法則に従ってトランジスタ数が増え続けるのは確かだが、それに伴うクロック速度の向上はもはや期待できない。その代わり、チップあたりのコア数は増え続けている。これからは、より多くのコアが利用可能になったときに、それを自動的に活用できる言語が求められているのです。

これまで、より多くのコアを利用して、より多くの作業を行うことができる分野をいくつか取り上げてきました。まず、futureを使ってバックグラウンドスレッドで非同期処理を行うことを考えてみました。Futuresは、非同期タスクを実行し、場合によってはその結果を通信で返す必要がある場合に、最初に選択すべきものです。もし、複数の値や非同期タスクの任意の場所からの配信が必要な場合は、promiseを使用してください。非同期タスクが状態を保持する必要がある場合（シミュレーションなど）、agentが最適です。

もし、あなたのシステムが仕事やリクエストの受信キューとして構成されているなら、その仕事をキューで受け入れ、ワーカスレッドのプールに送って処理する必要があります。そのためには、標準的なJavaライブラリのツールを使って、キュー、スレッド、エグゼキュータを使ってシステムを構成してください。

データが大きなベクトルやマップになっている場合は、reducerを使ってデータセット全体に対して並列に動作するように計算を構成する必要があります。reducerはシーケンス関数に期待されるような複合化能力を持ちながら、マシンの全コアをフルに活用することができ、中間オブジェクトを避けることでガベージコレクションを最小限に抑えることができます。

並行処理についてまだ調べていないことのひとつに、成長するシステムをいかにして断片化するかがあります。コンポーネント間の長寿命な接続を作成するために、再び core.async を活用することができます。次に、完全なアプリケーションを構築するために、これらのコンポーネントをどのように構築するかに焦点を当てます。


Footnotes
[19]
http://dl.acm.org/citation.cfm?doid=828.833