\section{すべてをまとめる}

多くの場合、シーケンシャルデータの処理は同じようなパターンで行われます。

\begin{enumerate}
\item  どんな質問をしようとしているのかを把握する。このステップは、問題領域やビジネス領域に位置するため、最も困難な場合が多い。明確な質問があれば、Clojureはあなたが持っているデータを処理して答えを出すためのツールを提供します。それが次の3つのステップです。
\item  データをフィルタリングして、不要な要素を取り除く。
\item 要素を目的の形に変換する。
\item 変換された要素を答えに還元する。
\end{enumerate}


ショッピングカートの例で説明しましょう。オンラインストアでは、カタログ、つまり販売する商品のリストがあります。これらの商品は部門ごとに分けられています。顧客はそれらをカートに入れ、チェックアウトする。このプロセスで、請求記録が作成されます。あなたの顧客は、部門別の売上を要約したレポートを要求しています：すべての決済されたカートについて、部門ごとの総売上はいくらですか？

ドメインモデルは次のとおりです。


\begin{lstlisting}[numbers=none]
(require '[money :refer [make-money +$ *$]])

(defrecord CatalogItem [number dept desc price])
(defrecord Cart        [number customer line-items settled?])
(defrecord LineItem    [quantity catalog-item price])
(defrecord Customer    [cname email membership-number])
\end{lstlisting}

何度もチェックアウトを繰り返すと、カートには\texttt{\#Cart}レコードのベクターが含まれることがあります。


\begin{lstlisting}[numbers=none]
[#Cart{:number 116,
       :customer #Customer{:cname "Danny Tanner",
                           :email "danny@fullhouse.example.com",
                           :membership-number 28374},
       :line-items [
         #LineItem{:quantity 3,
                   :catalog-item #CatalogItem{:number 664,
                                              :dept :clothing,
                                              :desc "polo shirt L",
                                              :amount 2515 :currency :usd},
                   :price #Money{:amount 7545
                                 :currency :usd}
         #LineItem{:quantity 1,
                   :catalog-item #CatalogItem{:number 621,
                                              :dept :clothing,
                                              :desc "khaki pants",
                                              :price #Money{:amount 3500
                                                            :currency
                                                            :usd},
                   :price #Money{:amount 3500
                                 :currency :usd}
                    ],
       :settled? true}, ,,, ]
\end{lstlisting}


これはかなり大きなデータ構造で、次の図のようなクラス図で理解するのが分かりやすいかもしれません。

\includegraphics[width=12cm]{fig_03_001.eps}

私たちが求めているのは、もっとシンプルな、部門と金額の対応表です。



\begin{lstlisting}[numbers=none]
{:clothing #Money{:amount 2386424, :currency :usd}
 :toys     #Money{:amount 1163277, :currency :usd}
 ,,, }
\end{lstlisting}

カートの中身から目的の出力まで、順を追って説明しましょう。まず最初にやるべきことは、気になるデータを見つけることです。

\subsection{選択}

シーケンス処理の選択ステップでは、興味のある要素だけを含む部分シーケンスを識別して作成します。カートデータに対してフィルタを使用することで、その要素を取得することができます。

レポートを作成する際、決済されたカートのみを考慮します。決済されるまでは、実際の収益ではなく、潜在的な収益に過ぎないからです。まず、filterを使用してリストのサイズを小さくします。



\begin{lstlisting}[numbers=none]
(defn revenue-by-department [carts]
  (->> (filter :settled? carts)
       ,,,))
\end{lstlisting}

キーワード \texttt{:settled?} を関数として使用すると、 \texttt{:settled?} が\texttt{true}でないカートをすべてフィルタリングすることができます。

\subsection{トランスフォーメーション}

これで一連の決済カートが揃ったので、部門別に収益を分離することができるようになりました。カートは一切必要なく、品目とカタログ品だけが必要なことがわかります。今は一歩ずつ進めていきましょう。次のステップは、すべてのラインアイテムのシーケンスを作成することです。


\begin{lstlisting}[numbers=none]
(defn revenue-by-department [carts]
  (->> (filter :settled? carts)
       (mapcat :line-items)
       ,,,))
\end{lstlisting}

\texttt{(mapcat :line-items ,,)} の結果は、このようになります。


\begin{lstlisting}[numbers=none]
[#LineItem{:quantity 3,
           :catalog-item #CatalogItem{:number   664,
                                      :dept  :clothing,
                                      :desc "polo shirt L",
                                      :price #Money{:amount 2515
                                                    :currency :usd}},
           :price #Money{:amount   7545
                         :currency :usd}},
 #LineItem{:quantity 1,
           :catalog-item #CatalogItem{:number 621,
                                      :dept :clothing,
                                      :desc "khaki pants",
                                      :price #Money{:amount 3500
                                                    :currency :usd}},
           :price #Money{:amount   3500
                         :currency :usd}}, ,,, ]
\end{lstlisting}

\texttt{mapcat}関数は、行項目ベクターの内容を集積したものを構築する。

\begin{itembox}[l]{mapcatとmap + flattenの使い分け}
\texttt{mapcat}の代わりに、\texttt{map}と\texttt{flatten}を併用することで、同様の結果を得ることができます。\texttt{flatten}を使いたくなったら、一歩戻って、そもそも\texttt{flatten}する必要がある構造を作らないようにしましょう。最も一般的なのは、\texttt{map}ではなく\texttt{mapcat}を使うことです（\texttt{map}と\texttt{concatenate}を行うため）。
\end{itembox}

次のステップは、各ラインアイテムから、カタログアイテムの \texttt{:dept} 値とラインアイテムの親の \texttt{:price} 値という気になるデータのマップを抽出することである。これは \texttt{map} と \texttt{line-summary} ヘルパー関数によって行われます。



\begin{lstlisting}[numbers=none]
(defn- line-summary
  "CatalogItem を持つ LineItem が与えられた場合、
   CatalogItem の :dept を :dept、LineItem の 
   :price を :total として含むマップを返します。"
  [line-item]
  {:dept (get-in line-item [:catalog-item :dept])
   :total (:price line-item)})

(defn revenue-by-department [carts]
  (->> (filter :settled? carts)
       (mapcat :line-items)
       (map line-summary)
       ,,,))
\end{lstlisting}

あと少しです。これで、報告する必要のあるデータのみを含む一連のマップができました。


\begin{lstlisting}[numbers=none]
[{:dept :clothing :total #Money{ ,,, }
 {:dept :clothing :total #Money{ ,,, }
 {:dept :toys     :total #Money{ ,,, }
 {:dept :kitchen  :total #Money{ ,,, }
 {:dept :toys     :total #Money{ ,,, }]
\end{lstlisting}

ここから、\texttt{group-by}を利用して、部門をキー、一連のサマリーを値とするマップを構築することができる。


\begin{lstlisting}[numbers=none]
(defn revenue-by-department [carts]
  (->> (filter :settled? carts)
       (mapcat :line-items)
       (map line-summary)
       (group-by :dept)
       ,,,))
\end{lstlisting}

この時点で、私たちのデータはこのようになっています。


\begin{lstlisting}[numbers=none]
{:clothing [{:dept :clothing :total #Money{},
            {:dept :clothing :total #Money{}, ,,,]
 :toys     [{:dept :toys     :total #Money{},
            {:dept :toys     :total #Money{}, ,,,]
 :kitchen  [{:dept :kitchen  :total #Money{}, ,,,]}
\end{lstlisting}

\texttt{:total}の\texttt{\#Money\{\}}の値のベクトルでサマリーを置き換えるという余分なステップを踏むこともできますが、それは不要です。その代わりに、最後のステップである、これらの値の要約に移りましょう。

\subsection{Reduction}

line-summary関数と同様に、各部門の集計を行う関数を定義して、削減処理で利用できるようにしたいと思います。


\begin{lstlisting}[numbers=none]
(require '[money :refer [make-money +$ *$])

(defn- dept-total
  [m k v]
  (assoc m k (reduce +$ (map :total v))))

(defn revenue-by-department [carts]
  (->> (filter :settled? carts)
       (mapcat :line-items)
       (map line-summary)
       (group-by :dept)
       (reduce-kv dept-total)))
\end{lstlisting}

断片的な\texttt{dept-total}関数の中に、通常のシーケンス処理パイプラインの縮図を見ることができます。この場合、\texttt{map}はシーケンスの各要素から\texttt{:total}を選択し、\texttt{reduce +\$}はそれを集計します。

\texttt{thread-last} マクロを使用した \texttt{dept-total} の代替実装は、読みやすいと思われます。


\begin{lstlisting}[numbers=none]
(defn- dept-total*
  [m k v]
  (assoc m k (->> (map :total v)
                  (reduce +$))))
\end{lstlisting}

以上です。最初のカートのベクトルを部門別の収益マップに落とし込みました。最終的なデータは、約束通り、このような形になりました。


\begin{lstlisting}[numbers=none]
{:clothing #Money{},
 :toys     #Money{},
 :kitchen  #Money{}, ,,, }
\end{lstlisting}

このセクションで行ったデータパイプラインは、\texttt{select}、\texttt{transform}、\texttt{reduce}という極めて典型的なものです。これはシーケンス処理の一単位と考えた方がよいかもしれません。\texttt{dept-total}関数で見たように、1つのシーケンス処理の単位が他の単位全体を包むことができるのです。練習を重ねるうちに、スムーズなパイプラインを作ることが反射的にできるようになるはずです。

もう一つ重要なことは、\texttt{revenue-by-department}関数で\texttt{thread-last}マクロ(\texttt{->>})を使っていることから明らかなように、シーケンスはプロセスの各段階に出入りしていることです。実際、最初の3つのステップ（\texttt{filter}, \texttt{mapcat}, \texttt{map}）において、開始シーケンスの各要素は、次の要素が始まる前に3つのステップをすべて成功させることができ、結果は同じになるのです。これらのステップでは、前や後に続くものを考慮することなく、一度にシーケンスの単一の要素に対して操作を行います。これは、パイプラインのこの部分にトランスデューサを使用することも選択肢の一つであることを示す良い手がかりとなります。