\section{リレーションシップのモデル化}

エンティティは、それ自体ではあまり意味がない。ほとんどのモデルでは、SQLデータベースの外部キーのように、異なるタイプのエンティティを接続して、データ内に関係を作成する必要があります。

エンティティは、他のエンティティを参照するために、入れ子、識別子、ステートフル参照という3つの主要な技術を使うことができる。これらのテクニックはすべて他の言語（およびデータベース）にも類似していますが、Clojureユーザーはこれらのテクニックの使用を他の言語とは異なる優先順位で使用します。Java のような言語は、1 つの変更可能なオブジェクトから別のオブジェクトへの状態的な参照に大きく依存しています。Clojureのユーザーはネストと識別子のテクニックを最初に使い、特別な場合のみステートフル参照にフォールバックします。

ネストは単に、親エンティティの直下に別のエンティティを含むことを意味します。ネストされたエンティティが親エンティティの一部であり、そのライフサイクルに従う場合、ネストは簡単な選択です。

実際の例を考えてみましょう。レシピマネージャアプリケーションを構築している場合、明らかにレシピをモデル化する必要があります。


\begin{lstlisting}[numbers=none]
(defrecord Recipe
  [name       ;; string
  author      ;; recipe creator
  description ;; string
  ingredients ;; list of ingredients
  steps       ;; sequence of string
  servings    ;; number of servings
  ])
\end{lstlisting}


この詳細については、後ほど説明します。今はレシピの\texttt{author}フィールドに焦点を当てます。今のところ、\texttt{author}モデルをシンプルに保つことにします。


\begin{lstlisting}[numbers=none]
(defrecord Person
  [fname ;; first name
   lname ;; last name
  ])
\end{lstlisting}

ここで、\texttt{Recipe}と\texttt{Person}のインスタンスを接続するためのオプションについて考えてみましょう。もし、\texttt{Recipe}をアプリケーションの中心的存在にすることに興味があり、著者を単に\texttt{Recipe}に関する記述的な情報と考えるなら、\texttt{Recipe}の下に\texttt{Person}をネストさせることができます。

\begin{lstlisting}[numbers=none]
(def toast
  (->Recipe
    "Toast"
    (->Person "Alex" "Miller") ;; nested
    "Crispy bread"
    ["Slice of bread"]
    ["Toast bread in toaster"]
    1))
\end{lstlisting}

しかし、このアプリケーションの別のバージョンでは、著者をより重要視する可能性があります。ユーザーは、1つのレシピで人の情報を更新すると、すべてのレシピでその情報が更新されることを期待するかもしれません。その場合、\texttt{Person}をプライマリエンティティとしてモデル化し、その人が執筆したレシピのリストをネストさせるとよいでしょう。

あるいは、\texttt{Person}と\texttt{Recipe}の両方をトップレベルのエンティティとして、それぞれを一箇所で更新できるようにしたい場合もあります。例えば、\texttt{Recipe} には複数の作成者がいる場合があります。この場合、入れ子に頼らず、よく知られている識別子でエンティティを参照することができます。識別子とは、他の場所で定義されたエンティティを参照するための単純な値 (通常はキーワード、文字列、数値) のことです。レシピと著者を別々に管理できるように、データモデルを作り直しましょう。

\begin{lstlisting}[numbers=none]
(def people
  {"p1" (->Person "Alex" "Miller")})

(def recipes
  {"r1" (->Recipe
          "Toast"
          "p1" ;; Person id
          "Crispy bread"
          ["Slice of bread"]
          ["Toast bread in toaster"]
          1)})
\end{lstlisting}

この例では、識別子によってエンティティのインデックスを作成する2つのマップ（\texttt{people}と\texttt{recipes}）を保持しています。\texttt{Recipe}がある\texttt{Person}を\texttt{author}として参照する必要がある場合、エンティティを直接ネストするのではなく、\texttt{Person}の識別子を使用します。これで、\texttt{Person}と\texttt{Recipe}の両方のエンティティを独立して検索、変更できるようになりました。

識別子をプログラムで生成し (多くの場合、データベースが生成してくれます)、 ユーザが識別子を選択したり編集したりできないようにすることは、 ほとんど常に良いアイデアです。こうすることで、ユーザーに影響を与えることなく、後でモデリング戦略を変更する自由度が高まります。

他のエンティティを参照し、その関係が時間とともに変化するようにしたい場合は、ステートフル参照を使用します。Clojureは、第4章「状態、アイデンティティ、変更」でより詳細に検討する、いくつかの状態構造を提供します。

ステートフルリファレンステクニックは、オブジェクトのグラフを作成するオブジェクト指向の実践に最も近いものです。しかし、Clojureではデータモデル内部で状態を使用することは稀で、ネストや識別子を使用し、アプリケーションデータの大きな塊の周りだけで状態を作成する方がはるかに一般的です。

次に、プロジェクトが進化してもエンティティを有効に保つための1つの方法を見ていきます。
