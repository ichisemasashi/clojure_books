\section{待機をバックグラウンドに押しやる}

ほとんどのプログラムは、ファイル、ソケット、標準的なターミナルストリームを通して外部世界と接続します。これらすべてを入出力、I/Oと呼んでいます。最近のプロセッサは1秒間に何十億もの命令を実行することができますが、ほとんどのI/Oは比較的低速です。多くのプログラムは、ファイルからデータを読み込んだり、外部サーバーから応答を受け取ったり、ユーザーが何をしたいのかを調べるために、かなりの時間をかけて待機しています。

プログラムが他の作業を続けられるように、この待ち時間を効率的に処理する必要があります。待っている間、私たちは他の処理を行うこともできますし、複数の処理を並行して待つこともできます。例えば、ウェブブラウザは、外部のウェブサーバがコンテンツを返すのを待つと同時に、現在のページをレンダリングし、ユーザーがリンクをクリックしたりページをスクロールしたりするのに応答して時間を費やしているプログラムである。

\subsection{ファイヤー・アンド・フォーゲット}

まず、バックグラウンドで応答不要な作業を行うという単純なケースを考えてみよう。アプリケーションを構築しているときに、イベントが発生するたびに外部の計測器コレクターを呼び出したいとします。この外部サービスは、inc-stat という便利な関数でラップすることができます。更新するstatを指定して、この関数を呼び出します。


\begin{lstlisting}[numbers=none]
(inc-stat :pageview)
\end{lstlisting}

この関数は、ネットワーク経由で外部のウェブサービスを呼び出そうとしています。もし、ページビューを制作中に呼び出すと、次の図にあるように、その呼び出しにかかる時間は、ページを構築するごとに遅くなってしまいます。


\includegraphics[width=10cm]{fig_05_001.eps}

この作業をバックグラウンドのスレッドに移すために、Clojureに含まれる\texttt{future}関数を使用します。

\begin{lstlisting}[numbers=none]
(future (inc-stat :pageview))
\end{lstlisting}

\texttt{future}関数はボディを受け取り、Clojure自身が維持するバックグラウンドのスレッドプールでそのボディを呼び出す。図にその違いを見ることができます。

\includegraphics[width=8cm]{fig_05_002.eps}

また、\texttt{future-call}を使用すると、ボディを渡す代わりに引数のない関数を非同期で呼び出すことができます。どちらの関数も\texttt{java.lang.Future}オブジェクトを返し、それを使って非同期の活動を制御したり検査したりすることができます。\texttt{future-cancel}関数はその実行をキャンセルし、\texttt{future-done?}と\texttt{future-cancelled?}はその状態についての情報を与えてくれます。

しかし、独立した統計値増加メッセージをリモートサービスに大量に送信するのは非効率的だと思われます。送信前にいくつかのインクリメントメッセージをバッチ処理する方がより理にかなっています。そのためには、非同期かつステートフルである必要がある。


\subsection{非同期とステートフル}

第4章「状態、アイデンティティ、変化」では、Clojureの状態コンテナであるvar、atom、refを検討しました。もう一つの状態コンテナであるagentの紹介は、今まで遅らせました。

他のステート・コンテナと同様に、agentは不変の値を保持し、同じ更新モデルを使用して変更されます。他のコンテナとは異なり、agentは非同期に更新されます。

メトリクス・コレクターを考えてみましょう。ある統計量のカウンターをagentに保持することにしましょう。

\begin{lstlisting}[numbers=none]
(def pageview-stat (agent 0))
\end{lstlisting}

agentの更新ごとにリモートサービスを呼び出すのではなく、10回目の更新（agentの状態が10で割り切れる回数に達したとき）ごとに呼び出すことにします。これは、ウォッチ(すべてのステートコンテナで動作する)を使えば簡単にできます。


\begin{lstlisting}[numbers=none]
(add-watch
  pageview-stat
  :pageview
  (fn [key agent old new]
    (when (zero? (mod new 10))
      (remote-send key new))))
\end{lstlisting}

ここでは、\texttt{pageview-stat} エージェントに、その状態が変化したときに起動されるウォッチを追加しました。新しいエージェントの状態が 10 の倍数のときだけ外部サービスリクエストを発行するようにし、バッチ処理を行うようにしました。

そして、アプリケーションが使用するインクリメント関数を、エージェント上で非同期的に実行される関数として定義することができます。





