\section{エンティティのモデリング}


プログラミングの作業は、解決したい問題から始まります。最初に直面するのは、問題の領域をどのようにモデル化し、解決策を表現するかという課題です。私たちが下す決定は、アプリケーションのアルゴリズムや性能だけでなく、外部システムとの対話の仕方にも影響します。まず、Clojureでドメインエンティティをどのように表現すべきかを検討することから始めます。

Clojureでは、ドメインエンティティを表現するためにマップまたはレコードのいずれかを使用します。マップはキーと値のペアの一般的なコレクションであり、レコードはよく知られたフィールドのためにあらかじめ定義された構造を持つ型を構築します。

これから、予想される使用パターンとパフォーマンスの必要性に基づいて、マップとレコードのどちらを選択するかについて、多くの検討事項を見ていきます。しかし、まずはマップとレコードを使ってどのようにエンティティをモデル化するかを確認することから始めましょう。


\subsection{マップ}

マップはあらかじめ定義された構造を持たず、制約が少ないため、非常に柔軟性がある。マップはキーと値のペアの集まりであり、キーによって値を効率的に一定時間で検索することができる。マップを実体として使うには、属性名をキーとして指定する。通常はキーワードで指定する。

\begin{itembox}[l]{実質的に一定時間}
Clojureでは、マップ、ベクター、セットは、32方向の分岐係数を用いたハッシュ配列のマップドツリーによって実装されています。ルックアップは木探索に基づいており、その時間複雑度は$O(\log n)$です。しかし、これらのClojureデータ構造は32方向の分岐係数を使用するので、実際のルックアップ時間は$O(\log _{32} n)$になります。実用的には、ほとんどのマップ 10億の項目を持つマップでも6レベルしか必要ない。この関数は非常にゆっくり成長するので、我々はこれらのデータ構造のルックアップを実質的に一定と呼ぶことにする。
\end{itembox}


例えば、太陽系をシミュレートするプログラムを作ることになったとしよう。このプログラムでは、太陽、惑星、それらの衛星、そしておそらくその他の注目すべき物体を表現するエンティティが必要になるでしょう。まず、地球を実体としてどのようにモデル化するかを考えてみましょう。地球は惑星であり、シミュレーションに必要ないくつかの属性を持っています。

Clojureでは、属性のセットを持つ実体をモデル化する最も簡単な方法は、Clojureマップを使うことです。

\begin{lstlisting}[numbers=none]
(def earth {:name   "Earth"
            :moons  1
            :volume 1.08321e12 ;; km^3
            :mass   5.97219e24 ;; kg
            :aphelion 152098232 ;; km, farthest from sun
            :perihelion 147098290 ;; km, closest to sun
           })
\end{lstlisting}

この後の章で説明するように、動的な動作を駆動するために使用できるエンティティタイプを持つことは、しばしば有用です。たとえば、太陽系のエンティティのうち惑星であるものだけを検索したい場合などです。この例を少し拡張して、エンティティをマークするための \texttt{:type} 属性を追加することができます。


\begin{lstlisting}[numbers=none]
(def earth {:name   "Earth"
            :moons  1
            :volume 1.08321e12 ;; km^3
            :mass   5.97219e24 ;; kg
            :aphelion 152098232 ;; km, farthest from sun
            :perihelion 147098290 ;; km, closest to sun
            :type       :Planet ;; entity type
           })
\end{lstlisting}


しかし、この構造（特にフィールド名）を、チームの他の開発者にとって有用な方法で取得することはできませんでした。

Clojureレコードは、この目的のために設計されました。


\subsection{レコード}

レコードは、ドメインエンティティをサポートするために、よく知られたフィールドとコンストラクタというクラスのような機能を提供します。レコードは型名とフィールドで作成されます．


\begin{lstlisting}[numbers=none]
(defrecord Planet [name
                   moons
                   volume ;; km^3
                   mass   ;; kg
                   aphelion ;; km, farthest from sun
                   perihelion ;; km, closest to sun
                   ])
\end{lstlisting}


レコード構造が定義されると、それを使って同じよく知られたフィールドを持つレコードのインスタンスを多数作成することができる。このレコードのすべてのインスタンスは、（作成したネームスペース内の）\texttt{Planet}という観測可能な型を持つことになる。

\texttt{defrecord}のフィールドは、ドメインエンティティのすべてのインスタンスで共有されます。さらに、新しいインスタンスの作成を支援するために、2 つのファクトリー関数が自動的に作成されます。\texttt{Planet}レコードの場合、\texttt{defrecord}で指定された順序で各属性の値を期待する位置ファクトリ関数(\texttt{->Planet})と、キー値を持つマップを期待するマップファクトリ関数(\texttt{map- >Planet})が存在することになる。

\begin{lstlisting}[numbers=none]
;; Positional factory function
(def earth
    (->Planet "Earth" 1 1.08321e12 5.97219e24 152098232 147098290))
;; Map factory function
(def earth
    (map->Planet {:name       "Earth"
                  :moons      1
                  :volume     1.08321e12
                  :mass       5.97219e24
                  :aphelion   152098232
                  :perihelion 147098290}))
\end{lstlisting}

位置指定ファクトリ関数はより簡潔であるが、すべての属性を指定された順序で含める必要があるため、レコードが変更された場合に呼び出し側が壊れる可能性が高くなる。mapファクトリー関数はオプションの属性を省略することができ、より多くの説明を提供し、レコードに新しい属性が追加されても動作し続けることができます。

\subsection{マップとレコードの使い分け}

マップとレコードはどちらもアクセスや変更に標準的なマップコレクション関数を使用するが、ドメインエンティティにはレコードの方が適している場合がほとんどである。レコードはホストプラットフォームであるJava Virtual Machine (JVM)の機能を利用して、いくつかの点でより良い性能を提供する。レコードは、各属性のフィールドを持つJavaクラスを作成することで、その型を定義する。レコードはそのフィールド定義でプリミティブ型のヒントを得ることができ、基礎となるJavaクラスでプリミティブフィールドを作成します。これは、数値に対してより効率的な表現と高速な演算を提供します。また、Javaクラスは、JavaインタフェースやClojureプロトコルを実装する場所を提供し、動作をレコードに直接配置し、それらの場合の最速の関数ディスパッチを提供します。

レコードがよく知られたフィールド、型、ファクトリー関数、およびより良いパフォーマンスを与えることを考えると、それらはドメインエンティティのためのあなたの最初の選択肢であるべきです。なぜマップを代わりに使うのでしょうか？

マップを強く考慮すべき特定のケースの1つは、JavaまたはClojureによって消費されることが期待されているかどうかにかかわらず、公衆向けのAPIにあります。APIでは、呼び出し側の制約を最小化することが重要です。レコードクラスのインスタンスを作成することを要求すると、それらのクラスの詳細の一部が事実上公開されることになります。この場合、よく知られたキーのセットを持つマップは、より少ないコミットで、よりシンプルで良い選択となる。

マップとレコードの選択を間違えても気にしないでください。レコードは、すべての重要な点で、事実上、マップである。マップもレコードも同じインターフェースを持っています。つまり、内部的にはレコードを使いながら、APIからエンティティを返すときだけレコードのマップの側面を利用するのは簡単なことです。主な相違点は、構築と型に基づく動的な動作の2点です。

\texttt{defrecord}が提供するファクトリー関数に加えて、エンティティを作成する際に、より柔軟性を提供する関数を定義すると便利なことがあります。これらについては、次に詳しく説明します。 





