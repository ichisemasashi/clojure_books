\section{はじめに}

プログラミング言語をおもちゃ箱から出して、職場に持ち込むのは大変なことです。Clojureで実物大のアプリケーションを設計または開発したことがない場合、どこから始め、どのように進め、日々の開発プロセスがどのようなものになるのか分からないかもしれません。あなたは一人ではありません、そして私たちがお手伝いします。Clojureの実践をプロフェッショナルなレベルに引き上げる方法をご紹介します。

Clojureのデータ、Lisp構文、関数型への傾倒は、エレガントなアプリケーションを書く力を与えてくれることでしょう。しかし、これらの機能を最大限に活用することを学ぶことは、単なる構文ではありません。チェスのゲームを考えてみてください。

チェスの遊び方を理解することは、どの駒がどこに動けるかを理解することではありません。開幕の選択、中央への圧力と保持、中盤への移行、相手のキングのトラップなど、より広範な事柄が関わってくるのです。しかし、満足のいく勝利を収めるには、より大きな概念を理解する必要があります。

Clojureの学習も同じです。構文と動作は、熟練への第一歩に過ぎません。言語の原理を理解し、それを実践することが次のステップです。

どんなトピックでも、初めてのときは、操作するための強力なガイドラインを持つことが役に立ちます。ルールは練習になり、練習は習慣になり、習慣は直感になります。やがて、正しいことを行うための嗅覚が身につくでしょう。

練習を重ねるうちに、どのルールが曲げられるかがわかり、自分なりのスタイルを確立できるようになります。いずれは紹介したテクニックを使いこなすことができるようになりますが、その時には、このテキストをマスターへの足がかりの一つとして懐かしく思い出していただけることを願っています。


\subsection{Clojureを仕事に活かす}

Clojureアプリケーションはすべて、イミュータブルな値を基盤に構築されています。不変性は単純なスカラー値だけでなく、リスト、ベクトル、マップ、セットなどの複合的な値にも存在します。不 変の公理は、データ変換、状態、並行処理、さらにAPI設計に対する我々のアプローチの根底をなしています。

本書では、Clojureアプリケーションを下から上へと構築し、それらのシステムを実稼働させる方法を学びます。このプロセスは、単純なコンセプトから始まり、アプリケーションが完全な機能を持つまで、より大きなコードの単位を構築します。

まず、問題領域をドメインエンティティと関係でモデル化する方法について見ていきます。ドメイン内の値や実体を収集する際に使用する最適なデータ構造の選択方法を、あまり知られていない、より専門的なオプションも含めて学びます。利用可能なコレクションのどれも十分でない場合、既存のClojureコア・ライブラリで動作する独自のカスタム・コレクションを構築する方法についても学びます。

データ表現ができたら、実体とコレクションの両方をどのように変換するかを検討する必要があります。このために、主に関数型プログラミングのツールに頼ることができます。Clojureプログラムで作成する関数のほとんどは純粋で、ある不変の値（それがエンティティ、コレクション、シーケンス、またはツリーであろうと）を副作用なしに別の不変の値に変換します。このように、不変な値と純粋な関数の組み合わせは、コードを理解しやすく、テストしやすくし、管理されていない変異性が引き起こす多くの問題から免れるようにします。


\subsection{アプリケーションの構築}

データの表現とそれに対する基本的な操作を開発したら、そこからどのようにアプリケーションを構成する大きな構造体を構築するかを検討する必要があります。そのためには、ステート、コンカレンシー、コンポーネントといったものが必要になる。

イミュータブルな値と純粋な関数の組み合わせは、まさに状態を生成し維持するのに必要な基盤を提供する。Clojureでは、stateはIDによって参照される現在の値です。状態の変更は、更新関数が現在の値を新しい値に変換するときに起こります。Clojureには、共有IDを確立できるいくつかのステートフルな参照型があります。ニーズに合わせて最適な参照型を選択する方法を学びます。

この状態モデルは単純ですが、Clojureが並行プログラムを書くのに適している秘密です。状態変更に不変の値と単純なモデルに頼ることができれば、並行処理を使用して処理をスケールアップすることがはるかに容易になります。Clojureの並行処理技術を、バックグラウンドでの作業とデータの並行処理の両方に活用する方法を学びます。

次に、より大きな目標を達成するために、より大きなコード単位に移行する必要があります。コードを整理するために名前空間を活用する方法と、コンポーネントを設計する方法を学びます。コンポーネントは、APIを通じて機能を公開し、状態を保持し、並行処理を管理することができます。コンポーネントは、他のコンポーネントを集約して、アプリケーションのサブシステムとして動作させることもできます。

最後に、コンポーネントを接着して、アプリケーション全体を組み立てることになります。システム構成の読み込み、コンポーネントのインスタンス化、コンポーネントの接続、アプリケーション全体のエントリーポイントの提供について学びます。

このように下から上へとシステムを構築していくプロセスは論理的ですが、実際のアプリケーションの中で直線的な順序で行うことはまずありません。データモデルの開発から始めることもあれば、システムをどのようにサブシステムやコンポーネントに分割し、それらのコンポーネントをどのように接続するかを決定することから始めることもあります。ほとんどの場合、その両方を行うことになるでしょう。

両方の作業を行うことで、問題をより深く理解することができるのです。両方の情報を組み合わせた反復プロセスによってのみ、最終的なソリューションの形が見えてくるのです。とはいえ、最終的なアプリケーションには、前文で説明したような断片が、最後まで残っていると考えてください。


\subsection{ビルドからデプロイまで}

Clojureアプリケーションの構築方法の概要を見た後は、テスト、統合、デプロイメントなど他の関心事を検討する必要があります。

Clojureコードのテストを見ると、Clojure開発者は例ベースのユニットテストから、REPLでの対話型開発や、より幅広い入力を正しく調査できるモデルまたはプロパティ指向のアプローチのような他のアプローチに傾いていることがわかります。このアプローチは、より短い時間でより多くのカバレッジを提供し、長期にわたって保守しやすいテストを作成します。しかし、これは考え方を変えることであり、最大の効果を得るためには、ある程度の練習が必要です。

また、Clojureベースのアプリケーションを他のシステムに接続する必要があるかもしれません。Webや他のユーザーインターフェイスを統合したり、APIサービスを公開したり、外部APIを消費したりすることです。これらの問題に対するClojureのアプローチは、当然のことながら、データ（およびワイヤを介したデータの伝送）を重要視して扱います。利用可能なオプションのいくつかについて学び、パフォーマンスや拡張性を最大化するために、異なる状況でどれを使うべきかを学びます。

最後に、アプリケーションをクラウドベースのコンテナにデプロイする必要があります。最も人気のある選択肢のいくつかと、その中からどのように選択するかを見ていきます。


\subsection{本書について}

本書は、入門教材からClojureで実際の問題を解決するまでの橋渡しとして、提供されるツールと調和した方法で問題を考えるためのガイドを提供するものです。

\subsection{本書の対象者}

本書を読むには、Clojureの基本的な概念と構文に慣れている必要があります。本書では、優れたアプリケーションを構築するという大きな目標をサポートするために、すでに知っている部分をつなげることを学びます。

\subsection{本書の読み方}

各章は前のトピックの上に成り立っているので、第1部と第2部を順番に読んでください。これは物語であり、参考文献ではありません。パート3は、どのような順番で読んでもかまいません。パート3の各章は独立していますが、パート1や2で説明した内容に依存する場合があります。




