# CHAPTER 10  ドキュメント

Written by Tom Manshreck

Edited by Riona MacNamara

多くのエンジニアがコードの作成、使用、保守に関して抱いている不満の中で、共通しているのは、質の高いドキュメントがないことです。"この方法の副作用は何ですか？" "ステップ3の後にエラーが出ました。" "この頭字語は何を意味しますか？" "このドキュメントは最新のものですか？" すべてのソフトウェアエンジニアは、そのキャリアを通じて、ドキュメントの質、量、あるいはまったくの欠如について不満を口にするものであり、Googleのソフトウェアエンジニアも同様である。

テクニカルライターやプロジェクトマネージャーの助けはあっても、ソフトウェアエンジニアは常にほとんどのドキュメントを自分で書く必要がある。そのため、エンジニアが効果的にドキュメントを書くためには、適切なツールとインセンティブが必要です。エンジニアが質の高いドキュメントを簡単に書けるようにするには、組織の規模に合わせたプロセスやツールを導入し、既存のワークフローと連携させることが重要です。

全体的に見ると、2010年代後半のエンジニアリング・ドキュメンテーションの状況は、1980年代後半のソフトウェア・テストの状況に似ています。ドキュメンテーションを改善するためにもっと努力する必要があることは誰もが認識していますが、その重要なメリットが組織的に認識されているわけではありません。しかし、少しずつではありますが、その状況は変わりつつあります。Googleでは、ドキュメントをコードのように扱い、従来のエンジニアリングのワークフローに組み込むことで、エンジニアが簡単なドキュメントを書いて維持することができるようになったときに、最も成功した取り組みがあります。

## ドキュメンテーションとは？

「ドキュメント」とは、エンジニアが仕事をする上で必要なあらゆる補足テキストのことを指します。(実際、Googleのエンジニアが書くドキュメントのほとんどは、コードコメントの形で提供されています）。この章では、さまざまな種類のエンジニアリングドキュメントについて説明します。

## ドキュメンテーションはなぜ必要なのか？

質の高いドキュメントは、エンジニアの組織にとって非常に大きなメリットがあります。コードやAPIがより理解しやすくなり、ミスが減ります。プロジェクトチームは、設計目標やチームの目的が明確に示されていると、より集中できます。マニュアルプロセスでは、手順が明確に示されていると従うのが容易になります。新しいメンバーをチームやコードベースに迎え入れる際にも、プロセスが明確に文書化されていれば、労力が大幅に軽減されます。

しかし、文書化のメリットは必ずしも下流にあるため、一般的に文書化した人がすぐに利益を得ることはできません。これから説明するように、プログラマーにすぐに利益をもたらすテストとは異なり、ドキュメント作成は一般的に前もって多くの努力を必要とし、作成者に明確な利益をもたらすのは後になってからです。しかし、テストへの投資と同様に、ドキュメンテーションへの投資も時間が経てば元が取れます。つまり、ドキュメントを書くのは一度だけかもしれないが(*1)、その後、何百回、何千回と読まれることになり、その初期費用は将来の読者すべてに償却されることになるのだ。ドキュメントは時間とともにスケールするだけでなく、組織の他の部分も同様にスケールするために重要です。それは、次のような質問に答えるのに役立ちます。

- なぜこのような設計判断をしたのか？
- なぜこのコードをこのように実装したのか？
- 2年後に自分のコードを見たときに、なぜこのコードをこのように実装したのか？

ドキュメントがこのようなメリットを伝えるものであるならば、なぜ一般的にエンジニアから「貧弱」と言われるのでしょうか？その理由の一つは、これまで述べてきたように、特に書き手にとってのメリットがすぐには得られないことです。しかし、それ以外にもいくつかの理由があります。

- エンジニアは、ライティングをプログラミングとは別のスキルと考えていることが多いです。(ここでは、そうではないことを説明します。また、そうであっても、必ずしもソフトウェアエンジニアリングとは別のスキルではありません。)
- エンジニアの中には、自分には文章を書く能力がないと思っている人もいます。しかし、実用的なドキュメントを作成するのに、英語力(*2)が必要なわけではありません。自分から少し離れて、相手の立場に立って物事を考えればいいのです。
- ドキュメントの作成は、ツールのサポートや開発者のワークフローへの統合が限られているために、より困難になることが多い。
- ドキュメンテーションは、既存のコードのメンテナンスを容易にするものではなく、余分な負担（メンテナンスするための他の何か）と見なされます。

すべてのエンジニアリングチームがテクニカルライターを必要としているわけではありません（仮にそうだとしても、その数は十分ではありません）。つまり、ほとんどのドキュメントはエンジニアが自分で書くことになります。ですから、エンジニアにテクニカルライターになることを強要するのではなく、エンジニアがドキュメントを書きやすくするにはどうしたらいいかを考えるべきなのです。ドキュメンテーションにどれだけの労力を割くかは、あなたの組織でもいつかは決めなければならないことです。
ドキュメンテーションは、いくつかの異なるグループに利益をもたらします。書き手にとっても、ドキュメンテーションは以下のようなメリットがあります。

- APIの策定に役立ちます。ドキュメントを書くことは、そのAPIが意味のあるものかどうかを見極める最も確実な方法の一つです。多くの場合、ドキュメントを書くこと自体が、エンジニアに、他の方法では疑われないような設計上の決定を再評価させるきっかけとなる。説明できない、定義できないということは、おそらく十分に設計されていないということです。
- メンテナンスのためのロードマップと歴史的な記録を提供します。コードのトリックは避けるべきですが、優れたコメントは、2年前に書いたコードを見つめながら何が問題なのかを考えているときに、大いに役立ちます。
- あなたのコードをよりプロフェッショナルに見せ、トラフィックを促進します。開発者は当然のことながら、ドキュメントが充実したAPIは設計の良いAPIだと考えるでしょう。必ずしもそうとは限りませんが、両者はしばしば高い相関関係にあります。製品のドキュメントが充実しているかどうかは、その製品がどの程度メンテナンスされているかを示すかなり良い指標となります。
- 他のユーザーからの質問が減ります。これはおそらく、ドキュメントを書いている人にとって、時間をかけて得られる最大のメリットです。何かを誰かに何度も説明しなければならない場合、そのプロセスを文書化することは通常意味のあることです。

ドキュメントを書く人にとってのこれらの利点と同様に、ドキュメントの利点の大部分は、当然ながら読者にもたらされます。GoogleのC++スタイルガイドでは、「読み手のために最適化する」という格言が記されています。この格言は、コードだけでなく、コード周りのコメントや、APIに付属するドキュメントセットにも当てはまります。テストと同じように、良いドキュメントを書くために費やした努力は、その寿命の間に何倍もの利益をもたらします。ドキュメントは時間とともに重要になり、組織の規模が大きくなるにつれて、特に重要なコードに多大な利益をもたらします。

## ドキュメントはコードと同じ

1つの主要なプログラミング言語を使用しているソフトウェアエンジニアでも、特定の問題を解決するために異なる言語を使用することはよくあります。シェルスクリプトやPythonを使ってコマンドラインタスクを実行したり、バックエンドのコードのほとんどをC++で書き、ミドルウェアのコードの一部をJavaで書いたり......。それぞれの言語はツールボックスの中の一つの道具です。

ドキュメントも同じで、特定のタスクを達成するために、異なる言語（通常は英語）で書かれたツールです。ドキュメンテーションを書くことは、コードを書くこととあまり変わりません。プログラミング言語のように、規則、特定の構文、スタイルの決定があり、多くの場合、コードと同じような目的を達成するために、一貫性を保ち、明確性を高め、（理解の）誤りを避けるために書かれます。技術文書において文法が重要なのは、ルールが必要だからではなく、音声を標準化し、読者を混乱させたり、気を散らさせたりしないためです。Googleが多くの言語で特定のコメントスタイルを要求しているのはこのためです。

コードと同様、ドキュメントにもオーナーが必要です。所有者のいないドキュメントは陳腐化し、メンテナンスも困難になります。また、オーナーシップを明確にすることで、バグトラッキングシステムやコードレビューツールなど、既存の開発者のワークフローでドキュメントを扱うことが容易になります。もちろん、所有者が異なるドキュメント同士が衝突することもあります。そのような場合には、正規のドキュメントを指定することが重要です。つまり、プライマリ・ソースを決定し、関連する他のドキュメントをそのプライマリ・ソースに統合します（または、重複するドキュメントを廃止します）。

Googleで普及している「go/links」（第3章参照）は、このプロセスを容易にしています。分かりやすいgo/linksを持つドキュメントは、しばしば正典となります。正準化されたドキュメントを促進するもう一つの方法は、ドキュメントをソースコントロールの下に直接置き、ソースコードそのものと並べることで、ドキュメントをコードと直接関連付けることです。

ドキュメントはコードと密接に結びついていることが多いので、可能な限りコードとして扱われるべきです。つまり、ドキュメントは以下のようにすべきです。

- 従うべき内部ポリシーやルールがある
- ソース管理されている
- ドキュメントの維持に責任を持つ明確なオーナーシップがある
- 変更時にはレビューを受ける（ドキュメントのコードと一緒に変更される)
- コードのバグを追跡するように、問題が追跡されること
- 定期的に評価される（何らかの形でテストされる）。
- 可能であれば、正確さや新鮮さなどの面で測定されること。(ツールはまだここに追いついていない）。

エンジニアがドキュメント作成をソフトウェア開発に必要な作業の1つと考えれば考えるほど、ドキュメント作成にかかる初期費用への抵抗が減り、長期的な利益を得ることができるようになります。また、ドキュメント作成の作業を容易にすることで、先行コストを削減することができます。

----

### ケーススタディ Google Wiki

Googleがもっと小さくてスリムだった頃、テクニカルライターはほとんどいませんでした。情報を共有する最も簡単な方法は、独自の社内Wiki（GooWiki）でした。最初は、これは合理的なアプローチに思えました。すべてのエンジニアが単一のドキュメントセットを共有し、必要に応じて更新することができたのです。

しかし、Googleの規模が大きくなるにつれ、wikiスタイルのアプローチの問題点が明らかになりました。文書の真の所有者がいないため、多くの文書が古くなってしまった(*3)。 新しい文書を追加するプロセスがないため、重複する文書や文書セットが出てきてしまった。GooWikiはフラットな名前空間を持っていたため、人々はドキュメントセットに階層を適用することが苦手だった。ある時点では、本番環境であるBorgのセットアップに関するドキュメントが7～10個（数え方による）ありましたが、そのうちのいくつかは維持されているように見えましたし、ほとんどは特定のチームに特定の権限や前提条件を与えたものでした。

GooWikiのもう一つの問題は、時間の経過とともに明らかになりました：ドキュメントを修正できる人々は、それらを使用する人々ではありませんでした。新しいユーザが悪いドキュメントを発見しても、そのドキュメントが間違っていることを確認できないか、エラーを報告する簡単な方法がありませんでした。彼らは何かが間違っていることを知っていたが（ドキュメントが機能しなかったので）、それを「修正」することができなかった。逆に言えば、ドキュメントを直すのに最も適した人たちは、ドキュメントが書かれた後にそれを参照する必要がないことが多かったのです。Googleが成長するにつれ、ドキュメントの質が非常に悪くなり、毎年行われる開発者アンケートでは、ドキュメントの質がGoogleの開発者の不満の第1位になっていました。

この状況を改善するには、重要なドキュメントを、コードの変更を追跡するために使われていたのと同じ種類のソースコントロールの下に移動させる必要があった。ドキュメントには所有者がいて、ソースツリー内の正規の位置が決められ、バグを特定して修正するためのプロセスが導入され、ドキュメントは劇的に改善されていった。さらに、ドキュメントの書き方、メンテナンスの仕方が、コードの書き方、メンテナンスの仕方と同じになってきた。ドキュメントのエラーは、バグトラッキングソフトウェアで報告することができる。ドキュメントの変更は、既存のコードレビュープロセスを使って行うことができました。最終的には、エンジニアが自分でドキュメントを修正したり、テクニカルライター（オーナーであることが多い）に変更を伝えたりするようになりました。

ドキュメントをソースコントロールに移行することは、当初、多くの議論を呼びました。多くのエンジニアは、情報の自由の砦であるGooWikiを廃止することで、ドキュメントに対するハードル（レビューの必要性、ドキュメントのオーナーの必要性など）が高くなり、品質が低下すると確信していました。しかし、そんなことはありませんでした。ドキュメントの質が向上したのです。

ドキュメントの共通フォーマット言語としてMarkdownが導入されたことで、HTMLやCSSの専門知識がなくても、エンジニアがドキュメントの編集方法を理解しやすくなったことも功を奏した。やがてGoogleは、コード内にドキュメントを埋め込むための独自のフレームワーク「g3doc」を導入しました。このフレームワークでは、エンジニアの開発環境の中にソースコードと一緒にドキュメントが存在するため、ドキュメントの質がさらに向上しました。このフレームワークにより、エンジニアの開発環境の中でソースコードとドキュメントが並存するようになり、エンジニアはコードとそれに関連するドキュメントを同じ変更で更新することができるようになりました（これは今でも採用率の向上を目指しています）。

大きな違いは、ドキュメントのメンテナンスがコードのメンテナンスと同じような感覚で行えるようになったことです。エンジニアはバグを報告し、チェンジリストでドキュメントに変更を加え、変更内容を専門家のレビューに回すなどの作業を行います。新しいワークフローを作るのではなく、既存の開発者のワークフローを活用できることが大きなメリットでした。

----

## 聴衆を知る

エンジニアがドキュメントを書くときに陥りがちな間違いのひとつに、自分のためだけに書いてしまうというものがあります。それは当然のことで、自分のために書くことに価値がないわけではありません。なぜなら、数年後にこのコードを見て、かつて自分が言っていたことを理解する必要があるかもしれないからです。数年後にこのコードを見て、かつての意味を理解する必要があるかもしれませんし、あなたの文書を読む人とほぼ同じスキルセットを持っているかもしれません。しかし、自分のためだけに書いていると、ある種の仮定をしてしまうことになります。あなたのドキュメントが非常に幅広い読者（エンジニアリング全員、外部の開発者）に読まれる可能性があることを考えると、たとえ数人の読者がいなくなったとしても、それは大きなコストになります。組織が大きくなると、ドキュメントのミスが目立つようになり、あなたの仮定が当てはまらなくなることがよくあります。

そうではなく、書き始める前に、（正式にも非公式にも）ドキュメントが満足させる必要のあるオーディエンス（複数可）を特定する必要があります。設計書は、意思決定者を説得する必要があるかもしれません。チュートリアルでは、コードベースを全く知らない人に非常に明確な指示を与える必要があります。APIでは、専門家であれ初心者であれ、そのAPIのすべてのユーザーに完全で正確なリファレンス情報を提供する必要があるかもしれません。常に主要な読者を特定し、その読者に向けて書くようにしましょう。

良いドキュメントは、洗練されていなくても、"完璧 "でなくても良い。エンジニアがドキュメントを書くときに犯す間違いの一つは、自分たちはもっと優れた文章を書く必要があると思い込んでいることだ。そのような基準では、ほとんどのソフトウェアエンジニアは文章を書きません。エンジニアとして必要なテストやその他のプロセスと同じように、文章を書くことについて考えてみてください。聴衆に向かって、聴衆が期待する声とスタイルで書くのです。読むことができれば、書くことができます。聴衆は、あなたがかつて立っていた場所に立っていることを忘れてはいけません。ですから、優れたライターである必要はありません。あなたのような人が、今のあなたと同じようにドメインに精通していればいいのです。(そして、地面に杭を打ちさえすれば、時間をかけてこのドキュメントを改善することができます)。

### オーディエンスの種類

これまで、読者に適したスキルレベルや知識を持った人に向けて文章を書くべきだと指摘してきました。しかし、あなたの読者はいったい誰なのでしょうか？おそらく、次のような基準に基づいて、複数の読者が存在するのではないでしょうか。

- 経験レベル（熟練したプログラマーや、その言語に精通していないジュニアエンジニアなど
- ドメイン知識（チームメンバー、またはAPIエンドポイントにしか詳しくない組織内の他のエンジニア）。
- 目的（特定のタスクを実行するためにAPIを必要とし、その情報を素早く見つける必要があるエンドユーザー、または誰にも維持される必要がないことを望む、特に毛深い実装の根幹を担当するソフトウェアの専門家）。

対象者によってライティングスタイルが異なる場合もありますが、ほとんどの場合、異なる対象者グループにできるだけ広く適用できる方法で書くことがコツです。多くの場合、複雑なトピックを、専門家と初心者の両方に説明する必要があります。ドメイン知識を持つ専門家向けに書くと、手抜きはできても、初心者を混乱させることになります。逆に、初心者にすべてを詳細に説明すると、専門家を悩ませることになるでしょう。

もちろん、このような文書を書くことはバランスのとれた行為であり、特効薬はありませんが、私たちが発見した一つのことは、文書を短くすることが有効だということです。複雑なテーマをよく知らない人にも説明できるように、説明的に書きますが、専門家を失望させたり、困らせたりしないようにしましょう。短い文書を書くためには、長い文書を書いて（すべての情報を書き出して）から、可能な限り重複した情報を削除するエディットパスを行う必要があることがよくあります。これは退屈に聞こえるかもしれませんが、この費用はドキュメントの読者全員に分散されることを覚えておいてください。かつてパスカルが言ったように、「もし時間があれば、もっと短い手紙を書いていただろう」。ドキュメントを短く、明確にすることで、専門家と初心者の両方を満足させることができます。

もうひとつの重要な違いは、ユーザーがどのようにしてドキュメントに出会うかということです。

- 求道者とは、自分が欲しいものを知っていて、自分が見ているものがその条件に合っているかどうかを知りたいと思っているエンジニアです。この層のための重要な教育的工夫は、一貫性です。このグループに向けてリファレンス・ドキュメントを書く場合、例えばコード・ファイルの中では、読者がリファレンスに素早く目を通し、探しているものが見つかるかどうかを確認できるように、コメントを同じようなフォーマットに沿って書きたいと思うでしょう。
- つまずきやすい人は、自分が何を求めているのか正確にはわからないかもしれません。漠然としたアイデアしか持っていないかもしれません。このようなお客様には、わかりやすさが重要です。見ているコードの目的を説明する概要や紹介文（ファイルの先頭など）を用意しましょう。また、あるドキュメントが対象者にとって適切でない場合を特定することも有効です。Googleのドキュメントの多くは、"TL;DR: If you are not interested in C++ compilers at Google, you can stop reading now. "のような「TL;DR文」で始まります。

最後に、顧客（例：APIのユーザー）と提供者（例：プロジェクトチームのメンバー）を区別することも重要です。可能な限り、一方を対象とした文書と他方を対象とした文書は分けて考えるべきです。実装の詳細は、チームメンバーがメンテナンスのために重要な情報であり、エンドユーザーはそのような情報を読む必要はありません。しばしば、エンジニアは自分が公開しているライブラリのリファレンスAPIの中で設計上の決定を示すことがあります。このような理由は、特定の文書（設計文書）か、せいぜいインターフェイスの後ろに隠されたコードの実装の詳細に記載するのが適切です。

## ドキュメントの種類

エンジニアは、仕事の一環として、設計書、コードコメント、ハウツー文書、プロジェクトページなど、さまざまな種類のドキュメントを書きます。これらはすべて「ドキュメント」として扱われます。しかし、それぞれの種類を知り、種類を混在させないことが重要です。ドキュメントは一般的に、単一の目的を持ち、それを貫くべきです。APIが1つのことをうまくやるべきであるように、1つのドキュメントで複数のことをやろうとするのは避けましょう。代わりに、それらの部分をより論理的に分割します。

ソフトウェアエンジニアが書く必要のあるドキュメントには、大きく分けていくつかの種類があります。

- コードコメントを含むリファレンスドキュメント
- 設計書
- チュートリアル
- コンセプト・ドキュメント
- ランディングページ

Googleの初期には、大量のリンク（その多くは壊れていたり、時代遅れだったりします）、システムがどのように機能するかについての概念的な情報、APIリファレンスなどが散りばめられた、一枚岩のようなwikiページを持つチームが一般的でした。そのようなドキュメントは、単一の目的を果たさないため、失敗します（また、誰も読まないほど長くなります。有名なwikiページでは、数十の画面をスクロールしていました）。もし、そのページに何かを追加することに意味がないのであれば、その目的のために別の文書を探すか、あるいは作成することをお勧めします。

### リファレンスドキュメント

リファレンスドキュメントは、エンジニアが書く必要のある最も一般的なものです。リファレンスドキュメントとは、コードベース内のコードの使用方法を文書化したものを意味します。コードコメントは、エンジニアが維持しなければならない最も一般的なリファレンスドキュメントの形態です。このコメントは2つの基本的な陣営に分けられます。APIコメントと実装コメントです。この2つのコメントの違いを覚えておいてください。APIコメントでは、実装の詳細や設計上の決定事項を議論する必要はなく、ユーザーが著者ほどAPIに精通していることを前提とすることはできません。一方、実装コメントは読み手のドメイン知識をより多く想定することができますが、想定しすぎることには注意が必要です。

ほとんどのリファレンスドキュメントは、コードとは別のドキュメントとして提供されている場合でも、コードベース自体のコメントから生成されています。(当然のことですが、リファレンスドキュメントはできる限りシングルソースであるべきです)。JavaやPythonなどの一部の言語では、このリファレンスドキュメントの生成を容易にするために、特定のコメントフレームワーク（Javadoc、PyDoc、GoDoc）が用意されています。C++のような他の言語では、標準的な「参照ドキュメント」の実装はありませんが、C++はAPIの表面（ヘッダーまたは.hファイル）と実装（.ccファイル）を分離しているので、ヘッダーファイルはC++ APIをドキュメント化するための自然な場所であることが多いです。

Googleはこのようなアプローチをとっています。C++のAPIは、そのリファレンスドキュメントがヘッダーファイル内に存在することが望ましいと考えています。その他のリファレンスドキュメントも、Java、Python、Goのソースコードに直接埋め込まれています。Googleのコード検索ブラウザ（第17章参照）は非常に堅牢なので、別個に生成されたリファレンスドキュメントを提供するメリットはほとんどありません。コード検索のユーザーは、コードを簡単に検索できるだけでなく、通常、そのコードのオリジナルの定義を一番上の結果として見つけることができます。また、コードの定義と一緒にドキュメントがあることで、ドキュメントの発見やメンテナンスが容易になります。

ドキュメントが充実したAPIには、コードコメントが欠かせないことは周知の事実です。しかし、「良い」コメントとは一体何なのでしょうか？この章の前半で、リファレンス・ドキュメントの2つの主要な読者を特定しました：求める人とつまずく人です。求める人は自分が何を求めているかを知っていますが、つまずく人は知りません。求める人にとっての重要なポイントは、一貫してコメントされたコードベースであり、APIを素早くスキャンして探しているものを見つけることができます。つまずきやすい人にとっては、APIの目的を明確に示すことが重要で、多くの場合、ファイルヘッダの先頭に書かれている。この後のサブセクションでは、いくつかのコードコメントについて説明します。以下のコードコメントのガイドラインはC++に適用されていますが、Googleでは他の言語についても同様のルールが設けられています。

#### ファイルコメント

Googleでは、ほぼすべてのコードファイルにファイルコメントを記述しなければなりません。(ユーティリティー関数を1つだけ含むヘッダーファイルなどは、この基準から外れる場合があります)。ファイルコメントは、次のような形式のヘッダーで始めなければなりません。

```C
// -----------------------------------------------------------------------------
// str_cat.h
// -----------------------------------------------------------------------------
//
// This header file contains functions for efficiently concatenating and appending
// strings: StrCat() and StrAppend(). Most of the work within these routines is
// actually handled through use of a special AlphaNum type, which was designed
// to be used as a parameter type that efficiently manages conversion to
// strings and avoids copies in the above operations.
...
```

一般的に、ファイルコメントは、読んでいるコードに何が含まれているかの概要から始めるべきです。また、コードの主な使用例や対象となる読者（先の例では、文字列を連結したいと考えている開発者）を特定する必要があります。最初の1、2段落で簡潔に説明できないAPIは、通常、よく考えられていないAPIの兆候である。そのような場合は、APIを別のコンポーネントに分割することを検討してください。

#### クラスのコメント

最近のプログラミング言語は、ほとんどがオブジェクト指向です。そのため、クラスコメントはコードベースで使用する API の「オブジェクト」を定義するために重要です。Google のすべてのパブリッククラス (および構造体) には、クラス/構造体、そのクラスの重要なメソッド、そしてクラスの目的を説明するクラスコメントを含める必要があります。一般的に、クラスコメントはそのオブジェクトの側面を強調したドキュメントで「名詞化」されるべきです。つまり、「Fooクラスはx, y, zを含み、Barを行うことができ、次のBazの側面を持っています」というように言います。
クラスのコメントは、一般的に次のような形式のコメントで始まるべきです。

```C
// -----------------------------------------------------------------------------
// AlphaNum
// -----------------------------------------------------------------------------
//
// The AlphaNum class acts as the main parameter type for StrCat() and
// StrAppend(), providing efficient conversion of numeric, boolean, and
// hexadecimal values (through the Hex type) into strings.
```

#### 関数コメント

Google のすべてのフリー関数、またはクラスのパブリックメソッドには、その関数が何をするのかを説明する関数コメントが必要です。関数コメントは、関数が何をするのか、何を返すのかを説明する指示動詞で始まり、能動的に使用することを強調しなければなりません。

関数コメントは通常、次のような形式のコメントで始まるべきです。

```C
// StrCat()
//
// Merges the given strings or numbers, using no delimiter(s),
// returning the merged result as a string.
...
```

関数のコメントを宣言的な動詞で始めることで、ヘッダーファイル全体の一貫性が確保されることに注意してください。探索者はAPIを素早くスキャンし、動詞だけを読んで、その関数が適切かどうかを判断することができます。"Merges, Deletes, Creates "といった具合に。

一部のドキュメントスタイル（および一部のドキュメントジェネレータ）では、関数のコメントに "Returns: "や "Throws: "などの様々な形式の定型文を必要としますが、Googleではそれらが必要であるとは考えていません。このような情報は、人工的なセクションの境界線で分割されていない1つの散文コメントで提示する方が、しばしば明確になります。

```C
// Creates a new record for a customer with the given name and address,
// and returns the record ID, or throws `DuplicateEntryError` if a
// record with that name already exists.
int AddCustomer(string name, string address);
```

ポストコンディション、パラメータ、戻り値、例外的なケースが、互いに独立していないため、自然に一緒に（この場合は1つの文に）文書化されていることに注目してください。明示的なボイラープレートのセクションを追加すると、コメントはより冗長で反復的になりますが、明確にはなりません（そして、間違いなく明確ではありません）。

### デザインドキュメント

Googleのほとんどのチームでは、大きなプロジェクトに着手する前に、承認された設計書が必要となります。ソフトウェアエンジニアは通常、チームで承認された特定の設計書テンプレートを使用して設計書案を作成します。このような文書は共同作業を前提としているため、優れたコラボレーションツールを備えたGoogle Docsで共有されることが多い。チームによっては、このような設計書を特定のチームミーティングで議論し、設計の細かい点を専門家が議論したり批評したりすることを要求する場合もあります。このような設計上の議論は、コードが書かれる前のコードレビューのような役割を果たしている面もあります。

設計書の作成は、エンジニアが新しいシステムを導入する前に行う最初のプロセスの一つであるため、様々な懸念事項を確実にカバーするのに便利な場所でもあります。Googleの典型的な設計書のテンプレートでは、セキュリティへの影響、国際化、ストレージ要件やプライバシーへの配慮など、設計の側面を考慮するようエンジニアに求めています。ほとんどの場合、そのような設計文書の部分は、その領域の専門家によってレビューされます。

優れた設計文書は、設計の目標とその実装戦略をカバーし、重要な設計上の決定事項を、それぞれのトレードオフに重点を置いて提案するものです。最良の設計文書は、設計目標を提案し、代替設計をカバーし、それらの長所と短所を示します。

一度承認された優れた設計文書は、歴史的な記録としてだけでなく、プロジェクトがその目標を無事に達成したかどうかを測る指標としても機能します。ほとんどのチームでは、デザインドキュメントをチームドキュメント内の適切な場所に保管し、後から見直せるようにしています。製品が発売される前に設計文書を見直すことは、設計文書が書かれたときの目標が発売時の目標のままであることを確認するために、しばしば有用です（もしそうでなければ、文書または製品のいずれかを適宜調整することができます）。

### チュートリアル

ソフトウェアエンジニアは、新しいチームに参加すると、できるだけ早く仕事に慣れたいと思うものです。新しいプロジェクトのセットアップを説明するチュートリアルは非常に重要です。「Hello World」は、チームメンバー全員が正しいスタートを切るための最良の方法のひとつです。これはコードだけでなく、ドキュメントにも言えることです。ほとんどのプロジェクトには、何も仮定せず、エンジニアに「実際に」何かを起こさせるための「Hello World」ドキュメントがふさわしい。

多くの場合、チュートリアルを書くのに最適なタイミングは、まだチュートリアルが存在しない場合は、チームに初めて参加したときです。(また、既存のチュートリアルのバグを見つけるのにも最適なタイミングです)。メモ帳などを用意して、ドメインの知識や特別な設定の制約がないと仮定して、その過程で必要なことをすべて書き出してみましょう。終わった後には、その過程でどのような間違いをしたのか、またその理由がわかるでしょうから、手順を編集してより合理的なチュートリアルを作ることができます。重要なのは、その過程で必要なことをすべて書くことです。特定の設定、権限、ドメインの知識などを前提としないようにしてください。もし、他の設定を前提とする必要がある場合は、前提条件としてチュートリアルの最初に明示してください。

ほとんどのチュートリアルでは、いくつかのステップを順番に実行する必要があります。そのような場合には、それらのステップに明確な番号を付けます。チュートリアルの焦点がユーザーに置かれている場合（例えば、外部の開発者向けドキュメントの場合）、ユーザーが行う必要のある各アクションに番号を付けます。ユーザーの行動に応じてシステムが取る行動には番号を振らないでください。このような場合、すべてのステップに明確に番号を付けることは非常に重要です。例えば、ユーザー名を適切に認証するように伝えるのを忘れたために、ステップ4でエラーになることほど腹立たしいことはありません。

#### 例 悪いチュートリアル

1. 私たちのサーバー（http://example.com）からパッケージをダウンロードします。
2. シェルスクリプトをホームディレクトリにコピーする
3. シェルスクリプトを実行する
4. foobarシステムが認証システムと通信します。
5. 認証されると、foobarは "baz "という名前の新しいデータベースを起動します。
6. コマンド・ラインでSQLコマンドを実行して、"baz "をテストする。
7. タイプします。CREATE DATABASE my_foobar_db;


前述の手順では、ステップ4と5はサーバー側で行われます。ユーザーが何かをする必要があるかどうかは不明ですが、ユーザーは何もしませんので、これらの副作用はステップ3の一部として言及することができます。同様に、ステップ6とステップ7が異なるものであるかどうかも不明です。(アトミックなユーザーの操作をすべて1つのステップにまとめ、ユーザーが各ステップで何かをする必要があるとわかるようにします。また、チュートリアルでユーザーに見える入力や出力がある場合は、それを別の行に表記してください（しばしば、等幅の太字フォントの規則を使用します）。


#### 例 悪いチュートリアルを良くしたもの

1. http://example.com のサーバーからパッケージをダウンロードします。
```
        $ curl -I http://example.com
```
2. シェルスクリプトをホームディレクトリにコピーします。
```
        $ cp foobar.sh ~
```
3. ホームディレクトリーでシェルスクリプトを実行します。
```
        $ cd ~; foobar.sh
```
 foobarシステムは、まず認証システムと通信する。認証されると、foobarは "baz "という名前の新しいデータベースを起動し、入力シェルを開きます。
4. コマンド・ラインでSQLコマンドを実行して、"baz "をテストする。
```
        baz:$ CREATE DATABASE my_foobar_db;
```

それぞれのステップで、どのようにユーザーが介入する必要があるかを説明します。もし、そのチュートリアルが他の側面に焦点を当てていたとしたら（例えば、「サーバーの生活」についてのドキュメント）、その焦点の観点（サーバーが何をするか）から、これらのステップに番号を付けてください。

### 概念的なドキュメント

コードの中には、リファレンス・ドキュメントを読むだけでは得られない、より深い説明や洞察を必要とするものがあります。そのような場合には、APIやシステムの概要を説明する概念的なドキュメントが必要になります。概念的なドキュメントの例としては、人気のあるAPIのライブラリの概要や、サーバー内のデータのライフサイクルを説明したドキュメントなどがあります。ほとんどの場合、概念的なドキュメントは、リファレンス・ドキュメント・セットを置き換えるものではなく、補強するものです。そのため、いくつかの情報が重複してしまうこともありますが、目的は明確にすることです。このような場合、概念的な文書ですべてのエッジケースをカバーする必要はありません（ただし、リファレンスはそれらのケースを忠実にカバーする必要があります）。この場合、明確さのために多少の正確さを犠牲にしても構いません。概念的な文書の主なポイントは、理解を与えることです。

「コンセプト・ドキュメントは、ドキュメントの中でも最も書くのが難しい形態です。そのため、ソフトウェアエンジニアのツールボックスの中で、最も軽視されているドキュメントのタイプです。コンセプト・ドキュメントを書く際にエンジニアが直面する問題の1つは、ソースコードに直接埋め込むことができない場合が多いことだ。APIの中には、APIの表面積が比較的広いものもあり、そのような場合には、APIの「概念的」な説明のために、ファイルのコメントが適切な場所となるかもしれない。しかし、多くの場合、APIは他のAPIやモジュールと連携して動作します。そのような複雑な動作を文書化するための唯一の論理的な場所は、別の概念的な文書である。コメントがドキュメントのユニットテストだとすれば、概念的なドキュメントは統合テストにあたります。

APIが適切にスコープされている場合でも、別の概念的なドキュメントを提供することが意味を持つことがよくあります。例えば、AbseilのStrFormatライブラリは、APIの熟練ユーザが理解すべき様々な概念をカバーしています。そのような場合には、社内外を問わず、フォーマットのコンセプト文書を提供しています。

コンセプト・ドキュメントは、専門家と初心者の両方を含む幅広い層に役立つものである必要があります。さらに、わかりやすさを重視する必要があるため、完全性（参考資料として最適なもの）や（場合によっては）厳密な正確性を犠牲にする必要があることもあります。これは、概念的な文書が意図的に不正確であるべきだということではなく、一般的な使用法に焦点を当て、稀な使用法や副作用については参考文献に任せるべきだということです。

### ランディングページ

ほとんどのエンジニアはチームに所属しており、ほとんどのチームは社内のイントラネットのどこかに「チームページ」を持っています。典型的なランディングページには、いくつかの興味深いリンク、時には「まずこれを読んでください！」と題されたいくつかのドキュメント、そしてチームとその顧客のための情報が含まれていることがありますが、これらのサイトは少し混乱しています。このようなドキュメントは、最初は便利ですが、すぐに災害になります。メンテナンスが非常に面倒になるため、最終的には時代遅れになり、勇気のある人や必死になっている人だけが修正することになるでしょう。

ランディングページの目的を明確にした上で、より詳細な情報を提供するために他のページへのリンクを貼ることです。ランディングページのどこかが交通整理以上の役割を果たしているとしたら、それはその役割を果たしていないということです。もし、別のセットアップドキュメントがある場合は、ランディングページから別のドキュメントとしてリンクしてください。ランディングページにリンクが多すぎる場合（ページは複数の画面をスクロールさせるべきではありません）、タクソノミー別にページを分割することを検討してください。

設定が不十分なランディングページの多くは、2つの異なる目的を持っています。つまり、製品やAPIのユーザーである人にとっての「入口」ページであったり、チームのホームページであったりします。1つのページで2つの役割を持たせてはいけません。混乱してしまいます。メインのランディングページとは別に、内部のページとして「チームページ」を作りましょう。チームが知りたいことと、APIを利用する顧客が知りたいことは全く異なることが多いからです。

## ドキュメントレビュー

Google では、すべてのコードはレビューされる必要があり、Google のコードレビュープロセスはよく理解され、受け入れられています。一般的に、ドキュメントにもレビューが必要です（ただし、これはあまり一般的には受け入れられていません）。ドキュメントが機能するかどうかを「テスト」したい場合は、通常、他の人にレビューしてもらうべきです。

技術文書には3つの異なるタイプのレビューがあり、それぞれが異なる側面を強調しています。

- 正確さを期すためのテクニカルレビュー。このレビューは、通常、対象分野の専門家（多くの場合、チームの他のメンバー）が行います。多くの場合、これはコードレビューの一環として行われます。
- オーディエンスレビュー：分かりやすさのために行います。これは通常、その分野に精通していない人が行います。あなたのチームの新入社員や、あなたのAPIの顧客などが該当します。
- 一貫性を保つためのライティング・レビュー。これは、テクニカルライターやボランティアが行うことが多い。

もちろん、これらの境界線は曖昧なこともありますが、もしあなたのドキュメントが注目を集めていたり、外部に出版される可能性がある場合は、より多くの種類のレビューを受けるようにしたいと思うでしょう。(たとえその場限りのレビューであっても、前述のようなレビューがあれば、どんなドキュメントにもメリットがあるはずです。とはいえ、1人のレビュアーにレビューしてもらうだけでも、誰にもレビューしてもらえないよりは好ましいものです。

重要なのは、ドキュメントがエンジニアリングのワークフローに結びついていれば、時間の経過とともに改善されることが多いということです。Googleでは、ほとんどのドキュメントが暗黙のうちにオーディエンスレビューを経ています。なぜなら、オーディエンスはある時点でそれらのドキュメントを使用し、うまく機能していないときには（バグやその他の形式のフィードバックによって）あなたに知らせてくれるからです。

----

### ケーススタディ デベロッパーガイドライブラリ

前述したように、ほとんどの（ほぼすべての）エンジニアリング文書が共有Wikiに収められていることには、重要な文書の所有者が少ないこと、競合する文書があること、古い情報があること、文書のバグや問題を提出するのが難しいことなどの問題がありました。しかし、この問題は一部のドキュメントでは見られませんでした。Google C++のスタイルガイドは、それを管理する選ばれたシニアエンジニアのグループ（スタイルアービター）によって所有されていました。特定の人が気にかけていたからこそ、そのドキュメントは良好な状態に保たれていたのです。彼らは暗黙のうちにその文書を所有していたのです。C++スタイルガイドは1つしかありません。

前述したように、ソースコード内に直接置かれたドキュメントは、正規のドキュメントの確立を促進する一つの方法です。ドキュメントがソースコードと一緒に置かれていれば、通常は最も適用可能であるはずです（願わくば）。Googleでは、各APIには通常g3docディレクトリがあり、そこにドキュメントが置かれています（Markdownファイルとして書かれており、Code Searchブラウザで読むことができます）。ドキュメントがソースコードと一緒に存在することは、事実上の所有権を確立するだけでなく、ドキュメントをより完全にコードの「一部」のように見せることができます。

しかし、ドキュメントセットの中には、ソースコードの中に論理的に存在できないものもあります。例えば、Googlerのための「C++開発者ガイド」は、ソースコードの中に明らかに存在する場所がありません。人々がそのような情報を探すためのマスター「C++」ディレクトリはありません。このケース（およびAPIの境界を越えた他のケース）では、独立したドキュメントセットを独自のデポに作成することが有用になりました。これらのドキュメントの多くは、関連する既存のドキュメントをまとめて、共通のナビゲーションとルックアンドフィールを持つ共通のセットにしました。このようなドキュメントは「開発者ガイド」と呼ばれ、コードベースのコードと同様に、特定のドキュメントデポでソース管理されていました。このデポは、APIではなくトピックごとに構成されていました。テクニカルライターは、APIの境界を越えてトピックを説明するのが得意なので、しばしばこれらの開発者ガイドを管理していました。

時が経つにつれ、これらの開発者ガイドは正式なものとなりました。競合する文書や補足的な文書を書いたユーザーは、正規の文書セットが確立された後、その文書を追加し、競合する文書を廃止することに従順になりました。最終的に、C++スタイルガイドは、より大きな「C++開発者ガイド」の一部となりました。ドキュメントセットがより包括的でより権威あるものになるにつれ、その品質も向上しました。エンジニアは、誰かがこれらのドキュメントを管理していることを知っているので、バグを記録するようになりました。ドキュメントはソースコントロールの下、適切なオーナーの下で管理されていたため、エンジニアは変更リストをテクニカルライターに直接送るようになりました。

go/links（第3章参照）の導入により、ほとんどのドキュメントは、どのトピックにおいても、より簡単に正典としての地位を確立することができるようになりました。例えば、C++開発者ガイドは「go/cpp」で確立されました。内部検索、go/links、そして複数のドキュメントを共通のドキュメントセットに統合することで、このような正規のドキュメントセットは、時間の経過とともに、より権威のある強固なものになっていきました。

----

## ドキュメンテーション哲学

注意：以下のセクションは、「Googleのやり方」というよりも、テクニカルライティングのベストプラクティス（および個人的な意見）をまとめたものです。ソフトウェアエンジニアが完全に理解するのは任意ですが、これらのコンセプトを理解することで、技術情報をより簡単に書くことができるようになるでしょう。

### WHO、WHAT、WHEN、WHERE、そしてWHY

ほとんどの技術文書は、「どのように」という質問に答えるものです。これはどのように動作しますか？このAPIへのプログラミングはどうすればいいですか？このサーバーを設定するにはどうすればいいですか？その結果、ソフトウェアエンジニアは、ドキュメントの「HOW」にすぐに飛びつき、それに付随する他の質問、つまり「WHO」「WHAT」「WHEN」「WHERE」「WHY」を無視する傾向があります。確かに、どの質問も一般的には「方法」と同じくらい重要ではありません。しかし、技術文書の適切なフレームワークがなければ、文書は混乱してしまいます。ドキュメントの最初の2段落で、他の質問に答えるようにしましょう。

- WHOは前に議論されました：それがオーディエンスです。しかし、時には、文書の中で明確にオーディエンスを呼び、演説する必要もあります。例を挙げると "This document is for new engineers on the Secret Wizard project."
- WHATはこのドキュメントの目的を明らかにしています。"This document is a tutorial designed to start a Frobber server in a test environment." 単にWHATを書くことで、ドキュメントを適切に構成することができる場合があります。WHATに当てはまらない情報を追加し始めると、その情報を別のドキュメントに移したくなるかもしれません。
- WHENは、このドキュメントがいつ作成、レビュー、または更新されたかを示すものです。ソースコードのドキュメントには暗黙のうちにこの日付が記載されていますし、他の出版スキームでもこれを自動化しているものがあります。しかし、そうでない場合は、ドキュメントが書かれた（または最後に改訂された）日付を、ドキュメント自体に必ず記載してください。
- WHEREは暗黙の了解であることが多いのですが、ドキュメントをどこに置くかを決めます。通常、ドキュメントはある種のバージョン管理下に置かれるべきであり、理想的にはドキュメントのソースコードと一緒に置かれるべきです。しかし、目的によっては他のフォーマットも有効です。Googleでは、Google Docsを使って、特にデザイン上の問題について簡単にコラボレーションを行うことができます。しかし、共有されたドキュメントは、ある時点で、議論のためのものではなく、安定した歴史的記録としての役割を果たすようになります。そのような場合は、所有権、バージョン管理、責任の所在が明確な、より永続的な場所に移します。
- WHYは、そのドキュメントの目的を設定します。読んだ人がそのドキュメントから何を得られるかを要約します。経験則としては、文書の導入部でWHYを設定するのが良いでしょう。要約を書くときには、当初の期待に応えられたかどうかを検証します（そして適宜修正します）。

 ### 始まり、中間、そして終わり

 すべてのドキュメント、いや、ドキュメントのすべての部分には、始まり、中間、そして終わりがあります。驚くほど馬鹿げているように聞こえるかもしれませんが、ほとんどの文書には最低でもこの3つのセクションがあるはずです。セクションが1つしかない文書は、言うべきことが1つしかありませんし、言うべきことが1つしかない文書はほとんどありません。セクションを追加することを恐れてはいけません。セクションは、流れを論理的に分割し、読者にドキュメントがカバーする内容のロードマップを提供します。

どんなにシンプルな文書でも、言いたいことは1つだけではありません。「C++ Tips of the Week（今週のC++ Tips）」は、これまでは非常に短く、1つの小さなアドバイスに焦点を当てていました。しかし、ここでもセクションがあると便利です。伝統的には、最初のセクションで問題点を指摘し、中間セクションで推奨される解決策を説明し、結論で要点をまとめます。1つのセクションで構成されていたら、読者の中には重要なポイントを見極めるのが難しい人もいるでしょう。

多くのエンジニアは冗長性を嫌うが、それには理由がある。しかし、ドキュメントにおいては、冗長性が役に立つこともあります。文章の壁の中に埋もれた重要なポイントは、覚えておくのも、引き出すのも難しいものです。一方で、そのポイントを早い段階で目立つ場所に配置すると、後に提供される文脈が失われてしまいます。通常、解決策としては、冒頭の段落でポイントを紹介して要約し、セクションの残りの部分でより詳細に主張することができます。この場合、冗長性を持たせることで、読者は述べられていることの重要性を理解することができます。

### 良いドキュメントのパラメータ

優れたドキュメントには、通常、完全性、正確性、明確性の3つの側面があります。例えば、ドキュメントをより「完全」にしようとすると、わかりやすさが損なわれることがあります。例えば、APIのすべての使用例を文書化しようとすると、理解しがたい混乱を招くことになります。プログラミング言語の場合、すべてのケースで完全に正確であること（そして起こりうるすべての副作用を文書化すること）は、わかりやすさに影響します。例えば、概念的な文書では、稀な副作用を無視することにするかもしれません。なぜなら、その文書の目的は、APIの使用方法を誰かに知ってもらうことであって、意図されたすべての動作の独断的な概要を提供することではないからです。

いずれの場合も、「良いドキュメント」とは、「意図した仕事をしているドキュメント」と定義されます。そのため、1つのドキュメントで複数の仕事をすることはほとんどありません。それぞれのドキュメント（そして、それぞれのドキュメントタイプ）について、その焦点を決定し、適切にライティングを調整してください。概念的なドキュメントを書く場合 APIのすべての部分をカバーする必要はないでしょう。リファレンスの作成？おそらく完全なものにしたいが、多少の明確さを犠牲にする必要があるだろう。ランディングページの作成？構成を重視し、議論は最小限にとどめます。これらすべてが品質につながりますが、これを正確に測定するのは難しいことです。

では、どうすればドキュメントの質を高めることができるのでしょうか。聴衆のニーズに集中することです。多くの場合、少ない方が良いのです。例えば、エンジニアが犯しがちなミスは、設計上の決定事項や実装の詳細をAPIドキュメントに追加してしまうことです。うまく設計されたAPIでは、インターフェースと実装を分離するのが理想的であるように、APIドキュメントでは設計上の決定事項を議論するのは避けるべきだ。ユーザーはこのような情報を知る必要はありません。代わりに、それらの決定事項は、その目的のために特別なドキュメント（通常は設計ドキュメント）に記載する。

### Deprecating Documents

Just like old code can cause problems, so can old documents. Over time, documents become stale, obsolete, or (often) abandoned. Try as much as possible to avoid abandoned documents, but when a document no longer serves any purpose, either remove it or identify it as obsolete (and, if available, indicate where to go for new information). Even for unowned documents, someone adding a note that “This no longer works!” is more helpful than saying nothing and leaving something that seems authoritative but no longer works.
At Google, we often attach “freshness dates” to documentation. Such documents note the last time a document was reviewed, and metadata in the documentation set will send email reminders when the document hasn’t been touched in, for example, three months. Such freshness dates, as shown in the following example --- and tracking your documents as bugs --- can help make a documentation set easier to maintain over time, which is the main concern for a document:

```
<!--*
# Document freshness: For more information, see go/fresh-source.
freshness: { owner: `username` reviewed: '2019-02-27' }
*-->
```

Users who own such a document have an incentive to keep that freshness date current (and if the document is under source control, that requires a code review). As a result, it’s a low-cost means to ensure that a document is looked over from time to time. At Google, we found that including the owner of a document in this freshness date within the document itself with a byline of “Last reviewed by...” led to increased adoption as well.

## When Do You Need Technical Writers?

When Google was young and growing, there weren’t enough technical writers in software engineering. (That’s still the case.) Those projects deemed important tended to receive a technical writer, regardless of whether that team really needed one. The idea was that the writer could relieve the team of some of the burden of writing and maintaining documents and (theoretically) allow the important project to achieve greater velocity. This turned out to be a bad assumption.
We learned that most engineering teams can write documentation for themselves (their team) perfectly fine; it’s only when they are writing documents for another audience that they tend to need help because it’s difficult to write to another audience. The feedback loop within your team regarding documents is more immediate, the domain knowledge and assumptions are clearer, and the perceived needs are more obvious. Of course, a technical writer can often do a better job with grammar and organization, but supporting a single team isn’t the best use of a limited and specialized resource; it doesn’t scale. It introduced a perverse incentive: become an important project and your software engineers won’t need to write documents. Discouraging engineers from writing documents turns out to be the opposite of what you want to do.
Because they are a limited resource, technical writers should generally focus on tasks that software engineers don’t need to do as part of their normal duties. Usually, this involves writing documents that cross API boundaries. Project Foo might clearly know what documentation Project Foo needs, but it probably has a less clear idea what Project Bar needs. A technical writer is better able to stand in as a person unfamiliar with the domain. In fact, it’s one of their critical roles: to challenge the assumptions your team makes about the utility of your project. It’s one of the reasons why many, if not most, software engineering technical writers tend to focus on this specific type of API documentation.

## Conclusion

Google has made good strides in addressing documentation quality over the past decade, but to be frank, documentation at Google is not yet a first-class citizen. For comparison, engineers have gradually accepted that testing is necessary for any code change, no matter how small. As well, testing tooling is robust, varied and plugged into an engineering workflow at various points. Documentation is not ingrained at nearly the same level.
To be fair, there’s not necessarily the same need to address documentation as with testing. Tests can be made atomic (unit tests) and can follow prescribed form and function. Documents, for the most part, cannot. Tests can be automated, and schemes to automate documentation are often lacking. Documents are necessarily subjective; the quality of the document is measured not by the writer, but by the reader, and often quite asynchronously. That said, there is a recognition that documentation is important, and processes around document development are improving. In this author’s opinion, the quality of documentation at Google is better than in most software engineering shops.
To change the quality of engineering documentation, engineers --- and the entire engineering organization --- need to accept that they are both the problem and the solution. Rather than throw up their hands at the state of documentation, they need to realize that producing quality documentation is part of their job and saves them time and effort in the long run. For any piece of code that you expect to live more than a few months, the extra cycles you put in documenting that code will not only help others, it will help you maintain that code as well.


## TL;DRs

- Documentation is hugely important over time and scale.
- Documentation changes should leverage the existing developer workflow.
- Keep documents focused on one purpose.
- Write for your audience, not yourself.













-----

1 OK, you will need to maintain it and revise it occasionally.
2 English is still the primary language for most programmers, and most technical documentation for programmers relies on an understanding of English.
3 When we deprecated GooWiki, we found that around 90% of the documents had no views or updates in the previous few months.




