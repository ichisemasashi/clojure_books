# CHAPTER 9 Code Review


Written by Tom Manshreck and Caitlin Sadowski

Edited by Lisa Carey

コードレビューとは、コードベースにコードを導入する前に、そのコードを作者以外の人間がレビューするプロセスである。これは簡単な定義ですが、コードレビューのプロセスの実装は、ソフトウェア業界全体で大きく異なります。ある組織では、コードベース全体の中から選ばれた「ゲートキーパー」たちが変更をレビューします。また、コードレビューのプロセスを小さなチームに委ね、チームごとに異なるレベルのコードレビューを要求することもあります。Googleでは、基本的にすべての変更がコミットされる前にレビューされ、すべてのエンジニアがレビューの開始と変更の確認に責任を持っています。

コードレビューは一般的に、プロセスとそれをサポートするツールの組み合わせが必要です。Googleでは、Critiqueというカスタムコードレビューツールを使ってプロセスをサポートしています(*1)。この章では、特定のツールではなく、Googleで実践されているコードレビューのプロセスに焦点を当てています。これは、これらの基礎がツールよりも古いものであることと、これらの洞察のほとんどが、コードレビューに使用するどのようなツールにも適用できるものであるためです。


  Critiqueについては、第19章を参照してください。

コードレビューの利点の中には、コードベースに入る前にコードのバグを検出できるなど、よく知られており(*2)、(測定が不正確ではあるが)ある程度明白なものがあります。しかし、それ以外のメリットは、より微妙なものです。Googleのコードレビュープロセスは非常にユビキタスで広範囲にわたっているため、心理的なものも含め、このような微妙な効果の多くに気付きました。

## コードレビューの流れ

コードレビューは、ソフトウェア開発のさまざまな段階で行われます。Googleでは、コードレビューは変更をコードベースにコミットする前に行われます。この段階はプリコミットレビューとも呼ばれます。コードレビューの主な目的は、他のエンジニアに変更を承諾してもらうことであり、私たちはその変更を「looks good to me」（LGTM）というタグで表します。私たちはこのLGTMを、変更をコミットするために必要なパーミッションの「ビット」として使用します（後述の他のビットと組み合わせて使用します）。
Googleの典型的なコードレビューは、以下のような手順で行われます。

1. ユーザーが自分のワークスペースのコードベースに変更を書き込みます。この作者は、変更のスナップショット（パッチとそれに対応する説明文）を作成し、コードレビューツールにアップロードします。この変更により、コードベースに対する diff が作成され、どのコードが変更されたかを評価するために使用されます。
2. 作者は、この最初のパッチを使って、自動レビューコメントを適用したり、セルフレビューを行ったりすることができます。作者は、変更点の diff に満足したら、その変更点を 1 人または複数のレビュアーに郵送します。このプロセスでは、それらのレビュアーに通知し、スナップショットの閲覧とコメントを求めます。
3. レビューアは、コードレビューツールで変更箇所を開き、diffにコメントを投稿します。コメントの中には、明示的な解決を求めるものがあります。単に情報を提供するものもあります。
4. 作者は、フィードバックに基づいて変更を修正し、新しいスナップショットをアップロードして、レビュアーに返信します。ステップ3と4は複数回繰り返すことができます。
5. レビューアが変更の最新の状態に満足した後、変更に同意し、「looks good to me」(LGTM)とマークして承認します。デフォルトでは1つのLGTMのみが要求されますが、コンベンションではすべてのレビュアーが変更に同意することを要求する場合もあります。
6. 変更が LGTM とマークされた後、すべてのコメントを解決し、変更が承認されていれば、作者はその変更をコードベースにコミットすることができます。承認については、次のセクションで説明します。

このプロセスについては、本章の後半で詳しく説明します。

-----

### コードには責任がある

コード自体が負債であることを忘れない（受け入れる）ことが重要です。必要な責任かもしれませんが、コードはそれだけでは、どこかの誰かのメンテナンス作業に過ぎません。飛行機が運ぶ燃料のように、コードには重みがありますが、もちろん飛行機が飛ぶためには必要なものです。

新しい機能が必要になることはよくありますが、そもそもコードを開発する前に、新しい機能が必要であるかどうかを確認するための注意が必要です。重複したコードは無駄な作業であるだけでなく、実際にはコードを持たない場合よりも時間的なコストがかかることがあります。一つのコードパターンで簡単にできる変更でも、コードベースに重複があるとより多くの労力を必要とします。全く新しいコードを書くことは嫌われるので、ある人はこう言います。"もしゼロから書いているなら、それは間違っている!"

これは、ライブラリやユーティリティのコードに特に当てはまります。おそらく、あなたがユーティリティを書いていても、Googleと同じ規模のコードベースのどこかで、他の誰かが同じようなことをしているでしょう。そのため、第17章で説明したようなツールは、そのようなユーティリティコードを見つけたり、重複したコードの導入を防いだりするために非常に重要です。理想的には、このような調査が事前に行われ、新しいコードを書く前に、新しいもののデザインが適切なグループに伝えられていることです。

もちろん、新しいプロジェクトが発生したり、新しい技術が導入されたり、新しいコンポーネントが必要になったりすることはあります。とはいえ、コードレビューは以前の設計上の決定を蒸し返したり、議論したりする場ではありません。設計の決定には時間がかかることが多く、設計案の配布、APIレビューなどでの設計に関する議論、そしておそらくプロトタイプの開発が必要になります。全く新しいコードのコードレビューが突然行われるべきではないのと同様に、コードレビューのプロセス自体も、過去の決定事項を再検討する機会と見なすべきではありません。

-----

## Googleにおけるコードレビューの仕組み

典型的なコードレビュープロセスがどのように機能するかを大まかに指摘してきましたが、重要なのは細部にあります。このセクションでは、Googleでのコードレビューの仕組みと、これらのプラクティスがどのようにして時間をかけて適切にスケーリングすることを可能にしているかについて、詳細に説明します。
Googleでは、どのような変更でも「承認」を必要とするレビューの3つの側面があります。

- 他のエンジニアが、コードが適切であり、作者が主張していることを実行しているかどうか、正しさと理解度をチェックすること。これはチームメンバーであることが多いのですが、必ずしもそうである必要はありません。このことは、LGTMの許可ビットに反映されています。許可ビットは、ピア・レビュアーがコードを「良さそうだ」と同意した後にセットされます。
- コードがコードベースの特定の部分に適している(特定のディレクトリにチェックインできる)という、コード所有者の1人からの承認。作者がそのような所有者である場合、この承認は暗黙の了解となることがあります。Googleのコードベースは、特定のディレクトリの所有者が階層化されたツリー構造になっています。(第16章参照)。所有者は、特定のディレクトリのゲートキーパーの役割を果たします。エンジニアが提案した変更は、他のエンジニアによってLGTMされるかもしれませんが、問題のディレクトリのオーナーは、コードベースの自分の部分への追加を承認しなければなりません。そのようなオーナーは、コードベースの特定の領域に精通していると思われる技術リーダーや他のエンジニアかもしれません。オーナーシップの権限をどれだけ広く、あるいは狭く設定するかは、各チームに任されています。
- 言語の「読みやすさ」(*3)を持つ人が、その言語のスタイルやベストプラクティスに準拠していることを承認し、私たちが期待する方法でコードが書かれているかどうかをチェックします。この承認も、著者にそのような読みやすさがあれば、暗黙の了解となるかもしれません。これらのエンジニアは、そのプログラミング言語のリーダビリティを付与された全社のエンジニアの中から引き抜かれます。

しかし、ほとんどのレビューでは、一人の人間がこの3つの役割を担っているため、プロセスが非常に速くなっています。重要なのは、著者が後者の2つの役割を担うこともできるということです。自分のコードベースにコードをチェックするためには、他のエンジニアがLGTMを必要とするだけですが、その言語での読みやすさをすでに持っていることが条件となります（オーナーがそうであることが多い）。

これらの要件により、コードレビュープロセスは非常に柔軟になります。あるプロジェクトのオーナーであり、そのコードの言語の可読性を持っているテックリードは、他のエンジニアからのLGTMだけでコード変更を提出することができます。そのような権限を持たないインターンは、言語可読性を持つオーナーから承認を得れば、同じコードベースに同じ変更を提出することができます。前述の3つの許可「ビット」は、どのような組み合わせも可能です。作者は、すべてのレビュアーにLGTMを求めるように変更を明示的にタグ付けすることで、別々の人に複数のLGTMを要求することもできます。

実際には、複数の承認を必要とするコードレビューのほとんどは、ピアエンジニアからLGTMを得て、次に適切なコードオーナー/可読性レビュアー（複数）に承認を求めるという2段階のプロセスを経るのが普通です。これにより、2つの役割がコードレビューの異なる側面に焦点を当てることができ、レビュー時間を短縮することができます。プライマリーレビュアーは、コードの正しさとコード変更の一般的な妥当性に注目することができ、コードオーナーは、コードの各行の詳細に注目しなくても、この変更がコードベースの自分の部分に適切であるかどうかに注目することができます。承認者が求めているものは、言い換えればピアレビューとは異なるものであることが多いのです。結局のところ、誰かが自分のプロジェクトやディレクトリにコードをチェックインしようとしているのです。彼らは次のような質問に関心があります。"このコードは維持するのが簡単か難しいか？" "このコードは私の技術的負債を増やすことになるのか？" "チーム内でメンテナンスするための専門知識はあるのか？"

これら3つのタイプのレビューを1人のレビュアーが担当できるのであれば、そのタイプのレビュアーがすべてのコードレビューを担当すればよいのではないでしょうか。その答えは「規模」です。3つの役割を分けることで、コードレビューのプロセスに柔軟性を持たせることができます。ユーティリティーライブラリ内の新しい関数を仲間と一緒に作っている場合、チーム内の誰かにコードの正しさと理解度をレビューしてもらいます。数回のラウンド（おそらく数日間）の後、あなたのコードがピア・レビュアーを満足させ、LGTMを得ることができます。あとは、そのライブラリのオーナー（オーナーは適切な読みやすさを持っていることが多い）に変更を承認してもらうだけです。

----

### 所有権

Hyrum Wright

専用のリポジトリで少人数のチームで作業する場合、チーム全体にリポジトリ内のすべてのものへのアクセスを許可するのが一般的です。結局のところ、他のエンジニアを知っているし、ドメインが狭いので各人が専門家になれるし、人数が少ないので潜在的なエラーの影響を抑えることができるからです。

チームの規模が大きくなると、このアプローチは拡張性に欠けるようになります。その結果、リポジトリが乱雑に分割されるか、誰がどのような知識と責任を持っているかをリポジトリの異なる部分に記録するための異なるアプローチが必要になります。Googleでは、この一連の知識と責任をオーナーシップと呼び、それを行使する人をオーナーと呼んでいます。この概念は、ソースコードの集合体を所有することとは異なり、コードベースのある部分について会社の利益のために行動するスチュワードシップの感覚を意味しています。(確かに、もう一度やり直すとしたら、「スチュワード」という言葉の方がいいかもしれません)。

特別な名前のOWNERSファイルには、ディレクトリとその子の所有権を持つ人のユーザー名がリストアップされています。これらのファイルは、他のOWNERSファイルや外部のアクセスコントロールリストへの参照を含むこともありますが、最終的には個人のリストに解決されます。各サブディレクトリには、それぞれ別のOWNERSファイルが含まれており、その関係は階層的に加算されていきます。OWNERSファイルは、チームが必要とする数のエントリーを持つことができますが、責任の所在を明確にするために、比較的小さくて集中的なリストを持つことを推奨します。

Google のコードを所有すると、自分の権限内のコードを承認する権利が与えられますが、この権利には、所有しているコードを理解したり、理解している人を見つける方法を知っておくなどの責任が伴います。新しいメンバーにオーナーシップを与える基準はチームによって異なりますが、一般的には、オーナーシップを入社式の儀式として使わないようにし、退社するメンバーにはできるだけ早くオーナーシップを放棄するように勧めています。

この分散したオーナーシップ構造により、本書で説明した他の多くの実践が可能になります。例えば、ルートOWNERSファイルに登録されている人たちは、大規模な変更を行う際に、ローカルチームに迷惑をかけることなく、グローバルな承認者として機能することができます（第22章参照）。同様に、OWNERSファイルは一種のドキュメントのような役割を果たし、人々やツールがディレクトリツリーを歩くだけで、特定のコードの責任者を簡単に見つけることができます。また、新しいプロジェクトが作成されても、新しいオーナーシップ権限を登録する中央機関はありません：新しいOWNERSファイルで十分です。

このオーナーシップの仕組みはシンプルでありながら強力で、過去20年間に渡ってうまく拡張されてきました。これは、Googleが、何万人ものエンジニアが1つのリポジトリで何十億行ものコードを効率的に処理できるようにするための方法の1つです。

----

## コードレビューのメリット

業界全体では、コードレビューは普遍的な慣行とは程遠いものの、それ自体は議論の対象にはなっていません。多くの企業やオープンソースプロジェクトでは、何らかの形でコードレビューが行われており、ほとんどの企業では、コードベースに新しいコードを導入する際の健全性チェックとして、このプロセスを重要視しています。ソフトウェアエンジニアは、個人的にはコードレビューがすべてのケースに適用されるとは思っていなくても、コードレビューのより明白なメリットを理解しています。しかし、グーグルでは、このプロセスが他の多くの企業よりも徹底しており、広く普及している。

多くのソフトウェア企業がそうであるように、Googleの文化は、エンジニアに仕事の進め方の自由度を与えることを基本としています。新しい技術に迅速に対応しなければならないダイナミックな企業にとって、厳格なプロセスはうまく機能しない傾向があり、官僚的なルールはクリエイティブなプロフェッショナルとうまく機能しない傾向があるという認識があります。しかし、コードレビューは、グーグルのすべてのソフトウェアエンジニアが参加しなければならない数少ない包括的なプロセスの1つであり、義務付けられている。グーグルでは、どんなに小さなコードベースへの変更でも、ほぼすべてのコードレビューを要求している(*4)。この義務化は、コードベースへの新しいコードの導入を遅らせ、コード変更の生産開始までの時間に影響を与えることから、エンジニアリングの速度にコストと影響を与えます。(これらはいずれも、厳格なコードレビュープロセスに対するソフトウェアエンジニアの一般的な不満です。) では、なぜこのようなプロセスを必要とするのでしょうか。また、このプロセスが長期的に有益であると考える理由は何でしょうか。

適切に設計されたコードレビュープロセスと、コードレビューに真剣に取り組む文化は、以下のようなメリットをもたらします。

- コードの正しさをチェック
- コードの変更が他のエンジニアに理解できるかどうかの確認
- コードベース全体の一貫性を確保する
- チームのオーナーシップを心理的に促進する
- 知識の共有が可能になる
- コードレビュー自体の履歴が残る
  
これらの利点の多くは、ソフトウェア組織にとって長期的に重要であり、作者だけでなくレビュアーにとっても有益なものが多い。以下のセクションでは、それぞれの項目についてより具体的に説明します。

### コードの正しさ

コードレビューの明らかな利点は、レビューアがコード変更の「正しさ」をチェックできることです。他の人の目で見てもらうことで、その変更が意図した通りに行われているかどうかを確認することができます。レビュアーは一般的に、変更が適切にテストされているか、適切に設計されているか、正しく効率的に機能しているかを確認します。多くの場合、コードの正しさをチェックすることは、特定の変更がコードベースにバグをもたらすかどうかをチェックすることです。

ソフトウェアのバグを未然に防ぐためにコードレビューが有効であることは、多くの報告で指摘されています。IBMの研究では、工程の早い段階で不具合を発見することで、当然のことながら後の修正にかかる時間を短縮することができた(*5)。コードレビューのための時間を投資することで、テスト、デバッグ、リグレッションにかかる時間を節約することができたが、コードレビューのプロセス自体を効率化して軽量化する必要があった。後者の点は重要で、コードレビュープロセスが重くなったり、適切にスケールしなかったりすると、維持できなくなります(*6)。この章の後半で、プロセスを軽量化するためのベストプラクティスを紹介します。

正しさの評価が客観的ではなく主観的になるのを防ぐために、著者は一般的に、導入された変更のデザインや機能にかかわらず、特定のアプローチに敬意を払うことになっています。レビュアーは、個人的な意見で代替案を提案してはいけません。レビュアーは代替案を提案することができますが、それは理解度を向上させる（例えば、複雑さを軽減する）、または機能性を向上させる（例えば、効率性を高める）場合に限られます。一般的にエンジニアは、より「完璧」なソリューションに対するコンセンサスを待つのではなく、コードベースを改善する変更を承認することが推奨されています。これにより、コードレビューが迅速に行われる傾向にあります。

ツールが充実してくると、静的解析や自動テストなど、多くの正しさのチェックが自動的に行われるようになります（ただし、ツールを使っても、人間がコードをチェックすることが完全になくなるわけではありません。このようなツールには限界がありますが、コードの正しさをチェックするために人の手によるコードレビューに頼る必要性は確実に減っています。

とはいえ、最初のコードレビューで不具合をチェックすることは、一般的な「左遷」戦略の不可欠な要素であり、問題をできるだけ早い段階で発見して解決し、開発サイクルの後半でコストやリソースを増大させないようにすることを目的としています。コードレビューは、そのような正しさをチェックする万能薬でもなければ、唯一のチェック方法でもありませんが、ソフトウェアのそのような問題に対する徹底的な防御の要素となります。そのため、コードレビューは「完璧」でなくても成果を上げることができます。

意外かもしれませんが、コードの正しさをチェックすることは、Googleがコードレビューのプロセスから得られる主な利点ではありません。コードの正しさをチェックすることは、一般的に変更が機能することを保証するものですが、コードの変更が理解可能であり、時間の経過やコードベース自体の規模が大きくなったときに意味をなすものであることを保証することに、より重要性があります。そういった点を評価するためには、単にコードが論理的に「正しい」かどうか、理解されているかどうか以外の要素に目を向ける必要があります。


### コードの理解度

コードレビューは、通常、作者以外の人が変更点を確認する最初の機会です。このような視点を持つことで、レビュアーは、最高のエンジニアでもできないことをすることができます。コードレビューは多くの場合、ある変更がより多くの人に理解できるかどうかの最初のテストです。コードは書かれたものよりも何度も読まれるものですから、この視点は非常に重要です。コードは書かれたものよりも何度も読まれるものであり、理解と把握が決定的に重要であるからです。

作者とは異なる視点を持ったレビュアーを見つけることは、しばしば有用です。特に、仕事の一環として、変更の中で提案されているコードを維持したり使用したりする必要があるかもしれないレビュアーはそうです。設計上の決定に関してレビュアーが著者に与えるべき敬意とは異なり、コード理解に関する質問には「顧客は常に正しい」という格言を用いて扱うことがしばしば役に立ちます。ある意味、今、あなたが受けた質問は、時間の経過とともに何倍にもなります。ですから、コード理解に関する質問はすべて有効なものと考えてください。批判されたからといって、アプローチやロジックを変える必要はありませんが、よりわかりやすく説明する必要があるかもしれないということです。

コードの正しさとコードの理解度のチェックを合わせて行うことが、他のエンジニアからのLGTMの主な基準となり、承認されたコードレビューに必要な承認ビットの1つとなります。エンジニアがコードレビューにLGTMと印をつけることは、コードが言っていることを実行しており、理解できることを言っていることになります。しかし、Googleはコードが持続的に維持されることも要求していますので、場合によってはコードに必要な追加の承認もあります。

### コードの一貫性

規模が大きくなると、あなたが書いたコードは誰かに頼られ、最終的には誰かがメンテナンスすることになります。多くの人があなたのコードを読み、あなたが行ったことを理解する必要があります。また、あなたが別のプロジェクトに移った後も、他の人（自動化ツールを含む）があなたのコードをリファクタリングする必要があるかもしれません。そのため、コードを理解し、維持するためには、ある程度の一貫性の基準に準拠する必要があります。また、コードは過度に複雑にならないようにする必要があります。シンプルなコードは、他の人にとっても理解しやすく、メンテナンスしやすいものです。コードレビューでは、コードがコードベース自体の基準にどれだけ合致しているかをレビュアーが評価します。つまり、コードレビューはコードの健全性を確保するために行われるべきものなのです。

コードレビューのLGTM状態（コードの正しさや理解度を示す）と、可読性承認の状態を分けているのは、保守性のためです。可読性の承認は、特定のプログラミング言語のコード可読性トレーニングのプロセスを成功させた個人によってのみ与えられる。例えば、Javaのコードを承認するには、"Javaの可読性 "を持つエンジニアが必要です。

可読性承認者は、コードが特定のプログラミング言語で合意されたベストプラクティスに従っているか、Googleのコードリポジトリにあるその言語のコードベースと一致しているか、過度に複雑になっていないかなどを確認する役割を担っています。一貫性のあるシンプルなコードは、理解しやすく、リファクタリングの際にツールが更新しやすいため、耐障害性に優れています。コードベースの中で特定のパターンが常に一つの方法で行われていれば、それをリファクタリングするためのツールを書くのも簡単です。

また、コードは一度しか書かれないかもしれませんが、何十回、何百回、何千回と読まれることになります。コードベース全体で一貫性のあるコードがあれば、エンジニア全員の理解度が向上しますし、この一貫性はコードレビューのプロセス自体にも影響します。一貫性は時に機能性と衝突することがあります。読みやすさを重視するレビュアーは、機能的には「より良い」とは言えなくても、理解しやすい複雑でない変更を好むかもしれません。

コードベースの一貫性が高まれば、エンジニアが他のプロジェクトのコードをレビューすることも容易になります。エンジニアは、コードレビューの際にチームの外に助けを求めなければならないことがあります。コード自体が一貫していることを期待して、専門家にコードレビューを依頼することができれば、エンジニアはコードの正しさや理解力にもっと適切に集中することができます。

### 心理的・文化的効果

コードレビューには、文化的にも重要な効果があります。ソフトウェアエンジニアにとって、コードは「自分のもの」ではなく、実際には集合的な企業の一部であることを再確認できます。このような心理的な効果は微妙なものですが、それでも重要です。コードレビューがなければ、ほとんどのエンジニアは自然と個人的なスタイルやソフトウェア設計への独自のアプローチに傾いてしまうでしょう。コードレビューのプロセスでは、作者は他の人の意見を取り入れるだけでなく、より大きな利益のために妥協することを余儀なくされます。

自分の技術に誇りを持ち、自分のコードを他人に批判されるのを嫌がるのは人間の常です。また、自分の書いたコードに対する批判的なフィードバックを歓迎したくないのも当然のことです。コードレビューのプロセスは、感情的になりがちなやりとりを和らげるメカニズムを提供します。コードレビューが最も効果的に機能するのは、エンジニアの前提条件に疑問を投げかけるだけでなく、規定の中立的な方法で行われることです。結局のところ、このプロセスは批判的なレビューを必要としています（実際、私たちはコードレビューツールを「Critique」と呼んでいます）ので、レビューアが自分の仕事をして批判的になることを非難することはできません。したがって、コードレビュープロセス自体が「悪い警官」の役割を果たし、レビュアーは「良い警官」と見なされるのです。

もちろん、すべてのエンジニアが、あるいはほとんどのエンジニアが、このような心理的な装置を必要としているわけではありません。しかし、コードレビューというプロセスを通じて、そのような批判を回避することは、多くのエンジニアにとって、チームが期待することをより穏やかに伝えることになります。Googleや新しいチームに参加するエンジニアの多くは、コードレビューに怯えています。批判的なレビューを受けることは、その人の仕事ぶりに悪影響を及ぼすと考えがちだからです。しかし、時間が経つにつれ、ほとんどすべてのエンジニアはコードレビューを受けることを期待するようになり、このプロセスで提供されるアドバイスや質問を大切にするようになります（確かに、これには時間がかかることもありますが）。

コードレビューのもう一つの心理的な利点は、検証です。どんなに優秀なエンジニアでも、インポスター症候群になったり、自己批判をしすぎたりすることがあります。コードレビューのようなプロセスは、自分の仕事を検証し、認めてもらうためのものです。多くの場合、このプロセスでは、アイデアの交換や知識の共有（次のセクションで説明）が行われ、レビュアーとレビュイーの両方にメリットがあります。エンジニアは、自分の知識が増えてくると、自分の改善点についてポジティブなフィードバックを得ることが難しくなることがあります。コードレビューというプロセスは、そのメカニズムを提供することができます。

また、コードレビューを開始するプロセスでは、すべての作成者が変更に少しだけ注意を払わなければなりません。多くのソフトウェアエンジニアは完璧主義者ではありません。多くの人は、完璧だけど開発に時間がかかりすぎるコードよりも、「仕事ができる」コードの方が良いと認めます。コードレビューがなければ、たとえ後で修正するつもりであっても、多くの人が手を抜いてしまうのは当然のことです。「確かにユニットテストは全部できていないけど、それは後でやればいいや」と。コードレビューでは、エンジニアは変更を送信する前にそれらの問題を解決しなければなりません。コードレビューのために変更の構成要素を集めると、エンジニアは心理的にすべてのカモが並んでいることを確認しなければなりません。変更を送信する前のちょっとした反省の時間は、変更に目を通し、何も見落としていないことを確認するのに最適な時間です。

### 知識の共有

コードレビューの最も重要でありながら過小評価されている利点の一つに、知識の共有があります。ほとんどの著者は、レビューの対象となる分野の専門家、または少なくとも知識のあるレビュアーを選びます。レビュープロセスでは、レビュアーがその分野の知識を著者に伝えることができ、レビュアーは著者に提案、新しい技術、アドバイス情報を提供することができます。(レビューアは、著者の助けとなるように、コメントに「FYI」という印をつけることもできます）。) コードベースのある分野に精通した著者は、しばしばオーナーとなり、他のエンジニアのためのレビュアーとして活躍することになる。

コードレビューのフィードバックと確認のプロセスでは、なぜその変更が特定の方法で行われたのかを質問します。このような情報交換は、知識の共有を促進します。実際、多くのコードレビューでは双方向の情報交換が行われています。作者はもちろんのこと、レビュアーもコードレビューから新しいテクニックやパターンを学ぶことができます。Googleでは、コードレビューツールの中でレビュアーが編集案を作者と直接共有することもあります。

エンジニアは、送られてきたメールをすべて読むわけではありませんが、送られてきたコードレビューにはすべて返信する傾向があります。このような知識の共有は、タイムゾーンやプロジェクトを超えて行われることもあります。Googleのスケールを利用して、コードベースの隅々にいるエンジニアに素早く情報を広めることができます。コードレビューは、知識の伝達に最適なタイミングであり、実行可能なものです。(グーグルのエンジニアの多くは、コードレビューを通じて初めて他のエンジニアと「出会う」のです！）。)

Googleのエンジニアがコードレビューに費やす時間を考えると、蓄積される知識は非常に大きなものです。Googleのエンジニアの主な仕事はもちろんプログラミングですが、コードレビューに費やす時間もかなりの割合を占めています。コードレビューのプロセスは、ソフトウェアエンジニアが互いに交流し、コーディング技術に関する情報を交換するための主要な手段のひとつです。大規模な変更などのリファクタリングによって、コードレビューの中で新しいパターンが宣伝されることもよくあります。

また、コードレビューは、変更のたびにコードベースの一部となるため、歴史的な記録としても機能します。エンジニアは誰でも、Googleのコードベースを調査し、ある特定のパターンがいつ導入されたかを判断し、問題のある実際のコードレビューを持ち出すことができる。しばしば、その考古学的発見は、オリジナルの作者やレビュアーよりも多くのエンジニアに洞察を与えることになります。

## コードレビューのベストプラクティス

コードレビューは、確かに、組織に摩擦や遅延をもたらすことがあります。このような問題の多くは、コードレビュー自体に問題があるのではなく、コードレビューの実施方法に問題があると考えられます。Googleでコードレビュープロセスを円滑に運営することも同様であり、コードレビューにかける労力に見合ったコードレビューを実現するためには、いくつかのベストプラクティスが必要です。これらのベストプラクティスのほとんどは、コードレビューが適切に拡張できるように、プロセスを軽快かつ迅速に保つことを重視しています。

### 礼儀正しく、プロフェッショナルであること

本書の「文化」の項で述べたように、Googleは信頼と尊敬の文化を大切にしています。これは、コードレビューに対する考え方にも反映されています。例えば、ソフトウェアエンジニアがコード理解の要件を満たすためには、他の1人のエンジニアからLGTMを受ける必要があるとします。多くのエンジニアは、コメントやLGTMの変更を行った後、追加のレビューを行わずに変更を提出することを理解しています。とはいえ、コードレビューは、どんなに有能なエンジニアでも、不安やストレスをもたらすものです。すべてのフィードバックや批判をしっかりとプロの領域にとどめておくことが決定的に重要なのです。

一般的に、査読者は特定のアプローチについて著者に従うべきであり、著者のアプローチに欠陥がある場合にのみ代替案を指摘すべきである。複数のアプローチが同等に有効であることを著者が証明できる場合は、査読者は著者の好みを受け入れるべきです。このような場合でも、アプローチに欠陥が見つかった場合は、レビューを（双方にとっての）学習の機会と考えてください。すべてのコメントは、厳密にプロフェッショナルであるべきです。レビュアーは、コード作者の特定のアプローチに基づいて結論を急ぐことに注意すべきです。そのアプローチが間違っていると決めつける前に、なぜそのようにしたのかを質問する方がよいでしょう。

レビュアーは迅速にフィードバックを行うべきです。Googleでは、コードレビューのフィードバックは24時間以内に行うことを求めています。もしレビュアーがその時間内にレビューを完了できない場合は、少なくとも変更点を確認し、できるだけ早くレビューに取りかかる旨を返信するのが良い方法です（期待されています）。レビュアーは、コードレビューに断片的に回答することは避けるべきです。レビューからフィードバックを得て、それに対処し、さらにレビュープロセスの中で関係のないフィードバックを受け続けることほど、作者を悩ませるものはありません。

査読者にプロ意識を求めるのと同様に、著者にもプロ意識を求めています。あなたのコードはあなたのものではなく、あなたが提案するこの変更は「あなたのもの」ではなく、チームのものであることを忘れないでください。あなたがコードベースにそのコードの一部をチェックした後は、どのような場合でもそれはもうあなたのものではありません。自分のやり方について質問されたら、なぜそのようにしたのかを説明できるようにしておきましょう。作者の責任の一部は、このコードが理解でき、将来にわたって保守可能であることを確認することであることを忘れないでください。

コードレビューでは、レビュアーのコメントをTODOアイテムとして扱うことが重要です。あるコメントをそのまま受け入れる必要はないかもしれませんが、少なくとも対処すべきです。あるコメントが問題なく受け入れられる必要はないかもしれませんが、少なくとも対処すべきです。レビューアのコメントに同意できない場合は、その旨と理由を伝え、双方が代替案を提示する機会が得られるまでコメントを解決済みとしないでください。著者がレビュアーに同意できない場合、このような議論を穏便に進めるための一般的な方法として、代替案を提示し、レビュアーにPTAL（Please take another look）を求めることがあります。コードレビューは、レビュアーと著者の両方にとって学ぶ機会であることを忘れないでください。その洞察力が、意見の相違を和らげるのに役立つことが多いのです。

同様に、あなたがコードの所有者であり、あなたのコードベース内でコードレビューに対応する場合は、外部の著者からの変更に従順であることが必要です。その変更がコードベースの改善につながるものである限り、その変更が改善できる点や改善すべき点を示しているという著者の意見を尊重すべきです。

### 小さな変更を書く

コードレビューのプロセスを軽快にするための最も重要な方法は、変更点を小さくすることでしょう。コードレビューは、レビュアーと作者の両方にとって、消化しやすく、単一の問題に焦点を当てることが理想的です。Googleのコードレビュープロセスでは、完全に形成されたプロジェクトで構成される大規模な変更は推奨されておらず、レビュアーはそのような変更を1回のレビューには大きすぎるとして、当然のことながら拒否することができます。また、小規模な変更であれば、エンジニアが大規模な変更のレビューを待つ時間を無駄にせず、ダウンタイムを減らすことができます。このような小さな変更は、ソフトウェア開発プロセスのさらに先にもメリットがあります。ある変更の中にあるバグの原因を特定するには、その変更が十分に小さいものであれば、はるかに簡単に絞り込むことができます。

とはいえ、小さな変更に頼るコードレビュープロセスは、大きな新機能の導入と両立させるのが難しい場合があることを認識しておく必要があります。小さなコード変更の積み重ねは、個々の変更を理解するのは容易ですが、大きな計画の中で理解するのは困難です。Googleのエンジニアの中には、小さな変更が好まれない人もいるという。そのようなコード変更を管理する技術は存在しますが（統合ブランチでの開発、HEADとは異なるdiffベースを使用した変更の管理）、それらの技術は必然的により多くのオーバーヘッドを伴います。小さな変更のための最適化はあくまでも最適化であり、たまに大きな変更があっても対応できるようなプロセスにしておきましょう。

「小さな」変更は、一般的にコードの200行程度に留めるべきです。小規模な変更は、レビュー担当者にとって簡単であるべきであり、同様に重要なことは、広範囲なレビューを待つために追加の変更が遅れるような面倒なものであってはならないということです。Googleでは、ほとんどの変更が約1日以内にレビューされることになっている(*7)（これは必ずしも1日以内にレビューが終わるという意味ではなく、最初のフィードバックが1日以内に提供されるという意味である）。Googleにおける変更の約35%は1つのファイルに対するものです(*8)。レビュアーに負担をかけないことで、コードベースの変更を迅速に行うことができ、作者にもメリットがあります。作者は迅速なレビューを望んでいます。1週間ほど広範なレビューを待っていると、その後の変更に影響を与える可能性が高いからです。また、最初に小さなレビューを行うことで、後になって間違ったアプローチで無駄な労力を費やすことを防ぐことができます。

コードレビューは一般的に少人数で行われるため、グーグルではほとんどすべてのコードレビューが一人の担当者によってレビューされるのが普通です。もしそうではなく、共通のコードベースに対するすべての変更についてチームが意見を求められたとしたら、このプロセス自体がスケールアップすることはありません。コードレビューを小規模にすることで、この最適化を可能にしています。1つの変更に対して複数の人がコメントすることは珍しくありません。ほとんどのコードレビューはチームメンバーに送られますが、適切なチームにはCCも送られます。その他のコメントは、重要ではあっても任意です。

変更点を小さくすることで、「承認」レビュアーは変更点をより迅速に承認することができます。彼らは、一次コードレビュアーが十分な注意を払ったかどうかをすぐに確認し、この変更がコードベースを強化し、長期的にコードの健全性を維持できるかどうかに純粋に集中することができます。

### 優れた変更内容の記述

変更内容の説明では、1行目に変更の種類をサマリーとして示す必要があります。最初の行は、コードレビューツール内での要約や、関連するメールの件名として使用され、Google エンジニアがコード検索内の履歴要約で目にする行（第 17 章参照）となるため、重要な位置を占めています。

最初の行は変更全体の要約であるべきですが、説明文では何がどのように変更されているのかを詳しく説明する必要があります。バグ修正」という記述は、査読者や将来のコードアーキオロジストにとって参考になりません。その変更でいくつかの関連する修正が行われた場合は、それらをリストにして列挙します（ただし、メッセージに沿って小さくします）。コード検索などのツールを使えば、コードベースの特定の変更において誰がどの行を書いたかを調べることができます。オリジナルの変更を掘り下げることは、バグを修正しようとするときにしばしば役に立ちます。

変更点にドキュメントを追加する機会は、説明文だけではありません。公開されたAPIを書くとき、一般的には実装の詳細を漏らしたくないものですが、実際の実装の中では是非ともそうしたいものですし、そこには自由にコメントすべきです。もしレビュアーが、あなたが何かをした理由を理解していない場合、それが正しいとしても、そのようなコードには、より良い構造またはより良いコメント（またはその両方）が必要であることを示す良い指標となります。コードレビューの過程で、新たな決定がなされた場合は、変更記述を更新するか、実装内に適切なコメントを追加してください。コードレビューは、単に現時点で行うものではなく、後世のために行ったことを記録するために行うものです。

### レビュアーを最小限に抑える

Googleのコードレビューは、ほとんどの場合、1人のレビュアーによって行われています(*9)。コードレビューのプロセスでは、コードの正しさ、オーナーの承認、言語の読みやすさなどを1人の個人が扱うことができるため、Googleのような規模の組織でも、コードレビューのプロセスは非常にうまく機能していると言えます。

業界や個人の中には、複数のエンジニアから追加の意見（および全員の同意）を得ようとする傾向があります。結局のところ、追加のレビュアーはそれぞれ、コードレビューに独自の洞察を加えることができるからです。最も重要なLGTMは最初の1人であり、それ以降のLGTMは思ったほど追加されないのです。追加のレビュアーのコストは、すぐにその価値を上回ってしまいます。

コードレビューのプロセスは、エンジニアが正しいことをしてくれるという信頼に基づいて最適化されています。特定のケースでは、特定の変更を複数の人にレビューしてもらうことが有効な場合がありますが、その場合でも、レビュアーは同じ変更の異なる側面に焦点を当てるべきです。

### 可能な限り自動化する

コードレビューは人間が行うプロセスであり、人間の意見は重要ですが、コードプロセスの中で自動化できる部分があれば、それを試してみてください。人間が行う機械的な作業を自動化する機会を模索すべきであり、適切なツールへの投資は利益をもたらします。Googleでは、コードレビューツールを使って、作者が自動的に変更を提出し、承認時にソースコントロールシステムに自動的に同期させることができます（通常、かなり単純な変更に使用されます）。

ここ数年の自動化に関する最も重要な技術的改善の一つは、コード変更時の自動静的解析です（第20章参照）。現在の Google コードレビューツールは、作者がテストやリンター、フォーマッターを実行するのではなく、プリサブミットと呼ばれる方法でほとんどのユーティリティを自動的に提供しています。プレサブミットプロセスは、変更が最初にレビューアに送信されるときに実行されます。変更が送信される前に、プリサブミットプロセスは既存の変更に関するさまざまな問題を検出し、現在の変更を拒否して（レビューアに気まずいメールを送るのを防いで）、元の作者にまず変更の修正を依頼します。このような自動化は、コードレビュープロセス自体を支援するだけでなく、レビュアーがフォーマットよりも重要な関心事に集中できるようにします。


## コードレビューの種類

すべてのコードレビューは同じではありません コードレビューの種類によって、レビュープロセスのさまざまな側面に焦点を当てるレベルが異なります。Google のコード変更は、一般的に次のいずれかに分類されます（重複する場合もあります）。

- グリーンフィールドレビューと新機能開発
- 動作の変更、改善、最適化
- バグ修正とロールバック
- リファクタリングと大規模な変更

### グリーンフィールドコードレビュー

コードレビューの中で最も一般的ではないのが、全く新しいコードのレビュー、いわゆるグリーンフィールドレビューです。グリーンフィールドレビューは、コードが時間の試練に耐えられるかどうか、つまり、時間と規模がコードの基本的な前提条件を変化させてもメンテナンスが容易になるかどうかを評価する最も重要な時間です。もちろん、まったく新しいコードが導入されても、驚くようなことではありません。この章の前半で述べたように、コードは負債であるため、全く新しいコードを導入する場合は、単に別の選択肢を提供するのではなく、実際の問題を解決する必要があります。Googleでは、新しいコードやプロジェクトは、コードレビューとは別に、大規模なデザインレビューを受ける必要があります。コードレビューは、過去に行われた設計上の決定を議論する場ではない（同じ意味で、コードレビューは提案されたAPIの設計を紹介する場でもない）。

コードが持続可能であることを保証するために、グリーンフィールド・レビューでは、APIが合意された設計(設計文書のレビューが必要な場合もある)に合致し、すべてのAPIエンドポイントが何らかの形でユニット・テストを行い、コードの前提条件が変わったときにそれらのテストが失敗することを確認する必要がある。(第11章参照）。) また、コードには適切なオーナーが存在し（新規プロジェクトの最初のレビューでは、新しいディレクトリのOWNERSファイルを1つ確認することがよくあります）、十分なコメントが付けられ、必要に応じて補足のドキュメントが提供されている必要があります。グリーンフィールド・レビューでは、プロジェクトを継続的インテグレーション・システムに導入する必要があるかもしれません。(第23章参照)。

### 動作の変更、改善、最適化

Googleにおける変更のほとんどは、コードベース内の既存コードの修正という大まかなカテゴリーに分類されます。このような変更には、APIエンドポイントの変更、既存の実装の改善、パフォーマンスなどの他の要因のための最適化などが含まれます。このような変更は、ほとんどのソフトウェアエンジニアの糧となります。

これらのケースでは、グリーンフィールドレビューに適用されるガイドラインが適用されます。つまり、この変更は必要なのか、この変更はコードベースを改善するものなのか、ということです。コードベースの最適な変更の中には、実は削除もあるのです。死んだコードや時代遅れのコードを取り除くことは、コードベースの全体的なコードの健全性を向上させる最良の方法の一つです。

挙動の修正には、新しいAPIの挙動に対する適切なテストの修正が含まれるべきです。実装の追加は、継続的インテグレーション（CI）システムでテストし、既存のテストの基本的な前提条件を壊さないようにする必要があります。また、最適化を行う際には、もちろんテストに影響を与えないようにする必要があり、レビュー担当者が参照できるようにパフォーマンスベンチマークを含める必要があるかもしれません。最適化のためには、ベンチマークテストが必要な場合もあります。

### バグフィックスとロールバック

必然的に、コードベースのバグフィックスのための変更を提出する必要があります。その際、他の問題に対処したいという誘惑に負けないようにしましょう。コードレビューの規模が大きくなるだけでなく、回帰テストの実施や他の人による変更のロールバックが困難になります。バグ修正は、指摘されたバグを修正することと、（通常は）最初に発生したエラーを捕捉するために関連するテストを更新することだけに集中すべきです。

テストを修正してバグに対処することは、しばしば必要です。このバグは、既存のテストが不十分であったり、コードの前提条件が満たされていなかったりしたために表面化したものです。バグ修正のレビュアーとしては、ユニットテストの更新を求めることが重要です（該当する場合）。

Google のような大規模なコードベースでコードを変更すると、テストで適切に検出されなかった依存関係が失敗したり、コードベースのテストされていない部分が明らかになったりすることがあります。このような場合、Google はそのような変更を「ロールバック」することを認めており、通常は影響を受ける下流の顧客がこれを行います。ロールバックとは、前回の変更を基本的に元に戻す変更のことです。このようなロールバックは、前回の変更を既知の状態に戻すだけなので、数秒で作成できますが、それでもコードレビューが必要です。

また、ロールバックの原因となる可能性のある変更（すべての変更を含む）は、できるだけ小さく、かつアトミックに行うことが非常に重要です。Googleでは、開発者が新しいコードを提出した後、すぐにそれに依存するようになり、その結果、ロールバックによって開発者が壊れてしまうことがあります。小さな変更は、その原子性と、小さな変更のレビューが迅速に行われる傾向にあることから、このような懸念を軽減するのに役立ちます。

### リファクタリングと大規模な変更

Google の多くの変更は自動的に生成されます。変更の作者は人間ではなく機械です。大規模変更（LSC）プロセスについては第22章で詳しく説明しますが、機械で生成された変更であってもレビューが必要です。リスクが低いと考えられる変更の場合は、コードベース全体の承認権限を持つ指定されたレビュアーによってレビューされます。しかし、変更がリスクを伴う可能性がある場合や、ローカルなドメインの専門知識が必要な場合には、個々のエンジニアが通常のワークフローの一環として、自動生成された変更のレビューを依頼されることがあります。

自動生成された変更に対するレビューは、一見すると他のコードレビューと同じように扱われるべきです。レビューアは、変更の正しさと適用性をチェックする必要があります。しかし、レビュアーには、関連する変更点へのコメントを制限し、変更点を生成する基本的なツールやLSCではなく、コードに固有の懸念事項のみを指摘することをお勧めします。特定の変更は機械で生成されたものかもしれませんが、これらの変更を生成する全体的なプロセスはすでにレビューされており、個々のチームがプロセスに対して拒否権を持つことはできませんし、そのような変更を組織全体に拡大することもできません。基本的なツールやプロセスに懸念がある場合、レビュアーはバンド外のLSCオーバーサイトグループにエスカレーションして詳細情報を得ることができます。

また、自動変更のレビュアーには、その範囲を広げないようにすることをお勧めします。新機能やチームメイトが書いた変更をレビューする際、変更を小さくするという先ほどのアドバイスに従っている限り、同じ変更の中で関連する問題を解決するように作者に依頼することは、しばしば妥当なことです。これは、自動生成された変更には適用されません。なぜなら、ツールを実行している人間は、何百もの変更を飛行中に持っている可能性があり、レビューコメントや関連性のない質問のある変更がわずかな割合であっても、人間がツールを効果的に操作できる規模を制限してしまうからです。

## 結論

コードレビューは、Googleで最も重要かつクリティカルなプロセスの1つです。コードレビューは、エンジニア同士を結びつける役割を果たしており、コードレビュープロセスは、テスト、静的解析、CIなど、他のほとんどのプロセスを支える主要な開発者のワークフローとなっています。コードレビュープロセスは、適切にスケールアップする必要があります。そのため、開発者の満足度と適切な生産速度を維持するためには、小さな変更、迅速なフィードバックと反復などのベストプラクティスが重要です。

## TL;DRs

- コードレビューには、コードの正しさ、理解度、コードベース全体の一貫性の確保など、多くの利点があります。
- 常に誰かを通して自分の仮定をチェックし、読む人のために最適化する。
- プロフェッショナルでありながら、批判的なフィードバックの機会を提供する。
- コードレビューは、組織全体で知識を共有するために重要です。
- 自動化は、プロセスを拡張するために重要です。
- コードレビュー自体が歴史的な記録となります。








-----

1 私たちは、主にオープンソースプロジェクトにおいて、GitコードのレビューにGerritも使用しています。しかし、GoogleではCritiqueが一般的なソフトウェアエンジニアの主要なツールとなっています。
2 Steve McConnell, Code Complete (Redmond: Microsoft Press, 2004).
3 Googleでは、「読みやすさ」とは単に理解力のことではなく、他のエンジニアがコードを維持できるようにするための一連のスタイルやベストプラクティスのことを指す。第3章参照。
4 ドキュメントや設定の変更によっては、コードレビューを必要としない場合もあるが、そのようなレビューを受けた方が望ましい場合も多い。
5 "Advances in Software Inspection," IEEE Transactions on Software Engineering, SE-12(7): 744-751, July 1986. この研究は、ソフトウェア開発プロセスにおいてロバストツールや自動テストが重要になる前に行われたものであるが、その結果は現代のソフトウェア時代にも当てはまると思われる。
6 Rigby, Peter C. and Christian Bird. 2013. "Convergent software peer review practices." ESEC/FSE 2013: Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering, August 2013: 202-212. https:// dl.acm.org/doi/10.1145/2491411.2491444.
7 Caitlin Sadowski, Emma Söderberg, Luke Church, Michal Sipko, and Alberto Bacchelli, "Modern code review: a case study at Google".
8 同上。
9 同上。


