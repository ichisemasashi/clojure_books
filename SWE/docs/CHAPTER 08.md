# CHAPTER 8 スタイルガイド・ルール

Written by Shaindel Schwartz
Edited by Tom Manshreck

ソースファイルの保存場所、コードのフォーマット、ネーミングやパターン、例外やスレッドに関するルールなど、ほとんどのエンジニアはコードベースを管理するルールを持っています。ほとんどのソフトウェアエンジニアは、自分たちの作業方法を管理する一連のポリシーの範囲内で仕事をしています。Googleでは、コードベースを管理するために、ルールを定義したスタイルガイドのセットを管理しています。

ルールは法律です。単なる提案や推奨ではなく、厳格で義務的な法律なのです。そのため、普遍的な強制力があり、必要に応じて承認された場合を除き、ルールを無視することはできません。ルールとは対照的に、ガイダンスは推奨事項やベスト・プラクティスを提供します。これらの断片は、従うべきであり、従うことを強く推奨しますが、ルールとは異なり、通常は多少の変動の余地があります。

私たちは、自分たちが定義したルール、つまり守らなければならないコードを書くための「やるべきこと」と「やってはいけないこと」を、プログラミングスタイルガイドにまとめ、それを規範として扱っています。「スタイル」というと、書式に限定したコレクションという意味で、少し語弊があるかもしれません。スタイルガイドはそれ以上のもので、私たちのコードを管理するための完全な規約なのです。しかし、スタイルガイドが厳密に規定されているわけではありません。スタイルガイドのルールでは、「合理的な範囲内で、できるだけ記述的な名前を使用する」というルールなど、判断が求められることがあります。むしろ、スタイルガイドは、エンジニアが責任を負うべきルールの決定的な情報源となっています。

Googleで使用しているプログラミング言語ごとにスタイルガイドを作成しています（※1）。 どのスタイルガイドも、持続可能性を意識したコード開発を目指しているという点では共通しています。一方で、その範囲や長さ、内容には大きな違いがあります。プログラミング言語には、異なる強み、異なる機能、異なる優先順位があり、進化し続けるGoogleのコードリポジトリに採用されるまでの歴史的な経緯も異なります。そのため、各言語のガイドラインを独自に調整する方がはるかに現実的です。スタイルガイドの中には、Dart、R、Shellのガイドに見られるように、ネーミングやフォーマットなど、いくつかの包括的な原則に焦点を当てた簡潔なものもあります。一方、C++、Python、Javaなどのように、特定の言語の特徴を詳細に説明し、より長い文書にしているスタイルガイドもあります。スタイルガイドの中には、Google以外の言語の典型的な使用方法を重視しているものもあります。私たちのGoスタイルガイドは非常に短く、外部で認識されている規約に記載されているプラクティスを遵守するという概要の指示に、いくつかのルールを追加しただけです。また、外部の規範とは根本的に異なるルールを盛り込んだものもあります。私たちのC++のルールでは、Googleコード以外で広く使われている言語機能である例外の使用を禁止しています。

Google独自のスタイルガイドであっても様々な違いがあるため、スタイルガイドがカバーすべき内容を正確に説明することは困難です。Googleのスタイルガイド開発の指針となる決定は、Googleのコードベースを持続可能なものにする必要性に由来しています。他の組織のコードベースでは、持続可能性に関する要件が本質的に異なるため、別の調整されたルールが必要になります。本章では、Google の C++、Python、Java のスタイルガイドを例に、ルールとガイダンスの開発を導く原則とプロセスについて説明します。

## なぜルールがあるのか？

では、なぜ私たちはルールを持つのでしょうか？ルールを設ける目的は、「良い」行動を促し、「悪い」行動を抑制することにあります。「良い」と「悪い」の解釈は組織によって異なり、組織が何を重視しているかによって異なります。このような呼称は普遍的な好みではなく、善と悪は主観的であり、ニーズに合わせて調整される。ある組織では、「良い」は、小さなメモリーフットプリントをサポートする使用パターンを促進したり、ランタイムの最適化の可能性を優先したりするかもしれません。また、ある組織では、新しい言語機能を利用することが「良い」ことになるかもしれません。また、一貫性を最も重視する組織では、既存のパターンと矛盾するものは「悪い」とされます。私たちはまず、組織が何に価値を置いているかを認識し、それに応じて行動を奨励したり抑制したりするために、ルールやガイダンスを使用する必要があります。

組織が成長するにつれ、確立されたルールとガイドラインがコーディングの共通語彙を形成していきます。共通のボキャブラリーがあれば、エンジニアはコードがどのように表現されているかではなく、コードが何を言わなければならないかに集中することができます。この語彙を形成することで、エンジニアは無意識のうちに「良い」ことをデフォルトで行うようになります。このようにルールは、一般的な開発パターンを望ましい方向に導くための大きな力となります。

## ルールの作成

ルールを定義する際に重要なのは、"どのようなルールにすべきか？"ということではありません。問われるべきは、"どのような目標を達成しようとしているのか "ということです。ルールが果たすべきゴールに焦点を当て、そのゴールをサポートするルールを特定することで、有用なルールを抽出することが容易になります。スタイルガイドがコーディングプラクティスの法則として機能しているGoogleでは、"What goes into the style guide?" ではなく、"Why does something go into the style guide?" と問いかけます。コードを書くことを規制する一連のルールを持つことで、私たちの組織は何を得るのでしょうか？

### 行動指針

物事を整理してみましょう。Googleのエンジニアリング組織は、3万人以上のエンジニアで構成されています。このエンジニア集団は、スキルや経歴に大きなばらつきがあります。また、20億行以上のコードベースに対して、毎日約6万件のコードを提出しています。このコードベースは今後数十年にわたって存在する可能性があります。私たちは、他の多くの組織が必要とするものとは異なる価値観に基づいて最適化を行っていますが、これらの懸念はある程度、普遍的なものであり、スケールと時間の両方に強いエンジニアリング環境を維持する必要があります。

この文脈では、私たちのルールの目的は、開発環境の複雑さを管理し、コードベースを管理可能な状態に保ちつつ、エンジニアが生産的に作業できるようにすることです。ここではトレードオフの関係にあります。この目標を達成するための大きなルール群は、選択肢を制限することになります。柔軟性は失われ、一部の人々を怒らせることもあるかもしれませんが、権威ある標準によってもたらされる一貫性と対立の減少という利益の方が大きいのです。

このような観点から、私たちは、ルールの開発を導くいくつかの包括的な原則を認識していますが、これらの原則は以下のとおりです。

- 自重する
- 読者にとって最適であること
- 一貫性があること
- エラーになりやすく、驚くような構造を避ける
- 必要に応じて実用性を考慮する

#### ルールは自重するもの

すべてをスタイルガイドに記載すべきではありません。新しいルールが設定されるたびに、組織内のすべてのエンジニアに学習と適応を求めることには、ゼロではないコストがかかります。ルールが多すぎると(*2)、エンジニアがコードを書くときにすべての関連ルールを覚えておくことが難しくなるだけでなく、新しいエンジニアが自分のやり方を覚えるのも難しくなります。また、ルールが多すぎると、ルールセットを維持するのが難しくなり、コストもかかります。

そのため、自明であると思われるルールはあえて掲載していません。Googleのスタイルガイドは、弁護士的に解釈されることを意図したものではありません。明示的に禁止されていないからといって、それが合法であるとは限りません。例えば、C++のスタイルガイドには、gotoの使用を禁止する規則はありません。C++プログラマーはすでにgotoを避ける傾向にあるため、明示的に禁止するルールを盛り込むと、不必要なオーバーヘッドが生じます。たった1人か2人のエンジニアが何かを間違えている場合、新しいルールを作ることで全員の精神的負担を増やすことは、スケールメリットがありません。

#### 読み手のための最適化

私たちのルールのもう一つの原則は、コードの作者ではなく、コードを読む人のために最適化することです。時間の経過とともに、コードは書かれた時よりもはるかに頻繁に読まれるようになります。読むのが難しいコードよりも、タイプするのが面倒なコードの方がいいのです。Pythonスタイルガイドでは、条件式について説明していますが、条件式はif文よりも短く、コード作成者にとって便利であると認識しています。しかし、条件式は、より冗長なif文よりも読者に理解されにくい傾向があるため、その使用を制限しています。書くのが簡単」よりも「読むのが簡単」を重視しているのです。ここではトレードオフの関係にあります。エンジニアが変数や型のために長くて説明的な名前を何度も入力しなければならない場合、前もってコストがかかります。しかし、将来の読者に読みやすさを提供するために、このコストを支払うことを選択しました。

この優先順位付けの一環として、私たちはエンジニアが意図した動作の証拠をコードの中に明示的に残すことも要求しています。読者がコードを読むときに、そのコードが何をしているのかを明確に理解できるようにするためです。例えば、Java、JavaScript、C++のスタイルガイドでは、メソッドがスーパークラスのメソッドをオーバーライドする場合、overrideアノテーションまたはキーワードの使用を義務付けています。明示的な設計上の証拠がなければ、読者はこの意図を理解することができますが、コードを読む際には各読者の側でもう少し調べる必要があります。

意図された動作の証拠は、それが意外なものである場合にさらに重要になります。C++では、コードの断片を読んだだけでは、ポインタの所有権を追跡することが難しい場合があります。ポインタが関数に渡された場合、その関数の動作に精通していなければ、何を期待していいのかわかりません。呼び出し側はまだポインタを所有しているのでしょうか？関数が所有権を持ったのか？関数が戻った後もポインタを使い続けられるのか，それとも削除されてしまったのか．この問題を回避するため、C++スタイルガイドでは、所有権の移転が意図される場合、std::unique_ptrの使用を推奨しています。unique_ptrは、ポインタの所有権を管理する構造体で、ポインタのコピーが1つしか存在しないことを保証します。関数が引数として unique_ptr を受け取り、そのポインタの所有権を取得しようとする場合、呼び出し側は明示的に移動セマンティクスを呼び出す必要があります。

```
// Foo*を受け取り、渡されたポインタの所有権を持つことも持たないこともできる関数。
void TakeFoo(Foo* arg);

// 関数を呼び出しても、その関数が戻ってきた後の所有権に関して、読者には何も伝えられません。
Foo* my_foo(NewFoo());
TakeFoo(my_foo);
```

次のように比較してみてください。

```
// std::unique_ptr<Foo>を受け取る関数です。
void TakeFoo(std::unique_ptr<Foo> arg);

// 関数を呼び出した場合は、所有権が放棄されたことを明示的に示し、
// 関数が戻った後はunique_ptrを使用できません。
std::unique_ptr<Foo> my_foo(FooFactory());
TakeFoo(std::move(my_foo));
```

このスタイルガイドのルールがあれば、すべての呼び出しサイトに、所有権移転の明確な証拠が適用されるたびに含まれることが保証されます。このシグナルがあれば、コードの読者はすべての関数呼び出しの動作を理解する必要はありません。私たちは、APIの相互作用を推論するのに十分な情報をAPIで提供しています。このように、呼び出し先での動作を明確に文書化することで、コードスニペットの可読性と理解性を確保しています。私たちはローカルな推論を目指しており、関数の実装を含む他のコードを探して参照しなくても、呼び出しサイトで何が起こっているかを明確に理解することを目標としています。

コメントを対象としたほとんどのスタイルガイドのルールも、読者にとってのその場での証拠というこの目標をサポートするように設計されています。ドキュメントコメント（ファイル、クラス、または関数の前に付けられるブロックコメント）は、後に続くコードの設計や意図を説明します。実装コメント（コード自体に散りばめられたコメント）は、明らかでない選択を正当化したり強調したり、やっかいな部分を説明したり、コードの重要な部分を強調したりします。当社では、この2種類のコメントについてスタイルガイドのルールを設けており、他のエンジニアがコードを読む際に求めているであろう説明を提供することを求めています。

#### 一貫性を保つ

コードベース内の一貫性に関する私たちの考え方は、Googleのオフィスで適用されている哲学に似ています。大規模で分散したエンジニア集団の中では、チームは頻繁にオフィス間で分割され、グーグル社員もしばしば他のサイトに移動します。それぞれのオフィスは独自の個性を持ち、地域性やスタイルを尊重していますが、仕事を進める上で必要なものは、意図的に同じものを維持しています。訪問するグーグラーのバッジは現地のすべてのバッジリーダーで使用でき、グーグルのデバイスは常にWiFiを利用でき、会議室のビデオ会議のセットアップは同じインターフェースで行われます。Googlerは、これらすべての設定方法を学ぶために時間を費やす必要はなく、どこにいても同じことができることを知っています。オフィス間を移動しても、仕事を進めるのは簡単です。

私たちはソースコードにもそれを求めています。一貫性があるからこそ、どんなエンジニアでもコードベースの知らない部分に飛び込んでも、すぐに仕事を始めることができるのです。ローカルプロジェクトには独特の個性がありますが、ツールは同じで、テクニックも同じで、ライブラリも同じで、すべてがうまくいくのです。

#### 一貫性のメリット

バッジリーダーやビデオ会議のインターフェースをカスタマイズできないのは、オフィスにとっては制約に感じるかもしれませんが、一貫性を保つことで得られるメリットは、失うクリエイティブな自由度をはるかに上回るものです。コードも同じで、一貫性を保つことで制約を感じることもあるかもしれませんが、その分、より多くのエンジニアがより少ない労力でより多くの仕事をこなすことができるのです(*3)

- コードベースのスタイルや規範が内部的に一貫していると、コードを書くエンジニアもそれを読む人も、表現方法よりも何をするのかに集中することができます。同じインターフェースで問題を解決し、一貫した方法でコードをフォーマットすることで、専門家がコードを一目見て、何が重要なのか、何をしているのかを理解することが容易になるのです。また、コードのモジュール化や重複の発見も容易になります。このような理由から、私たちは一貫した命名規則、共通パターンの一貫した使用、一貫したフォーマットと構造に多くの注意を払っています。また、一見すると小さな問題でも、物事が一つの方法でしか行われないことを保証するためだけに決定を下すルールも多くあります。たとえば、インデントに使うスペースの数や、行の長さの制限などです(*5)。ここで重要なのは、答えそのものではなく、答えがひとつであるという一貫性です。
- 一貫性がスケーリングを可能にします。一貫性のあるコードは、コードを理解し、編集し、生成することができるツールの構築を容易にしてくれます。一貫性に依存するツールの利点は、全員のコードが少しずつ異なっている場合には適用できません。あるツールが、不足しているインポートを追加したり、使用されていないインクルードを削除したりすることで、ソースファイルを更新し続けることができたとしても、プロジェクトごとにインポートリストのソート戦略が異なっている場合には、そのツールはどこでも動作することはできないかもしれません。全員が同じコンポーネントを使用し、全員のコードが構造や構成に関する同じルールに従っていれば、どこでも動作するツールに投資することができ、メンテナンス作業の多くを自動化することができます。もし各チームが、それぞれの環境に合わせて同じツールの特注バージョンに投資する必要があるとしたら、その利点は失われてしまいます。
- 一貫性は、組織の人間的な部分を拡大する際にも役立ちます。組織が大きくなると、コードベースに携わるエンジニアの数も増えます。全員が作業するコードを可能な限り一貫性のあるものにしておくことで、プロジェクト間の機動性を高め、エンジニアがチームを変更する際の立ち上げ時間を最小限に抑え、人員数のニーズが変動しても組織が柔軟に対応できるようにすることができます。組織が成長するということは、SRE、ライブラリエンジニア、コード管理者など、他の役割の人々がコードに関わるということでもあります。Googleでは、これらの役割が複数のプロジェクトにまたがっていることが多く、あるチームのプロジェクトに精通していないエンジニアが、そのプロジェクトのコードを担当することもあります。コードベース全体で一貫したエクスペリエンスを提供することで、これを効率的に行うことができます。
- 一貫性は、時間への耐性も確保します。時間が経過すると、エンジニアがプロジェクトを離れ、新しい人が加わり、オーナーシップが変化し、プロジェクトが合併したり分裂したりします。一貫性のあるコードベースを目指すことで、このような移行を低コストで行うことができます。また、コードとそれに携わるエンジニアの両方に、ほぼ制約のない流動性をもたらし、長期的なメンテナンスに必要なプロセスを簡素化することができます。

----

### スケールメリット

数年前、私たちのC++スタイルガイドは、古いコードの一貫性を失わせるようなスタイルガイドのルールはほとんど変更しないと約束しました。"場合によっては、特定のスタイルルールを変更する正当な理由があるかもしれませんが、一貫性を保つために、現状のままにしています。"

コードベースが小さく、古くて埃をかぶったコーナーが少なかった頃は、それが理にかなっていました。

コードベースが大きく、古くなってくると、それは優先すべきことではなくなりました。これは（少なくともC++スタイルガイドの策定者にとっては）意識的な変更でした。このビットを打ち込むことで、C++のコードベースが完全に一貫したものになることは二度とないし、それを目指しているわけでもないことを明確に表明したのです。

現在のベストプラクティスに合わせてルールを更新するだけでなく、これまでに書かれたすべてのものにそのルールを適用しなければならないというのは、単純に負担が大きすぎます。大規模変更ツールとプロセスにより、ほぼすべてのコードを、ほぼすべての新しいパターンや構文に従うように更新し、古いコードのほとんどが最新の承認されたスタイルを示すようにしています（第22章参照）。しかし、このような仕組みは完璧ではありません。コードベースがこれほど大きくなると、古いコードのすべてが新しいベストプラクティスに適合するとは限りません。完全な一貫性を求めることは、価値に対してコストがかかりすぎるという点に達しています。

----

**基準を設けること**
一貫性を主張するとき、私たちは内部的な一貫性に注目しがちです。時には、グローバルな規約が採用される前にローカルな規約が生まれることがあり、すべてを合わせることは合理的ではありません。そのような場合には、一貫性の階層化を提唱します。「一貫性を保つ」というのはローカルから始まります。あるファイルの中の規範が、あるチームの規範よりも先にあり、それが大きなプロジェクトの規範よりも先にあり、それがコードベース全体の規範よりも先にあります。実際、スタイルガイドには、ローカルな慣習に従うことを明示したルールが数多く含まれており(*6)、科学的な技術的選択よりも、このローカルな一貫性を重視しています。

しかし、組織が内部規約を作り、それを守るだけでは必ずしも十分ではありません。時には、外部のコミュニティで採用されている基準を考慮に入れる必要があります。

----

### スペースの数え方

GoogleのPythonスタイルガイドでは、当初、すべてのPythonコードに2スペースのインデントを義務付けていました。外部のPythonコミュニティで使用されている標準的なPythonスタイルガイドは4スペースのインデントを使用しています。私たちの初期のPython開発のほとんどは、実際のPythonアプリケーションではなく、C++プロジェクトを直接サポートするためでした。そのため、すでにそのようにフォーマットされていたC++のコードとの一貫性を保つために、2スペースのインデントを使うことにしました。時間が経つにつれ、この理由は実際には通用しないことがわかりました。Pythonのコードを書くエンジニアは、C++のコードを読んだり書いたりするよりも、他のPythonのコードを読んだり書いたりする方がはるかに多いのです。私たちは、エンジニアが何かを調べたり、外部のコードスニペットを参照する必要があるたびに、余分な労力を費やしていました。また、コードの一部をオープンソースにエクスポートしようとするたびに、社内のコードと外部の世界との違いを調整するのに時間がかかり、大変な苦労をしました。

Starlark（Googleで開発されたPythonベースのビルド記述言語）に独自のスタイルガイドを作成することになったとき、外部との整合性をとるために4スペースのインデントを使用することにしました(*7)。

----

慣例がすでに存在している場合は、通常、組織が外部との整合性をとることは良いアイデアです。小規模で自己完結的な短期間の取り組みの場合は、プロジェクトの限られた範囲の外で起こることよりも、内部の一貫性の方が重要なので、違いはないでしょう。しかし、時間の経過やスケールアップの可能性が出てくると、自分のコードが外部のプロジェクトに影響を与えたり、外の世界に出て行ってしまう可能性が高くなります。長期的に見れば、広く受け入れられている標準に従うことが利益につながるでしょう。

#### エラーになりやすい構文や意外な構文を避ける

私たちのスタイルガイドでは、私たちが使用している言語の中で、意外性のある、変わった、またはトリッキーな構成要素の使用を制限しています。複雑な機能には、一見しただけではわからない微妙な落とし穴があることがよくあります。複雑な機能を十分に理解せずに使用すると、誤用やバグの発生が容易になります。また、あるプロジェクトのエンジニアがよく理解している機能であっても、将来のプロジェクトメンバーやメンテナが同じように理解できるとは限りません。

このような理由から、Pythonのスタイルガイドでは、リフレクションのような強力な機能の使用を避けるように定めています。Pythonの反射関数hasattr()とgetattr()は、文字列を使ってオブジェクトの属性にアクセスすることができます。

```
if hasattr(my_object, 'foo'):
some_var = getattr(my_object, 'foo')
```

さて、この例では、すべてが順調に見えるかもしれません。しかし、考えてみてください。

```
some_file.py:
    A_CONSTANT = [
    'foo',
    'bar',
    'baz',
    ]
other_file.py:
    values = []
    for field in some_file.A_CONSTANT:
    values.append(getattr(my_object, field))
```

コードを検索するとき、foo、bar、bazというフィールドがここでアクセスされていることをどうやって知ることができますか？読み手には明確な証拠が残りません。どの文字列がオブジェクトの属性にアクセスするために使われているのか、簡単に見ることができないので、簡単に検証することができません。これらの値を `A_CONSTANT` から読み取る代わりに、リモート・プロシージャ・コール (RPC) のリクエスト・メッセージやデータ・ストアから読み取ったとしたらどうでしょう？このような難読化されたコードは、メッセージの検証を誤るだけで、重大なセキュリティ上の欠陥を引き起こす可能性があり、非常に気付きにくいものです。また、そのようなコードをテスト・検証することも困難です。

Pythonの動的な性質はそのような動作を可能にし、非常に限られた状況では、`hasattr()`や`getattr()`を使うことは有効です。しかし、ほとんどの場合、これらは難読化の原因となり、バグを引き起こすだけです。

このような高度な言語機能は、その活用方法を知っている専門家にとっては完璧に問題を解決できるかもしれませんが、パワー系の機能は理解するのが難しく、あまり普及していないのが現状です。エキスパートだけでなく、すべてのエンジニアがコードベースで操作できるようにする必要があります。これは、初心者のソフトウェアエンジニアをサポートするだけでなく、SREにとってもより良い環境となります。SREが本番の障害をデバッグしている場合、彼らはどんな疑わしいコードにも飛びつくでしょうし、たとえ自分が精通していない言語で書かれたコードであっても同様です。私たちは、理解しやすくメンテナンスしやすい、シンプルでわかりやすいコードに価値を置いています。

#### 実用性に譲歩する

ラルフ・ウォルドー・エマーソンの言葉です。"愚かな一貫性は、小さな心の迷信である。" 一貫性のあるシンプルなコードベースを追求するためには、他のすべてを盲目的に無視することはできません。スタイルガイドに記載されているルールの中には、例外を認めざるを得ないケースがあることは承知していますが、それは構いません。必要であれば、ルールに抵触する可能性のある最適化や実用性のための譲歩を認めます。

パフォーマンスは重要です。時には、一貫性や読みやすさを犠牲にしてでも、パフォーマンスの最適化に対応することは理にかなっています。たとえば、C++スタイルガイドでは例外の使用を禁止していますが、コンパイラの最適化を引き起こす例外関連の言語指定子であるnoexceptの使用を許可するルールが含まれています。

相互運用性も重要です。グーグル以外の特定の部品で動作するように設計されたコードは、そのターゲットに合わせて調整することで、より良い結果が得られるかもしれません。例えば、C++スタイルガイドには、一般的なキャメルケース命名ガイドラインの例外として、標準ライブラリの機能を模倣したエンティティに標準ライブラリのsnake_caseスタイルを使用することが認められています(*8)。また、C++スタイルガイドでは、プラットフォーム機能との互換性のために多重継承を必要とするWindowsプログラミングの例外も認められていますが、これは他のすべてのC++コードでは明示的に禁止されています。また、JavaとJavaScriptのスタイルガイドでは、プロジェクトの所有者以外のコンポーネントと頻繁にインターフェースをとったり、コンポーネントに依存したりする生成コードは、スタイルガイドのルールの対象外であることが明示されています(*9) 一貫性が重要であり、適応が重要です。

## スタイルガイド

では、言語スタイルガイドには何が必要なのでしょうか？スタイルガイドのルールには、大きく分けて3つのカテゴリーがあります。

- 危険を回避するためのルール
- ベストプラクティスを実施するためのルール
- 一貫性を保つためのルール

#### 危険を回避するために

スタイルガイドには、何よりもまず、技術的な理由で行わなければならない、あるいは行ってはならない言語機能に関するルールが記載されています。静的メンバーや変数の使い方、ラムダ式の使い方、例外処理のルール、スレッド化、アクセス制御、クラス継承などの構築に関するルールなどです。また、どのような言語機能を使用し、どのような構造を避けるべきかを説明しています。また、どのような目的で使用されるのか、標準的な語彙の種類についても言及しています。言語機能の中には、直感的に理解できなかったり、適切に適用するのが容易ではなかったりする微妙な使用パターンがあり、それが微妙なバグの原因になることがあります。このガイドでは、それぞれの判断について、長所と短所を考慮した上で、どのような結論に至ったかを説明することを目指しています。これらの決定のほとんどは、時間への耐性の必要性、維持可能な言語使用のサポートと奨励に基づいています。

#### ベストプラクティスの徹底

スタイルガイドには、ソースコードを書く上でのベストプラクティスを守るためのルールも含まれています。これらのルールは、コードベースの健全性と保守性を維持するのに役立ちます。例えば、コード作成者はどこにどのようにコメントを記述しなければならないかを規定しています(*10)。コメントに関する規則は、コメントの一般的な慣習を網羅しており、コード内の文書を記述しなければならない特定のケース（switch文のフォールスルー、空の例外キャッチブロック、テンプレートのメタプログラミングなど、意図が必ずしも明らかではないケース）にまで拡大しています。また、ソースファイルの構造を詳細に規定し、期待されるコンテンツの構成を概説するルールもあります。また、パッケージ、クラス、関数、変数などのネーミングに関するルールもあります。これらのルールはすべて、エンジニアがより健全で持続可能なコードをサポートするための実践を導くことを目的としています。

スタイルガイドで定められているベストプラクティスの中には、ソースコードをより読みやすくするためのものがあります。多くのフォーマットルールがこのカテゴリーに属します。スタイルガイドでは、読みやすさを向上させるために、垂直および水平方向の空白をいつ、どのように使用するかを規定しています。また、行の長さの制限や波括弧の配置についても規定しています。いくつかの言語では、自動フォーマットツール（Goの場合はgofmt、Dartの場合はdartfmt）に委ねることで、フォーマットの要件をカバーしています。フォーマット要件の詳細なリストを項目別に作成しても、適用しなければならないツールの名前を挙げても、目的は同じです。つまり、読みやすさを向上させるために設計された一貫したフォーマットルールを持ち、すべてのコードに適用するのです。

私たちのスタイルガイドには、新しい言語機能や、まだよく理解されていない言語機能に対する制限も含まれています。その目的は、その機能が持つ潜在的な落とし穴に安全柵をあらかじめ設置しておき、皆が学習プロセスを経ることにあります。同時に、みんなが走り出す前に、使用を制限することで、発展していく使用パターンを観察し、観察した例からベストプラクティスを抽出するチャンスを得ることができます。このような新機能の場合、最初はどのように指導すればよいのかわからないことがあります。導入が進むにつれ、新機能を様々な方法で使用したいと考えているエンジニアは、その例をスタイルガイドのオーナーに相談し、当初の制限事項でカバーされていない追加のユースケースを許可してほしいと依頼します。寄せられた許可申請を見て、私たちはその機能がどのように使われているかを把握し、最終的には良い事例と悪い事例を一般化できるだけの例を集めます。このような情報が得られれば、制限付きの裁定に立ち返り、より広い範囲で使用できるように修正することができます。

----

### ケーススタディ std::unique_ptr の導入

C++11 で、動的に割り当てられたオブジェクトの排他的な所有権を表し、`unique_ptr` がスコープ外になるとオブジェクトが削除されるスマート ポインタ型である `std::unique_ptr` が導入されたとき、私たちのスタイル ガイドは当初、その使用を認めませんでした。`unique_ptr` の動作はほとんどのエンジニアにとって馴染みのないもので、この言語が導入した関連する移動セマンティクスも非常に新しく、ほとんどのエンジニアにとっては非常に混乱したものでした。コードベースに `std::unique_ptr` が導入されるのを防ぐことは、より安全な選択だと思われました。私たちは、禁止された型への参照を捕捉するためにツールを更新し、既存のスマートポインタの他の型を推奨する既存のガイダンスを維持しました。

時間が経ちました。エンジニアは移動セマンティクスの意味を理解する機会があり、私たちは `std::unique_ptr` を使用することがスタイルガイダンスの目標に直接一致すると確信するようになりました。`std::unique_ptr` が関数呼び出しの場所で促進するオブジェクトの所有権に関する情報は、読者がそのコードを理解するのをはるかに容易にします。この新しい型を導入することによる追加の複雑さと、それに伴う斬新な移動セマンティクスは、依然として強い懸念材料でしたが、長期的にコードベース全体の状態が大幅に改善されたことで、`std::unique_ptr`の採用は価値あるトレードオフとなりました。

----

#### 一貫性の構築

スタイルガイドには、細かい部分をカバーするルールも含まれています。これらのルールでは、主に意思決定を行い、それを文書化します。このカテゴリーのルールの多くは、技術的に大きな影響を与えるものではありません。名前の付け方、インデントの間隔、インポートの順番など、ある形式が他の形式に比べて明確で測定可能な技術的メリットがないのが普通で、それが技術コミュニティが議論を続けがちな理由かもしれません(*11)。エンジニアはもう、スペースが2つか4つかという議論に時間を費やすことはありません。このカテゴリーのルールで重要なのは、あるルールに何を選択したかではなく、選択したという事実なのです。

#### そして、それ以外のものは...。

このように、スタイルガイドに載っていないこともたくさんあります。私たちは、コードベースの健全性に最も影響を与えるものに焦点を当てるようにしています。巧妙にならないこと、コードベースをフォークしないこと、車輪を再発明しないことなど、エンジニアリングの基本的なアドバイスも含めて、これらの文書で指定されていないベストプラクティスは絶対にあります。私たちのスタイルガイドのような文書は、全くの初心者がソフトウェアエンジニアリングをマスターレベルまで理解するための役割を果たすことはできませんが、私たちが想定していることがあり、これは意図的なものです。

## ルールの変更

私たちのスタイルガイドは固定されたものではありません。他の多くのものと同様に、時間の経過とともに、スタイルガイドの決定がなされた背景や、ある決定を導いた要因は変化する可能性があります。時には、再評価が必要なほど状況が変化することもあります。新しいバージョンの言語がリリースされた場合、新しい機能やイディオムを許可または除外するためにルールを更新する必要があるかもしれません。あるルールが原因でエンジニアがそのルールを回避するために労力を費やしている場合、そのルールが提供するはずだった利益を再検討する必要があるかもしれません。また、ルールを適用するためのツールが過度に複雑化し、メンテナンスに負担がかかるようになった場合は、ルール自体が衰退している可能性があり、再検討が必要です。ルールが見直されるタイミングを見極めることは、ルールセットを適切かつ最新の状態に保つための重要なプロセスのひとつです。

スタイルガイドに記載されているルールの決定は、根拠に基づいて行われています。ルールを追加する際には、関連する賛否両論や潜在的な影響についての議論や分析に時間をかけ、ある変更がGoogleの事業規模に適しているかどうかを検証しようとします。Googleのスタイルガイドのほとんどの項目には、このような検討事項が含まれており、プロセス中に検討された長所と短所が示され、最終的な裁定の理由が示されています。理想的には、この詳細な理由を優先し、すべてのルールに記載します。

理由を文書化することで、変更の必要性に気づくことができるという利点があります。時間の経過や状況の変化により、過去に行った良い判断が現在の最善の判断ではないかもしれません。影響を与える要因を明確にしておけば、これらの要因に関連した変化によってルールの見直しが必要になったときに、それを特定することができます。

----

### ケーススタディ キャメルケースネーミング

Googleでは、Pythonコードの初期スタイルガイダンスを定義した際、メソッド名にsnake_caseネーミングスタイルではなく、CamelCaseネーミングスタイルを使用することを選択しました。公開されているPythonスタイルガイド(PEP 8)やPythonコミュニティのほとんどはsnake_caseネーミングを使用していましたが、当時のGoogleのPython使用のほとんどはC++コードベースの上にスクリプトレイヤーとしてPythonを使用するC++開発者でした。定義されたPythonの型の多くは、対応するC++の型のラッパーであり、GoogleのC++の命名規則はキャメルケーススタイルに従っているため、言語間の一貫性が重要視されていました。

その後、私たちは独立したPythonアプリケーションを構築し、サポートする段階に達しました。最も頻繁にPythonを使用しているエンジニアは、Pythonプロジェクトを開発しているPythonエンジニアであり、C++エンジニアが簡単なスクリプトを作っているわけではありませんでした。私たちは、Pythonエンジニアに、内部コードのための1つの標準を維持しながら、外部コードを参照するたびに別の標準を常に調整しなければならないという、厄介で可読性の低い問題を引き起こしていました。また、Pythonの経験がある新入社員が、私たちのコードベースの規範に適応することも難しくなっていました。

私たちのPythonプロジェクトが成長するにつれ、私たちのコードは外部のPythonプロジェクトと頻繁にやりとりするようになりました。いくつかのプロジェクトではサードパーティのPythonライブラリを組み込んでいたので、コードベースの中では独自のCamelCaseフォーマットと外部から好まれるsnake_caseスタイルが混在するようになりました。いくつかのPythonプロジェクトをオープンソース化し始めたとき、私たちの慣習が不適合な外部の世界でそれらを維持することは、私たちにとって複雑さを増すと同時に、私たちのスタイルを意外で奇妙だと感じるコミュニティからの警戒心を招くことになりました。

これらの議論を受けて、コスト（他のGoogleコードとの整合性を失うこと、私たちのPythonスタイルに慣れたGooglerの再教育）とベネフィット（他のほとんどのPythonコードとの整合性を得ること、サードパーティのライブラリで既に漏れていたものを許可すること）の両方を議論した結果、Pythonスタイルガイドのスタイル制定者はルールを変更することを決定しました。ファイル全体の選択として適用されるという制限、既存のコードへの適用除外、プロジェクトが自分たちにとって何がベストかを決定する余地を考慮して、Google Python スタイルガイドは snake_case ネーミングを許可するように更新されました。

----

### プロセス

私たちが目指している長寿命と拡張性を考慮すると、物事を変える必要があることを認識し、私たちはルールを更新するためのプロセスを作成しました。スタイルガイドを変更するプロセスは、ソリューションベースです。スタイルガイド更新の提案は、既存の問題を特定し、それを解決するための方法として変更案を提示する、という考え方で行われます。このプロセスにおける「問題」とは、うまくいかない可能性のある仮想的な例ではなく、既存のGoogleコードに見られるパターンによって問題が証明されることです。実証された問題があれば、既存のスタイルガイドの決定の詳細な理由がわかるので、別の結論がより理にかなっているかどうかを確認しながら再検討することができます。

スタイルガイドで管理されているコードを書いているエンジニアのコミュニティは、ルールの変更が必要になったときに気づくのに最適な立場にあることが多い。実際、Googleではスタイルガイドの変更のほとんどがコミュニティでの議論から始まっています。エンジニアは誰でも質問したり、変更を提案したりすることができますが、通常はスタイルガイドの議論に特化した言語別のメーリングリストからスタートします。

スタイルガイドの変更を提案する際には、具体的な最新の表現が提案されることもあれば、特定のルールの適用可能性に関する漠然とした質問から始まることもあります。寄せられた提案はコミュニティで議論され、他の言語ユーザーからのフィードバックを受けます。提案の中には、不要である、曖昧である、有益でないなどの理由で、コミュニティのコンセンサスにより却下されるものもあります。一方で、そのままでも、あるいは改良を加えても価値があると判断され、肯定的なフィードバックを受けるものもあります。コミュニティのレビューを通過した提案は、最終的な意思決定者の承認を受けることになります。

### スタイルアービター

Googleでは、各言語のスタイルガイドについて、最終的な決定と承認はスタイルガイドの所有者であるスタイルアービターが行います。各プログラミング言語では、長年の言語専門家のグループがスタイルガイドの所有者であり、指定された決定権を持っています。ある言語のスタイルアービターは、その言語のライブラリチームのシニアメンバーや、関連する言語の経験を持つ長年のGooglerであることが多いです。

スタイルガイドの変更に関する実際の意思決定は、提案された変更に対するエンジニアリング上のトレードオフを議論することです。調停委員は、スタイルガイドが最適化するために合意された目標の文脈の中で決定を下します。変更は個人的な好みによって行われるのではなく、トレードオフに基づいて判断されます。実際、C++スタイルアービターグループは現在4人のメンバーで構成されています。これは奇妙に思えるかもしれません。委員会のメンバーが奇数であれば、判断が分かれた場合に同数の投票を防ぐことができます。しかし、「私がこうだと思うから」ではなく、すべてがトレードオフの評価であるという意思決定方法の性質上、投票ではなくコンセンサスで決定しています。4人のグループは、このままでも十分に機能している。

### 例外について

私たちのルールは法律ですが、例外を認めるべきルールもあります。当社のルールは、一般的なケースを想定して作られています。時には、特定の状況において、特定のルールを免除することが有効な場合もあります。このようなシナリオが発生した場合、スタイルアービターに相談して、特定のルールに対する免除を許可する正当なケースがあるかどうかを判断します。

免除は簡単には認められません。C++コードでは、マクロAPIを導入する場合、スタイルガイドでは、プロジェクト固有のプレフィックスを使用して名前を付けることが義務付けられています。C++では、マクロをグローバルな名前空間のメンバーとして扱うため、ヘッダーファイルからエクスポートされるすべてのマクロには、衝突を防ぐためにグローバルに一意な名前を付ける必要があります。マクロの命名に関するスタイルガイド規則では、純粋にグローバルな一部のユーティリティーマクロについて、アービターによる免除が認められています。しかし、プロジェクト固有の接頭辞を除外したいという免除申請の理由が、マクロ名の長さやプロジェクトの一貫性による好みに起因する場合、その免除は却下されます。ここでは、コードベースの整合性がプロジェクトの整合性を上回っています。

ルール違反を回避するよりも許可した方が有益であると判断される場合は、例外が認められています。C++スタイルガイドでは、単一引数のコンストラクタを含む暗黙の型変換を禁止しています。しかし、他の型を透過的にラップするように設計された型で、基礎となるデータが正確かつ精密に表現されている場合は、暗黙の変換を認めることは完全に合理的です。このような場合には、暗黙的変換禁止のルールを放棄することができます。このように明確な例外規定があるということは、問題となっているルールを明確にしたり、修正したりする必要があるかもしれません。しかし、この特定のルールでは、免除の有効なケースに適合するように見えても、実際には適合しない免除申請が十分に寄せられています。つまり、問題となっている特定のタイプが実際には透明なラッパータイプではないか、またはラッパータイプであっても実際には必要ではないかのどちらかです。

## ガイダンス

ルールに加えて、私たちはプログラミングガイダンスを様々な形で作成しています。複雑なトピックを深く掘り下げた長い議論から、私たちが支持するベストプラクティスについての簡潔なアドバイスまで、様々な形で作成しています。

ガイダンスは、私たちのエンジニアとしての経験から得られた知恵を集約したもので、これまでに得られた教訓から抽出したベストプラクティスを文書化したものです。ガイダンスは、人々が頻繁に間違えることを観察したものや、慣れていないために混乱を招きやすい新しい事柄に焦点を当てる傾向があります。ルールが "must "であるならば、ガイダンスは "shoulds "です。

私たちが培ってきた指針の一例として、私たちが使用する主要な言語のためのプライマーのセットがあります。私たちのスタイルガイドが、どの言語のどの機能が許され、どの機能が許されないかを規定するものであるのに対し、プライマーは、ガイドが推奨する機能を説明するものです。その内容は非常に幅広く、Googleで初めて言語を使用するエンジニアが参照する必要のあるほぼすべてのトピックに触れています。トピックの詳細までは語られていませんが、説明と推奨される使用方法が記載されています。エンジニアが使いたい機能をどのように適用すればいいのかを把握するために、プライマーは最適なガイド資料となることを目指しています。

数年前から、一般的な言語に関するアドバイスと Google 固有のヒントを組み合わせた C++ のヒントのシリーズを発行しています。ここでは、オブジェクトの寿命、コピーと移動のセマンティクス、引数に依存するルックアップなどの難しい問題、コードベースで採用された C++ 11 の機能、string_view、optional、variant などの C++17 で採用された型などの新しい問題、そして、use 指令を使用しないように注意したり、暗黙の bool 変換に気をつけるように警告したりするなど、優しく修正する必要がある問題を取り上げています。これらのヒントは、実際に遭遇した問題から生まれたもので、スタイルガイドではカバーしきれない実際のプログラミング上の問題を取り上げています。これらのアドバイスは、スタイルガイドのルールとは異なり、真の規範ではなく、ルールではなくアドバイスのカテゴリーに属しています。しかし、抽象的な理想ではなく、観察されたパターンから成長する方法を考えると、その広範で直接的な適用性は、他の多くのアドバイスとは異なり、「一般的な規範」のようなものです。Tipsは焦点を絞った比較的短いもので、1つの記事が数分で読める程度のものです。この "Tip of the Week "シリーズは社内で非常に好評で、コードレビューや技術的な議論の場で頻繁に引用されています(*12)。

ソフトウェアエンジニアは、新しいプロジェクトやコードベースに参加する際に、使用するプログラミング言語の知識はあっても、そのプログラミング言語が Google 社内でどのように使用されているかについての知識はありません。このギャップを埋めるために、Googleでは、主要なプログラミング言語ごとに「<言語>@Google 101」コースを設けています。この1日コースでは、その言語での開発がGoogleのコードベースで何が違うのかに焦点を当てます。最も頻繁に使用されるライブラリやイディオム、社内での好み、カスタムツールの使用方法などをカバーしています。GoogleのC++エンジニアになったばかりのC++エンジニアにとって、このコースは、単に優れたエンジニアというだけでなく、Googleのコードベースの優れたエンジニアとなるための足りない部分を補うものです。

私たちのセットアップにまったく慣れていない人でも、すぐに使いこなせるようになることを目的としたコースを教えるだけでなく、コードベースの奥深くにいるエンジニアが、外出先で役立つ情報を見つけられるようなリファレンスを用意しています。これらのリファレンスは、使用している言語ごとに様々な形で用意されています。社内で管理している便利なリファレンスには、以下のようなものがあります。

- 一般的に正しい情報を得るのが難しい分野（同時実行やハッシュなど）に対する言語別のアドバイス。
- 言語の更新に伴って導入される新機能の詳細な説明と、コードベース内での使用方法に関するアドバイス。
- ライブラリが提供する主要な抽象化とデータ構造のリスト。これにより、すでに存在する構造を再発明することなく、「必要なものがあるが、ライブラリで何と呼ばれているのかわからない」という問題に対応することができます。

## ルールの適用

ルールとは、その性質上、強制力を持つことでより大きな価値を発揮します。ルールは、教育やトレーニングを通じて社会的に強制することも、ツールを使って技術的に強制することもできます。Googleでは、ルールで定められているベストプラクティスの多くをカバーするさまざまな公式トレーニングコースを設けています。また、参考資料が正確で最新のものであるように、ドキュメントを最新の状態に保つためにリソースを投入しています。Googleのルールを理解していただくためのトレーニング方法として、コードレビューが重要な役割を果たしています。Googleで実施している可読性向上プロセス（Googleの開発環境に新規参入したエンジニアがコードレビューを通じて指導を受ける）は、スタイルガイドが求める習慣やパターンを培うためのものです（可読性向上プロセスの詳細については第3章を参照）。このプロセスは、これらの習慣を学び、プロジェクトの境界を越えて適用するための重要な要素となっています。

ある程度のトレーニングは常に必要ですが、エンジニアは結局のところ、ルールを学び、それに従ったコードを書けるようにしなければなりません。遵守状況の確認に関しては、エンジニアによる検証のみに頼るのではなく、ツールを使って施行を自動化することを強く望んでいます。

自動化されたルール・エンフォースメントは、時間が経過したり、組織が大きくなったりしても、ルールが抜け落ちたり、忘れられたりしないようにする。新しい人が加わっても、彼らはまだすべてのルールを知らないかもしれません。ルールは時間とともに変化します。コミュニケーションを十分にとっていても、全員がすべての現状を覚えているわけではありません。プロジェクトが成長し、新しい機能が追加されると、それまで関係のなかったルールが突然適用されるようになります。ルールが守られているかどうかをチェックするエンジニアは、記憶と文書のどちらかに頼ることになりますが、どちらも失敗する可能性があります。ルールの変更に同期してツールが最新の状態に保たれていれば、すべてのエンジニアがすべてのプロジェクトでルールを適用していることがわかります。

自動化されたエンフォースメントのもう一つの利点は、ルールの解釈や適用方法のばらつきを最小限に抑えることができることです。コンプライアンスをチェックするためにスクリプトを書いたり、ツールを使ったりする際には、すべての入力を単一の不変的なルールの定義に対して検証します。解釈を個々のエンジニアに任せることはありません。人間のエンジニアは、自分のバイアスがかかった視点ですべてを見ます。無意識であろうとなかろうと、潜在的には微妙な、あるいは無害なバイアスが、人のものの見方を変えてしまうのです。エンジニアにエンフォースメントを任せると、ルールの解釈や適用に一貫性がなく、期待される説明責任にも一貫性がなくなる可能性があります。ツールに委ねれば委ねるほど、人間のバイアスが入り込む余地は少なくなります。

また、ツール化することで、エンフォースメントをスケーラブルにすることができます。組織が大きくなっても、1つの専門家チームが作成したツールを他の組織が使用することができます。会社の規模が2倍になっても、組織全体ですべてのルールを実施するための労力は2倍にならず、以前と同じくらいのコストで済みます。

ツールを導入することで得られるメリットがあったとしても、すべてのルールの施行を自動化することは不可能かもしれません。技術的なルールの中には、人間の判断を明示的に求めるものがあります。例えば、C++のスタイルガイドには、次のように書かれています。"複雑なテンプレートのメタプログラミングは避ける。" "うるさい型名、明らかな型名、重要でない型名を避けるためにautoを使用する --- 型が読者の明確な理解を助けない場合" "合成はしばしば継承よりも適切である。" Javaのスタイルガイドでは "どのように（クラスのメンバーや初期化子を並べる）すればいいのか、唯一の正しいレシピはありません。" "異なるクラスは異なる方法でコンテンツを並べることができます。" "捕捉した例外に対して何もしないことが正しいことは極めて稀である。" "Object.finalizeをオーバーライドすることは極めて稀です。" これらのルールのすべてにおいて、判断が必要であり、ツールがその代わりをすることは（まだ！）できません。

その他のルールは、技術的なものというよりも社会的なものであり、社会的な問題を技術的な解決策で解決するのは賢明ではないことが多い。このカテゴリーに分類されるルールの多くは、詳細があまり定義されていない傾向があり、ツールの開発は複雑で高価なものになります。そのようなルールの施行は、人間に任せた方が良い場合が多いのです。例えば、コード変更のサイズ（影響を受けるファイル数や変更される行数）に関しては、エンジニアはより小さな変更を推奨しています。小さな変更はエンジニアにとってレビューしやすいため、レビューはより早く、より徹底したものになります。また、小さな変更であれば、潜在的な影響や効果を推し量ることができるため、バグが発生する可能性も低くなります。しかし、小さな変更の定義は曖昧です。何百ものファイルに同一の1行のアップデートを適用するような変更は、実際にはレビューしやすいかもしれません。一方、20行に及ぶ小規模な変更では、評価が困難な副作用を伴う複雑なロジックが導入される可能性があります。私たちは、サイズの測定方法には様々なものがあり、その中には主観的なものもあることを認識しています --- 特に変更の複雑さを考慮する場合には。これが、任意の行数制限を超えて提案された変更を自動で却下するツールを持たない理由です。レビューアは、変更が大きすぎると判断した場合、反発することができます（そして実際にそうしています）。このルールや同様のルールは、コードを作成したりレビューしたりするエンジニアの裁量に委ねられています。しかし、技術的なルールに関しては、実現可能な場合は、技術的に実施することを推奨します。

### エラーチェッカー

言語の使用方法をカバーする多くのルールは、静的解析ツールで強制することができます。実際、2018年半ばにC++ライブラリアンの何人かがC++スタイルガイドを非公式に調査したところ、そのルールのおよそ90％が自動的に検証できると推定されました。エラーチェックツールは、ルールやパターンのセットを受け取り、与えられたコードサンプルが完全に準拠しているかどうかを検証します。自動検証により、適用可能なルールをすべて覚えておくという負担をコード作成者から取り除くことができます。エンジニアは、開発ワークフローに緊密に統合されたアナライザーによるコードレビューの際に表示される違反警告（その多くは修正案を含んでいる）を確認するだけでよいのであれば、ルールを遵守するために必要な労力は最小限に抑えられる。ソースのタグ付けに基づいて非推奨の関数にフラグを立てるツールを使い始めたところ、警告と修正案の両方がその場で表示されるようになり、非推奨のAPIが新たに使用されるという問題が一夜にして解消されました。コンプライアンスのコストを抑えることで、エンジニアが喜んでコンプライアンスに従う可能性が高まります。

私たちは、clang-tidy（C++用）やError Prone（Java用）のようなツールを使用して、ルールを実施するプロセスを自動化しています。このアプローチの詳細については、第20章を参照してください。

私たちが使うツールは、私たちが定義するルールをサポートするために設計され、調整されています。ルールをサポートするツールのほとんどは絶対的なもので、誰もがルールを遵守しなければならないため、誰もがルールをチェックするツールを使用します。しかし、ベストプラクティスをサポートするツールでは、規則に従うことにもう少し柔軟性がある場合、プロジェクトが必要に応じて調整できるように、オプトアウトメカニズムが用意されていることがあります。

### コードフォーマッタ

Googleでは、自動化されたスタイルチェッカーとフォーマッターを使用して、コード内の一貫したフォーマットを実現しています。エンジニアはスタイルチェッカーを実行するだけで、行の長さの問題には興味を示さなくなりました(*13)。毎回同じ方法でフォーマットが行われていれば、コードレビューの際に問題になることはありません。そうすれば、スタイル上の些細な問題を発見し、フラグを立て、修正するために費やしていたレビューサイクルが不要になります。

過去最大のコードベースを管理する中で、人間が行ったフォーマットと、自動化されたツールが行ったフォーマットの結果を観察する機会がありました。平均すると、ロボットの方が人間よりもはるかに優れています。例えば、行列のフォーマットは、汎用のフォーマッタよりも人間の方が上手にできることが多いですね。そうでなくても、自動スタイルチェッカーを使ってコードをフォーマットしても、失敗することはほとんどありません。

コードが送信される前に、サービスはフォーマッタを実行して差分が発生するかどうかをチェックします。コードを投稿する前に、サービスがフォーマッタを実行して差分が出るかどうかをチェックし、差分が出た場合は、コードを修正するためのフォーマッタの実行方法を指示して、投稿を拒否します。Googleのほとんどのコードは、このような投稿前のチェックを受けています。私たちのコードでは、C++にはclang-format、Pythonにはyapfのラッパー、Goにはgofmt、Dartにはdartfmt、そして`BUILD`ファイルにはbuildifierを使用しています。

----

### ケーススタディ：gofmt

Sameer Ajmani

Googleは、2009年11月10日にプログラミング言語「Go」をオープンソースとして公開しました。それ以来、Goはサービスやツール、クラウド基盤、オープンソースソフトウェアを開発するための言語として成長してきました(*14)。

Goのコードに標準的なフォーマットが必要なことは、初日からわかっていました。また、オープンソースのリリース後に標準フォーマットを後付けするのはほぼ不可能だと思っていました。そこで、Goの初期リリースには、Goの標準フォーマットツールであるgofmtを搭載しました。

#### 動機

コードレビューはソフトウェアエンジニアリングのベストプラクティスですが、レビューではフォーマットについての議論に多くの時間が費やされていました。標準フォーマットは誰もが好むものではありませんが、この無駄な時間をなくすには十分なものです(*15)。

フォーマットを標準化することで、機械で編集したコードと人間が編集したコードの区別がつかないような、偽の差分を発生させずにGoのコードを自動的に更新するツールの基礎を築くことができました(*16)。

例えば、2012年にGo 1.0がリリースされるまでの数ヶ月間、Goチームはgofixというツールを使って、1.0以前のGoコードを言語とライブラリの安定版に自動的にアップデートしました。gofmtのおかげで、gofixが作成する差分には、言語やAPIの使い方の変更など、重要な部分だけが含まれていました。これにより、プログラマーはより簡単に変更点を確認し、ツールが行った変更点から学ぶことができるようになりました。

#### インパクト

Go プログラマーは、すべての Go コードが gofmt でフォーマットされていることを期待しています。 gofmt には設定ノブがなく、その動作が変更されることはほとんどありません。主要なエディタや IDE はすべて gofmt を使用しているか、その動作をエミュレートしているため、現存するほぼすべての Go コードは同じフォーマットになっています。当初、Goユーザーは強制された標準に不満を持っていましたが、今ではGoを好きになった多くの理由の一つとして、しばしばgofmtを挙げています。見慣れないGoコードを読む場合でも、フォーマットは親しみやすいものです。

何千ものオープンソースパッケージがGoコードを読み書きしています(*17)。すべてのエディタやIDEがGoフォーマットに同意しているため、Goツールはポータブルで、コマンドラインを介して新しい開発環境やワークフローに簡単に統合できます。

#### 改造

2012年、Googleではすべての`BUILD`ファイルを新しい標準フォーマッタを使って自動的にフォーマットすることにしました。`buildifier`です。`BUILD`ファイルには、GoogleのビルドシステムであるBlazeでGoogleのソフトウェアをビルドするためのルールが書かれています。標準的な`BUILD`フォーマットがあれば、GoツールがGoファイルを編集するように、`BUILD`ファイルのフォーマットを崩すことなく自動的に編集するツールを作ることができます。

Googleの200,000個のBUILDファイルの再フォーマットを様々なコードオーナーに受け入れてもらうのに、1人のエンジニアが6週間かかり、その間に毎週1,000個以上の新しい`BUILD`ファイルが追加された。大規模な変更を行うためのGoogleの初期のインフラは、この作業を大きく加速させた。(第22章参照)

## 結論

どのような組織であっても、特にGoogleのエンジニアリング部隊のような大規模な組織では、ルールによって複雑性を管理し、保守可能なコードベースを構築することができます。ルールを共有することで、エンジニアリングプロセスがスケールアップし、成長し続けることができ、コードベースと組織の両方を長期的に持続可能なものにすることができます。


## TL;DRs

- ルールとガイダンスは、時間と規模に対する耐性をサポートすることを目的とすべきである。
- ルールを調整できるように、データを把握する。
- すべてをルール化するべきではない。
- 一貫性が重要である。
- 可能であれば施行を自動化する。







-----

1 多くのスタイルガイドには外部版があり、https://google.github.io/styleguide で見ることができます。本章では、これらのガイドから多くの例を引用しています。
2 ここではツールが重要です。多すぎる」という指標は、実際に使用されているルールの数ではなく、エンジニアが覚える必要のある数です。例えば、clang-formatが登場する前の古い時代には、膨大な数のフォーマットルールを覚えておく必要がありました。これらのルールがなくなったわけではありませんが、現在のツールを使えば、ルールを守るためのコストは劇的に減少します。誰かが任意の数のフォーマットルールを追加しても、ツールが代わりにやってくれるので、誰も気にしないというところまで来ています。
3 Googleのオフィスを15カ所ほど訪問した際に行った、現実世界での比較についてはH.Wright氏による。
4 「チャンキング」とは、情報を個別に記録するのではなく、意味のある「チャンク」にまとめる認知プロセスのこと。例えば、チェスの熟練者は、個々の駒の位置ではなく、駒の構成について考える。
5 参照 4.2 ブロックインデント。+4.2 ブロックのインデント：スペース2個、スペースとタブ、4.4 列数の制限：100、行の長さを参照してください。
6 constの使用例。
7 Starlarkで実装されたBUILDファイルのスタイルフォーマットはbuildifierで適用されます。https://github.com/ bazelbuild/buildtoolsを参照してください。
8 「命名規則の例外」を参照してください。例として、オープンソースの Abseil ライブラリでは、標準の型を置き換えるための型に snake_case 命名を使用しています。https://github.com/abseil/abseil- cpp/blob/master/absl/utility/utility.h で定義されている型をご覧ください。これらは C++14 標準型の C++11 実装であるため、Google が好むキャメルケース形式ではなく、標準で好まれる snake_case 形式が使用されています。
9 「生成されたコード：ほとんどが除外されています」を参照。
10 https://google.github.io/styleguide/cppguide.html#Comments,http://google.github.io/styleguide/pyguide#38- comments-and-docstrings、および複数の言語が一般的なコメントルールを定義している https://google.github.io/styleguide/javaguide.html#s7-javadoc を参照。
11 このような議論は、実際には単なるバイクシェディングであり、パーキンソンのつまらない法則の実例です。
12 https://abseil.io/tips には、最も人気のあるヒントの一部が掲載されています。
15 Robert Griesemer氏の2015年の講演「The Cultural Evolution of gofmt」では、goや他の言語におけるgofmtの動機、設計、影響について詳しく説明されています。
16 ラス・コックスは2009年に、gofmtは変更の自動化について説明しています。「つまり、プログラム操作ツールのすべてのハードパーツが使われるのを待っているのです。gofmtスタイル」を受け入れることに同意することは、限られたコード量でそれを可能にする部分である。"
17 GoのASTとフォーマットパッケージには、それぞれ何千ものインポーターがあります。


