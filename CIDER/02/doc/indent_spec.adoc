= インデント仕様

== 概要

インデント指定は、より複雑なマクロ（または関数）の複雑なインデントルールを指定するために使用できます。これは var メタデータの `:style/indent` キーの値として提供されます。

[source,clojure]
----
(defmacro with-in-str
  "[DOCSTRING]"
  {:style/indent 1}
  [s & body]
  ...cut for brevity...)
----

このインデントには3つの形式がある：

* 無し、つまり_""通常の関数呼び出しのようにインデントする"_。
* 整数またはキーワード `x` 、これはリスト `[x]` の省略形です。
* リスト、つまりこの関数/マクロはいくつかの特別な引数を取り、それ以外の引数はすべて特別な引数ではありません。
** 最初の要素* は、引数が sexp に対してどのようにインデントされているかを表します。それは次のようになります：
*** 整数 `n` は、この関数/マクロが `n` 個の特別な引数を取ることを示します(この意味については後述します)。
  *** キーワード `:form` は、_"すべての引数は関数のフォームのようにインデントされる"_ を意味します。
  *** キーワード `:defn` は、_"1行目にないすべての引数は特殊でない"_ を意味します。
** 以下の*各要素*は、それ自体がインデント仕様であり、この要素と同じ位置にある引数の内部構造を詳述しています。つまり、引数がフォームである場合、この要素はそのフォームを内部的にどのようにインデントするかを指定します（フォームでない場合は、この指定は関係ありません）。
 ** 関数/マクロがリストの要素数よりも多くの引数を持つ場合、リストの最後の要素が残りのすべての引数に適用されます。

'''

== 例

ここでは、`clojure.core` からいくつかのよく知られたマクロとフォームを使用したいくつかの例を紹介します。明らかに、これらは `clojure-mode` によって既に知られているので、指定する必要はありません。これらは、独自のマクロやサードパーティのライブラリにあるマクロのインデント仕様を書くときのガイドとなる単なる例です。

非常に単純な例として `do` フォームがあります。引数はすべて同じインデントで、どれも特別なものではありません。そのため、インデント指定は単純に `[0]` 、略して `0` となります。

[source,clojure]
----
(do
  (something)
  (quick))

(do (whatever)
    (you)
    (want))
----

単純さにこだわって、`when-let*` マクロには特別な引数（バインディングベクター）が1つだけあり、特別な内部構造はありません。そのため、インデントの指定は `1` だけです（これは `[1]` の省略形です）。

'''

もっと洗練されたものを見てみよう。もし `clojure-mode` が使用する `defrecord` インデント指定が `[2 :form :form [1]]` である場合。これはこう言っています：

* `defrecord`には2つの特別な引数（名前とarglist）があります。
* 最初の2つの引数は特別な内部構造を持っていません。
* 残りのすべての引数は `[1]` の内部インデント仕様を持っています（つまり、arglistだけが特別にインデントされ、残りは本体です）。

[source,clojure]
----
(defrecord Thing [a]
  FileNameMap
  (getContentTypeFor [_ file-name]
    (str a "-" file-name))
  Object
  (toString [_]
    "My very own thing!!"))
----

さらに複雑なものには `letfn` は `+[1 [[:defn]] :form]+` です。これは次のことを意味する。

* `letfn` は1つの特別な引数（バインディングリスト）を持つ。
* 最初の引数のインデント指定は `+[[:defn]]+` であり、これは最初の引数の内側のすべてのフォームのインデント指定が `+[:defn]+` であることを意味します。
* 第2引数、そして他のすべての引数は通常のフォームである。

[source,clojure]
----
(letfn [(twice [x]
          (* x 2))
        (six-times [y]
          (* (twice y) 3))]
  (six-times 15))
----

== 特殊引数

多くのマクロは、いくつかの "特殊 "引数を持ち、その後に任意の数の "非特殊 "引数（ボディと呼ばれることもある）が続く。”非特殊"引数には小さなインデント（通常はスペース2個）がある。特殊引数は通常マクロ名と同じ行にありますが、必要な場合にはインデントを加えて別の行に置きます。

例えば、`defrecord`には2つの特別引数があり、以下のようにインデントされます：

[source,clojure]
----
(defrecord TheNameOfTheRecord
    [a pretty long argument list]
  SomeType
  (assoc [_ x]
    (.assoc pretty x 10)))
----

もう1つの方法を紹介しよう：

[source,clojure]
----
(defrecord TheNameOfTheRecord
           [a pretty long argument list]
  SomeType
  (assoc [_ x]
    (.assoc pretty x 10)))
----

_インデント仕様のポイントは、いくつのスペースを使うかを指定することでは *ありません*。_

要は、"defrecord has *2* special arguments "と言って、特別な引数とそうでない引数にいくつのスペースを使うかについて、エディターとユーザーが合意すればいいのです。

== 内部インデント

問題はもう少し深い。`defrecord`の最後の引数に注目してほしい。通常の関数形式は内部的に次のようにインデントされる：

[source,clojure]
----
(assoc [_ x]
       (.assoc pretty x 10))
----

しかし、これは通常の関数呼び出しではなく、関数定義である。そこで、この形式が内部的に1つの特別な引数（arglistベクトル）を持つことを指定し、このようにインデントされるようにしたい：

[source,clojure]
----
(assoc [_ x]
  (.assoc pretty x 10))
----

これはインデント仕様でも同様だ。2つ目以降の各引数について、それがフォームである場合は、内部的に1つの特別な引数を持つものとしてインデントするように指定できる。

== インデントの推論

cider-nrepl 0.32から、インデントが推論されるようになり、指定する必要がなくなったことは注目に値します。

そのためには、慣用的なClojureマクロを書くことが最も推奨されます：

* あなたのマクロがclojure.coreのものと類似している場合、同じ名前を付けます。
  * 例えば、 `my-defprotocol`ではなく、 `defprotocol`というマクロ名を付けます。
    *  ( これはClojureの名前空間システムの意図的な使用法です)
* あなたのマクロがclojure.coreのものに類似している場合、そのすべてのarglistをミラーします。
  * 引数の正確な名前は重要ではありません。
  * 一致しなければならないのは、arglistの構造です。
  * 与えられたargを名前として表すか、構造化されていないマップ/ベクトルとして 表現するかは問題ではありません。
* clojure.coreカスタムを使用するように、'body'argsに名前を付けます。
  * good: `[opts body]`
  * bad: `[opts etc]`
  * good: `[& body]`
  * bad: `[& etc]`
  * 他の一般的に受け入れられている名前には `forms` や `clauses` などがあります。

確かに、これらの提案に従わなければならないわけではありません -- CIDERが生成するインデントがより良いものになるため、便宜上そうしているだけです。

他のツールも最終的にはこれらとまったく同じ推論ルールを使うかもしれません。
