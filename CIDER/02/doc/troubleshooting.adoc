= トラブル・シューティング
:experimental:

万が一問題に遭遇した場合、問題を診断するのに役立つヒントをいくつか紹介します。

一般的に、エラー時にバックトレースを吐き出すようにEmacsを設定するのは悪いことではありません（ `+*Messages*+`バッファにエラーを記録するだけではありません）。この動作は kbd:[M-x] `toggle-debug-on-error` を使って切り替えることができます。

== CIDERコマンドのデバッグ

Emacsには超強力なビルトイン  http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html[Emacs Lispデバッガ] があり、これを使うことはあらゆる種類の問題を診断する最良の方法です。

TIP: デバッガの使い方に関する https://www.youtube.com/watch?v=odkYXXYOxpo[すばらしい実践講座] があります。

あるコマンドをデバッグするには、以下のことをする必要があります：

* デバッグしたいコマンドの名前を知る（例えば、 kbd:[C-h k] を使って、どのコマンドがあるキーバインドに関連付けられ ているかを調べる）。
* コマンドのソースを見つける(例えば kbd:[M-x] `find-function` kbd:[RET] `function-name` を使う)。
* 関数の本文中でkbd:[C-u C-M-x]を押す。
* もう一度コマンドを実行する。

この時点でデバッガーにドロップされるので、問題を見つけるまで前進してください。

== CIDERコマンドのプロファイリング

Emacsには https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html[ビルトイン・プロファイラ] が付属しています。使い方はとても簡単です：

. kbd:[M-x] `profiler-start` で起動します。
. いくつかのコマンドを起動します。
. kbd:[M-x] `profiler-report` でレポートを取得する。

TIP: プロファイリングの結果を誰かと共有する場合は、kbd:[C-x C-w]でレポートバッファをファイルに保存しておくとよいでしょう。

== nREPLとの通信のデバッグ

時々、CIDERとnREPLの間で交換されたメッセージを検査するのは良い考えかもしれない。CIDERには次のような簡単なメッセージログがある：

  (-->
    id         "16"
    op         "eval"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:42.963936000"
    code       "(in-ns 'nrepl.completion)"
  )
  (<--
    id         "16"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:43.027347000"
    ns         "nrepl.completion"
    value      "#namespace[nrepl.completion]"
  )
  (<--
    id         "16"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:43.195358000"
    status     ("done")
  )

これはリクエストマップ（`+-->+`でマーク）とレスポンスマップ（`+<--+`でマーク）を表すCIDERの方法です。

nREPL メッセージのロギングはデフォルトでは有効になっていない。有効にするには `nrepl-log-messages` を `t` に設定する。また、kbd:[M-x] `nrepl-toggle-message-logging` を使って、現在のEmacsセッション内で一時的にロギングを有効/無効にすることもできます。メッセージロギングを有効にするとパフォーマンスに影響があることに注意してください。

メッセージログは `+*nrepl-messages repl-info*+` バッファにあります。アクティブな REPL ごとに1つのバッファがあります。

TIP: kbd:[C-c M-s m]を押すと関連するメッセージバッファに素早くジャンプできます。

== よく遭遇する問題（とその解決方法）

=== REPL が起動しない

CIDER のバージョンが `cider-nrepl` のバージョンと合っていることを確認してください。CIDER 関連のエラーがないか `+*Messages*+` バッファの内容をチェックしてください。また、`+*nrepl-messages*+` にある CIDER と nREPL の間で渡される nREPL メッセージもチェックしてください。そこで有用なものが何も見つからなければ、いよいよ大きな武器を持ち出す時だ。

==== REPL initのデバッグ

CIDERのREPLのinitをデバッグするには、そのエントリーポイントの1つにフックするのが良い。`cider-make-repl` にブレークポイントを追加してください（kbd:[C-u C-M-x], そのボディの中にある間に）。次にCIDERを起動するときにデバッガに落とされるので、問題を見つけるまで前に進むことができる。

=== バッファ`+*nrepl-messages*+`がありません。

nREPL メッセージのロギングはデフォルトでは有効になっていない。有効にするには `nrepl-log-messages` を `t` に設定する。あるいは、kbd:[M-x] `nrepl-toggle-message-logging` を使って、現在のEmacsセッション内で一時的にロギングを有効/無効にすることもできます。メッセージのロギングを有効にするとパフォーマンスに影響を与える可能性があることに注意してください。

=== `cider-debug` が "`failed to instrument ...`" と文句を言う。

REPL バッファで、以下を実行する。

 your.namespace> (ns cider.nrepl.middleware.util.instrument)
 cider.nrepl.middleware.util.instrument> (def verbose-debug true)

これにより、式をデバッグしようとしたときに（例えばkbd:[C-u C-M-x]で）、CIDERがREPLバッファに広範な情報を表示します。 https://github.com/clojure-emacs/cider-nrepl/issues/new[File an issue] をクリックして、この情報をコピーしてください。

=== ある関数がURLを返すときにREPLが吹き飛ぶ

おそらく、`content-type`ミドルウェアに何らかの問題が発生しているのでしょう。一般的に、stracktraceを調べれば簡単に確認できる：

[source,clojure]
----
user> (java.net.URI. "mailto:foo@bar.com")
#object[java.net.URI 0x36966ca2 "mailto:foo@bar.com"]ERROR: Unhandled REPL handler exception processing message {:op slurp, :url mailto:foo@bar.com, :session 69c4d8e1-7bb4-45ad-8075-d21995fd50ab, :id 1579}
java.net.UnknownServiceException: protocol doesn't support input
	at java.base/java.net.URLConnection.getInputStream(URLConnection.java:840)
	at cider.nrepl.middleware.slurp$slurp_url_to_content_PLUS_body.invokeStatic(slurp.clj:100)
	at cider.nrepl.middleware.slurp$slurp_url_to_content_PLUS_body.invoke(slurp.clj:82)
	at cider.nrepl.middleware.slurp$handle_slurp.invokeStatic(slurp.clj:117)
	at cider.nrepl.middleware.slurp$handle_slurp.invoke(slurp.clj:109)
----

ミドルウェアを無効にするには、次のようにする：

[source,lisp]
----
(setq cider-repl-use-content-types t)
----

CIDER 0.25からはデフォルトで無効になっている。

=== フリーズとロックのデバッグ

CIDERコマンドが（バグや設定の問題などで）しばらくハングアップすることがある。このような問題は非常に厄介ですが、デバッグは比較的簡単です。このような場合に取ることのできるいくつかのステップを紹介しよう：

* kbd:[M-x] `toggle-debug-on-quit` を実行する。
* 問題を再現する
* kbd:[C-g] をハングしてから10秒前後に実行する。

これにより、関数の引数を含む関数スタック全体のバックトレースが表示されます。これで何が起こっているのか（少なくとも何が要求されているのか）がわかるはずだ。

=== より新しいnREPLを使用しなければならないという警告

CIDERが正しく動作するためには、現在少なくともnREPL 0.6が必要です。nREPLはLeiningenとBootにバンドルされているため、時折、それらから提供されるバージョンを上書きする必要があるかもしれません（古いバージョンのLeiningenを使わざるを得ない場合や、必要なnREPLバージョンをバンドルしているリリースがまだない場合など）。Leiningen のユーザは `profiles.clj` にこれを追加することで、適切な依存関係を強制することができます：

[source,clojure]
----
{:repl {:dependencies [[nrepl/nrepl "x.y.z"]]}}
----

Boot でも手順はほぼ同じだ。

IMPORTANT: 新しい nREPL 依存関係を `:plugins` の代わりに `:dependencies` キーに追加してください（ここに `cider-nrepl` Lein プラグインがあります）。これはよくある間違いです。

一般的に、CIDERでは最新のnREPLを使うことを勧められる。ほとんどのリリースでバグが修正されているからだ。

=== CIDERアップデート後にclojure-...関数が見つからない

おそらく、`clojure-mode`を更新せずにCIDERを更新したのでしょう。

CIDERは`clojure-mode`に依存しており、常に一緒に更新する必要があります。最新のCIDERバージョンは、最新の`clojure-mode`バージョンにのみ存在する機能に依存しているかもしれません。

=== `package.el` を使ってCIDERをアップグレードしたら壊れた。

ビルトインパッケージマネージャーは完璧ではないので、時々混乱します。 もしアップデートしたばかりでエラーに遭遇した場合は、issueを開く前に以下のことを試してみてください： `.emacs.d/elpa`ディレクトリに入り、CIDERに関連するフォルダをすべて削除し、Emacsを再起動してから、足りないパッケージを再インストールしてください。 ここでの順番は重要です。

=== `package.el` を使ってCIDERをアップグレードしましたが、何も変わりませんでした。

Emacsは新しいファイルを読み込まず、ディスクにインストールするだけです。 変更の効果を見るにはEmacsを再起動する必要があります。

=== CIDER が `cider-nrepl` バージョンに文句を言う

これは REPL バッファが起動したときに表示される警告で、通常は次のようになります：

____
*WARNING:* CIDER 0.18.0 requires cider-nrepl x.y.z, but you're currently using cider-nrepl a.b.c. Some functionality may not work properly!
____

ここで `a.b.c` は `0.17.0` のような実際のバージョンかもしれないし、`not installed` や `nil` かもしれない。 これに対する解決策は、何を見るか、何をしているかによる。

==== `X.X.X` のような数字が表示され、`cider-connect` で REPL を開始しています。

あなたのプロジェクトは cider-nrepl ミドルウェアに間違ったバージョンを指定しています。ミドルウェアのセットアップ" セクションの  xref:basics/middleware_setup.adoc[instructions] を参照してください。

==== `not installed` または `nil` と表示され、`cider-connect` を使って REPL を起動しています。

`cider-connect` を使用するには、プロジェクトに cider-nrepl ミドルウェアを追加する必要があります。「ミドルウェアのセットアップ」セクションの  xref:basics/middleware_setup.adoc[instructions] を参照してください。

==== You see `not installed` or `nil`, and you're starting the REPL with `cider-jack-in`

* Do `C-h v cider-inject-dependencies-at-jack-in`, and check that this variable is non-nil.
* Make sure your project depends on at least Clojure `1.7.0`.
* If you use Leiningen, make sure your `lein --version` is at least `2.9.0`.
* If you use Boot and you've changed `cider-boot-parameters`, that's probably the cause.

If the above doesn't work, you can try specifying the cider-nrepl middleware manually, as per the xref:basics/middleware_setup.adoc[instructions] in the "Middleware Setup" section.

==== You see a number like `X.X.X`, and you're starting the REPL with `cider-jack-in`

This means you're manually adding the cider-nrepl middleware in your project, but you shouldn't do that because `cider-jack-in` already does that for you. Look into the following files, and ensure you've removed all references to `cider-nrepl` and `nrepl`: `project.clj`, `build.boot`, `~/.lein/profiles.clj` and `~/.boot/profile.boot`.

=== I get some error related to refactor-nrepl on startup

The package `clj-refactor` would normally inject its own middleware on `cider-jack-in`, just as CIDER itself would. Usually that's not a problem, as long as you're using compatible versions of CIDER and `clj-refactor`, but if you're getting some error probably that's not the case. You've got two options to solve this:

* Use compatible versions of the two projects (e.g. their most recent snapshots or most recent stable releases)
* Disable the `clj-refactor` middleware injection:

[source,lisp]
----
(setq cljr-inject-dependencies-at-jack-in nil)
----

=== Off-by-one column numbers

Emacs and Clojure differ in their indexing of column numbers -- Emacs starts counting from 0 while Clojure starts from 1. Accordingly, the `cider-nrepl` middleware uses 1-based indexing and all conversions to 0-based indexing should be handled client-side. See https://github.com/clojure-emacs/cider/issues/2852.

=== Empty Java stacktraces

Occasionally the JVM might remove some stack frames, resulting in no stacktrace information being displayed in CIDER's error buffer.

That's caused by an JVM optimization (`OmitStackTraceInFastThrow`, enabled by default), which optimizes "built-in" exceptions that are thrown frequently enough to be cached and have no stacktrace.

You can turn off the optimization by adding the JVM flag `-XX:-OmitStackTraceInFastThrow` to whatever command you're using to start nREPL.

In particular, by adding it to a `deps.edn` file under an alias (eg. `:dev`)
[source,lisp]
---
{:aliases
 {:dev
  {:jvm-opts ["-XX:-OmitStackTraceInFastThrow"]
  ...}}}
---

Or by customising the jack-in options.
[source,lisp]
---
(setq cider-clojure-cli-parameters "-J-XX:-OmitStackTraceInFastThrow")
---

NOTE: Leiningen disables `OmitStackTraceInFastThrow` by default.

=== Errors Related to enrich-classpath

If you get any errors related to `enrich-classpath` when doing `cider-jack-in`, you can disable the `enrich-classpath` integration like this:

[source,lisp]
----
(setq cider-enrich-classpath nil)
----

=== Navigation to JDK sources doesn't work

Firstly, make sure that you are using enrich-classpath. `cider-enrich-classpath` should be truthy.  If you are launching your own repl process, it should have the enrich-classpath Leiningen plugin or `clojure` wrapper.

If you are on Linux and still can't navigate to the source of built-in methods like `.toUpperCase` you probably haven't installed the JDK sources. While you're at it - it's good to install the JDK's Javadocs as well. On Debian/Ubuntu:

[source,shell]
----
$ sudo apt install openjdk-17-source openjdk-17-doc
----

On Red Hat/Fedora/CentOS:

[source,shell]
----
$ sudo dnf install java-17-openjdk-src java-17-openjdk-javadoc
----

On Guix:

[source,shell]
----
$ guix package -i openjdk:jdk
----

NOTE: On Windows and macOS the JDK source code is bundled with the JDK.

=== Pressing `RET` in the REPL does not evaluate forms

Are you a Paredit user? Have you enabled for the REPL buffers?

In recent versions of Paredit (25+), `RET` is bound to `paredit-RET`. This can cause unexpected behaviour in the repl when `paredit-mode` is enabled, e.g. it appears to hang after hitting `RET` instead of evaluating the last form.

You can disable this Paredit behaviour by adding the following to your `init.el`:

[source,lisp]
----
(define-key paredit-mode-map (kbd "RET") nil)
----

=== Interactions fail with `No linked CIDER sessions`

If any interactive feature is being shortcircuited for you with the message `No linked CIDER sessions`, that's due to one of the following reasons:

* You're evaluating code in a buffer from a project that hasn't started a repl
  * You can fix this by switching instead to a project that has.
  * You can also, simply, start a repl in the current project.
* There's a bug in the CIDER/Sesman integration
  * Session linking generally works by determining whether the current buffer is related to the classpath of some REPL.
  * You can obtain debug info echoed to the `*messages*` buffer by running `M-x cider-debug-sesman-friendly-session-p` on the problematic buffer.
    * By reading it, you might be able to determine why CIDER failed to see the relationship between `(buffer-filename)` and the classpath.
    * Feel free to created a detailed GitHub issue including this information.
