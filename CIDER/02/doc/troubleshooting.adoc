= トラブル・シューティング
:experimental:

万が一問題に遭遇した場合、問題を診断するのに役立つヒントをいくつか紹介します。

一般的に、エラー時にバックトレースを吐き出すようにEmacsを設定するのは悪いことではありません（ `+*Messages*+`バッファにエラーを記録するだけではありません）。この動作は kbd:[M-x] `toggle-debug-on-error` を使って切り替えることができます。

== CIDERコマンドのデバッグ

Emacsには超強力なビルトイン  http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html[Emacs Lispデバッガ] があり、これを使うことはあらゆる種類の問題を診断する最良の方法です。

TIP: デバッガの使い方に関する https://www.youtube.com/watch?v=odkYXXYOxpo[すばらしい実践講座] があります。

あるコマンドをデバッグするには、以下のことをする必要があります：

* デバッグしたいコマンドの名前を知る（例えば、 kbd:[C-h k] を使って、どのコマンドがあるキーバインドに関連付けられ ているかを調べる）。
* コマンドのソースを見つける(例えば kbd:[M-x] `find-function` kbd:[RET] `function-name` を使う)。
* 関数の本文中でkbd:[C-u C-M-x]を押す。
* もう一度コマンドを実行する。

この時点でデバッガーにドロップされるので、問題を見つけるまで前進してください。

== CIDERコマンドのプロファイリング

Emacsには https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html[ビルトイン・プロファイラ] が付属しています。使い方はとても簡単です：

. kbd:[M-x] `profiler-start` で起動します。
. いくつかのコマンドを起動します。
. kbd:[M-x] `profiler-report` でレポートを取得する。

TIP: プロファイリングの結果を誰かと共有する場合は、kbd:[C-x C-w]でレポートバッファをファイルに保存しておくとよいでしょう。

== nREPLとの通信のデバッグ

時々、CIDERとnREPLの間で交換されたメッセージを検査するのは良い考えかもしれない。CIDERには次のような簡単なメッセージログがある：

  (-->
    id         "16"
    op         "eval"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:42.963936000"
    code       "(in-ns 'nrepl.completion)"
  )
  (<--
    id         "16"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:43.027347000"
    ns         "nrepl.completion"
    value      "#namespace[nrepl.completion]"
  )
  (<--
    id         "16"
    session    "eb3ef563-86ec-4d9e-9fa8-a56ce0e0f0b0"
    time-stamp "2020-03-15 16:01:43.195358000"
    status     ("done")
  )

これはリクエストマップ（`+-->+`でマーク）とレスポンスマップ（`+<--+`でマーク）を表すCIDERの方法です。

nREPL メッセージのロギングはデフォルトでは有効になっていない。有効にするには `nrepl-log-messages` を `t` に設定する。また、kbd:[M-x] `nrepl-toggle-message-logging` を使って、現在のEmacsセッション内で一時的にロギングを有効/無効にすることもできます。メッセージロギングを有効にするとパフォーマンスに影響があることに注意してください。

メッセージログは `+*nrepl-messages repl-info*+` バッファにあります。アクティブな REPL ごとに1つのバッファがあります。

TIP: kbd:[C-c M-s m]を押すと関連するメッセージバッファに素早くジャンプできます。

== よく遭遇する問題（とその解決方法）

=== REPL が起動しない

CIDER のバージョンが `cider-nrepl` のバージョンと合っていることを確認してください。CIDER 関連のエラーがないか `+*Messages*+` バッファの内容をチェックしてください。また、`+*nrepl-messages*+` にある CIDER と nREPL の間で渡される nREPL メッセージもチェックしてください。そこで有用なものが何も見つからなければ、いよいよ大きな武器を持ち出す時だ。

==== REPL initのデバッグ

CIDERのREPLのinitをデバッグするには、そのエントリーポイントの1つにフックするのが良い。`cider-make-repl` にブレークポイントを追加してください（kbd:[C-u C-M-x], そのボディの中にある間に）。次にCIDERを起動するときにデバッガに落とされるので、問題を見つけるまで前に進むことができる。

=== バッファ`+*nrepl-messages*+`がありません。

nREPL メッセージのロギングはデフォルトでは有効になっていない。有効にするには `nrepl-log-messages` を `t` に設定する。あるいは、kbd:[M-x] `nrepl-toggle-message-logging` を使って、現在のEmacsセッション内で一時的にロギングを有効/無効にすることもできます。メッセージのロギングを有効にするとパフォーマンスに影響を与える可能性があることに注意してください。

=== `cider-debug` が "`failed to instrument ...`" と文句を言う。

REPL バッファで、以下を実行する。

 your.namespace> (ns cider.nrepl.middleware.util.instrument)
 cider.nrepl.middleware.util.instrument> (def verbose-debug true)

これにより、式をデバッグしようとしたときに（例えばkbd:[C-u C-M-x]で）、CIDERがREPLバッファに広範な情報を表示します。 https://github.com/clojure-emacs/cider-nrepl/issues/new[File an issue] をクリックして、この情報をコピーしてください。

=== ある関数がURLを返すときにREPLが吹き飛ぶ

おそらく、`content-type`ミドルウェアに何らかの問題が発生しているのでしょう。一般的に、stracktraceを調べれば簡単に確認できる：

[source,clojure]
----
user> (java.net.URI. "mailto:foo@bar.com")
#object[java.net.URI 0x36966ca2 "mailto:foo@bar.com"]ERROR: Unhandled REPL handler exception processing message {:op slurp, :url mailto:foo@bar.com, :session 69c4d8e1-7bb4-45ad-8075-d21995fd50ab, :id 1579}
java.net.UnknownServiceException: protocol doesn't support input
	at java.base/java.net.URLConnection.getInputStream(URLConnection.java:840)
	at cider.nrepl.middleware.slurp$slurp_url_to_content_PLUS_body.invokeStatic(slurp.clj:100)
	at cider.nrepl.middleware.slurp$slurp_url_to_content_PLUS_body.invoke(slurp.clj:82)
	at cider.nrepl.middleware.slurp$handle_slurp.invokeStatic(slurp.clj:117)
	at cider.nrepl.middleware.slurp$handle_slurp.invoke(slurp.clj:109)
----

ミドルウェアを無効にするには、次のようにする：

[source,lisp]
----
(setq cider-repl-use-content-types t)
----

CIDER 0.25からはデフォルトで無効になっている。

=== フリーズとロックのデバッグ

CIDERコマンドが（バグや設定の問題などで）しばらくハングアップすることがある。このような問題は非常に厄介ですが、デバッグは比較的簡単です。このような場合に取ることのできるいくつかのステップを紹介しよう：

* kbd:[M-x] `toggle-debug-on-quit` を実行する。
* 問題を再現する
* kbd:[C-g] をハングしてから10秒前後に実行する。

これにより、関数の引数を含む関数スタック全体のバックトレースが表示されます。これで何が起こっているのか（少なくとも何が要求されているのか）がわかるはずだ。

=== より新しいnREPLを使用しなければならないという警告

CIDERが正しく動作するためには、現在少なくともnREPL 0.6が必要です。nREPLはLeiningenとBootにバンドルされているため、時折、それらから提供されるバージョンを上書きする必要があるかもしれません（古いバージョンのLeiningenを使わざるを得ない場合や、必要なnREPLバージョンをバンドルしているリリースがまだない場合など）。Leiningen のユーザは `profiles.clj` にこれを追加することで、適切な依存関係を強制することができます：

[source,clojure]
----
{:repl {:dependencies [[nrepl/nrepl "x.y.z"]]}}
----

Boot でも手順はほぼ同じだ。

IMPORTANT: 新しい nREPL 依存関係を `:plugins` の代わりに `:dependencies` キーに追加してください（ここに `cider-nrepl` Lein プラグインがあります）。これはよくある間違いです。

一般的に、CIDERでは最新のnREPLを使うことを勧められる。ほとんどのリリースでバグが修正されているからだ。

=== CIDERアップデート後にclojure-...関数が見つからない

おそらく、`clojure-mode`を更新せずにCIDERを更新したのでしょう。

CIDERは`clojure-mode`に依存しており、常に一緒に更新する必要があります。最新のCIDERバージョンは、最新の`clojure-mode`バージョンにのみ存在する機能に依存しているかもしれません。

=== `package.el` を使ってCIDERをアップグレードしたら壊れた。

ビルトインパッケージマネージャーは完璧ではないので、時々混乱します。 もしアップデートしたばかりでエラーに遭遇した場合は、issueを開く前に以下のことを試してみてください： `.emacs.d/elpa`ディレクトリに入り、CIDERに関連するフォルダをすべて削除し、Emacsを再起動してから、足りないパッケージを再インストールしてください。 ここでの順番は重要です。

=== `package.el` を使ってCIDERをアップグレードしましたが、何も変わりませんでした。

Emacsは新しいファイルを読み込まず、ディスクにインストールするだけです。 変更の効果を見るにはEmacsを再起動する必要があります。

=== CIDER が `cider-nrepl` バージョンに文句を言う

これは REPL バッファが起動したときに表示される警告で、通常は次のようになります：

____
*WARNING:* CIDER 0.18.0 requires cider-nrepl x.y.z, but you're currently using cider-nrepl a.b.c. Some functionality may not work properly!
____

ここで `a.b.c` は `0.17.0` のような実際のバージョンかもしれないし、`not installed` や `nil` かもしれない。 これに対する解決策は、何を見るか、何をしているかによる。

==== `X.X.X` のような数字が表示され、`cider-connect` で REPL を開始しています。

あなたのプロジェクトは cider-nrepl ミドルウェアに間違ったバージョンを指定しています。ミドルウェアのセットアップ" セクションの  xref:basics/middleware_setup.adoc[instructions] を参照してください。

==== `not installed` または `nil` と表示され、`cider-connect` を使って REPL を起動しています。

`cider-connect` を使用するには、プロジェクトに cider-nrepl ミドルウェアを追加する必要があります。「ミドルウェアのセットアップ」セクションの  xref:basics/middleware_setup.adoc[instructions] を参照してください。

==== あなたは `not installed` または `nil` と表示され、`cider-jack-in` で REPL を開始しています。

* `C-h v cider-inject-dependencies-at-jack-in` を実行して、この変数が `nil` でないことを確認してください。
* プロジェクトが少なくとも Clojure `1.7.0` に依存していることを確認してください。
* Leiningen を使用している場合、 `lein --version` が少なくとも `2.9.0` であることを確認してください。
* Boot を使っていて、`cider-boot-parameters` を変更したのなら、おそらくそれが原因です。

上記がうまくいかない場合は、"Middleware Setup" セクションの  xref:basics/middleware_setup.adoc[instructions] にあるように、手動で cider-nrepl ミドルウェアを指定してみてください。

==== You see a number like `X.X.X`, and you're starting the REPL with `cider-jack-in`

This means you're manually adding the cider-nrepl middleware in your project, but you shouldn't do that because `cider-jack-in` already does that for you. Look into the following files, and ensure you've removed all references to `cider-nrepl` and `nrepl`: `project.clj`, `build.boot`, `~/.lein/profiles.clj` and `~/.boot/profile.boot`.

=== 起動時に refactor-nrepl に関するエラーが発生します。

パッケージ `clj-refactor` は通常、CIDER 自身がそうであるように、`cider-jack-in` で自身のミドルウェアをインジェクトします。通常、CIDER と `clj-refactor` の互換性のあるバージョンを使っている限り、それは問題ではありません。これを解決するには2つの選択肢があります：

* 2つのプロジェクトの互換性のあるバージョンを使う。(例えば、最新のスナップショットや最新の安定リリース)
* ミドルウェア `clj-refactor` インジェクションを無効にする：

[source,lisp]
----
(setq cljr-inject-dependencies-at-jack-in nil)
----

=== カラム番号の1つ違い

Emacs と Clojure はカラム番号のインデックス付けが異なります -- Emacs は 0 からカウントを開始しますが、Clojure は 1 からカウントを開始します。したがって、`cider-nrepl` ミドルウェアは 1 ベースのインデックス付けを使用し、0 ベースのインデックス付けへの変換はすべてクライアントサイドで処理する必要があります。https://github.com/clojure-emacs/cider/issues/2852 を参照してください。

=== 空のJavaスタックトレース

時折、JVMがいくつかのスタックフレームを削除し、CIDERのエラーバッファにスタックトレース情報が表示されなくなることがあります。

これはJVMの最適化(`OmitStackTraceInFastThrow`、デフォルトで有効)によるもので、キャッシュされるのに十分な頻度でスローされ、スタックトレースを持たない「組み込み」例外を最適化します。

JVMフラグ `-XX:-OmitStackTraceInFastThrow` をnREPLを起動するコマンドに追加することで最適化をオフにすることができる。

特に、`deps.edn` ファイルにエイリアス(例: `:dev`)で追加します。

[source,lisp]
---
{:aliases
 {:dev
  {:jvm-opts ["-XX:-OmitStackTraceInFastThrow"]
  ...}}}
---

あるいは、Jack-inのオプションをカスタマイズすることによって。
[source,lisp]
---
(setq cider-clojure-cli-parameters "-J-XX:-OmitStackTraceInFastThrow")
---

NOTE: Leiningen はデフォルトで `OmitStackTraceInFastThrow` を無効にする。

=== enrich-classpath に関連するエラー

`cider-jack-in` を実行したときに `enrich-classpath` に関連するエラーが発生した場合は、次のように `enrich-classpath` のインテグレーションを無効にすることができる：

[source,lisp]
----
(setq cider-enrich-classpath nil)
----

=== JDKソースへのナビゲーションが機能しない

まず、enrich-classpath を使っていることを確認してください。`cider-enrich-classpath` は真でなければなりません。 もしあなた自身の repl プロセスを起動しているなら、enrich-classpath Leiningen プラグインか `clojure` ラッパーを持っているはずです。

Linuxを使用していて、`.toUpperCase`のような組み込みメソッドのソースにナビゲートできない場合は、おそらくJDKのソースがインストールされていません。ついでにJDKのJavadocsもインストールしておくといいだろう。Debian/Ubuntuの場合：

[source,shell]
----
$ sudo apt install openjdk-17-source openjdk-17-doc
----

Red Hat/Fedora/CentOS では:
[source,shell]
----
$ sudo dnf install java-17-openjdk-src java-17-openjdk-javadoc
----

Guix では:

[source,shell]
----
$ guix package -i openjdk:jdk
----

NOTE: WindowsとmacOSでは、JDKのソースコードはJDKにバンドルされている。

=== REPLで`RET`を押してもフォームが評価されない

Pareditユーザーですか？REPLバッファを有効にしましたか？

Paredit の最近のバージョン (25+) では、`RET` は `paredit-RET` にバインドされています。このため、`paredit-mode`が有効になっている場合、replが予期しない動作をすることがあります。例えば、`RET`を押した後、最後のフォームを評価せずにハングしてしまうことがあります。

このPareditの動作を無効にするには、`init.el`に以下を追加してください：

[source,lisp]
----
(define-key paredit-mode-map (kbd "RET") nil)
----

=== `No linked CIDER sessions`で対話が失敗する

もし何らかのインタラクティブ機能が `No linked CIDER sessions` というメッセージとともにショートカットされている場合、それは以下のいずれかの理由によるものです：

* replを開始していないプロジェクトのバッファ内のコードを評価しています。
  * この問題は、プロジェクトを開始したものへと切り替えることで解決できます。
  * 単純に、現在のプロジェクトでreplを開始することもできます。
* CIDER/Sesmanの統合にバグがあります。
  * セッションのリンクは一般的に、現在のバッファが REPL のクラスパスに関連し ているかどうかを判断することで動作します。
  * 問題のあるバッファで `M-x cider-debug-sesman-friendly-session-p` を実行することで `*messages*` バッファにエコーされたデバッグ情報を得ることができます。
    * それを読むことで、なぜ CIDER が `(buffer-filename)` とクラスパスの関係を見抜けなかったのかを判断できるかもしれません。
    * この情報を含む詳細な GitHub issue を自由に作成してください。
